[
    {
        "question": "What does the following function do for a given Linked List with first node as head?\r\n\r\n\r\nvoid fun1(struct node* head)\r\n{\r\n  if(head == NULL)\r\n    return;\r\n  \r\n  fun1(head->next);\r\n  printf(\"%d  \", head->data);\r\n}\r\n",
        "answer": [
            "Prints all nodes of linked lists",
            "Prints all nodes of linked list in reverse order",
            "Prints alternate nodes of Linked List",
            "Prints alternate nodes in reverse order"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> fun1() prints the given Linked List in reverse manner. For Linked List 1-&gt;2-&gt;3-&gt;4-&gt;5, fun1() prints 5-&gt;4-&gt;3-&gt;2-&gt;1.   See <a href=\"http://www.geeksforgeeks.org/practice-questions-for-linked-list-and-recursion/\" target=\"_blank\">http://www.geeksforgeeks.org/practice-questions-for-linked-list-and-recursion/</a></div>",
        "keyword": "Linked List",
        "section": "Singly Linked List"
    },
    {
        "question": "Which of the following points is/are true about Linked List data structure when it is compared with array",
        "answer": [
            "Arrays have better cache locality that can make them better in terms of performance.",
            "It is easy to insert and delete elements in Linked List",
            "Random access is not allowed in a typical implementation of Linked Lists",
            "The size of array has to be pre-decided, linked lists can change their size any time. ",
            "All of the above"
        ],
        "correct": "E",
        "explain": "<div class=\"mtq_explanation-text\"> See <a href=\"http://www.geeksforgeeks.org/linked-list-vs-array/\" target=\"_blank\">http://www.geeksforgeeks.org/linked-list-vs-array/</a> for explanation.</div>",
        "keyword": "Linked List"
    },
    {
        "question": "Consider the following function that takes reference to head of a Doubly Linked List as parameter.   Assume that a node of doubly linked list has previous pointer as prev and next pointer as next.  \r\n\r\n\r\nvoid fun(struct node **head_ref)\r\n{\r\n    struct node *temp = NULL;\r\n    struct node *current = *head_ref;\r\n\r\n    while (current !=  NULL)\r\n    {\r\n        temp = current->prev;\r\n        current->prev = current->next;\r\n        current->next = temp;\r\n        current = current->prev;\r\n    }\r\n\r\n    if(temp != NULL )\r\n        *head_ref = temp->prev;\r\n}\r\n\r\n\r\nAssume that reference of head of following doubly linked list is passed to above function\r\n\r\n1 <--> 2 <--> 3 <--> 4 <--> 5 <-->6.\r\n\r\nWhat should be the modified linked list after the function call?",
        "answer": [
            "2 <--> 1 <--> 4 <--> 3 <--> 6 <-->5",
            "5 <--> 4 <--> 3 <--> 2 <--> 1 <-->6.",
            "6 <--> 5 <--> 4 <--> 3 <--> 2 <--> 1.",
            "6 <--> 5 <--> 4 <--> 3 <--> 1 <--> 2"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> The given function reverses the given doubly linked list.   See <a href=\"http://www.geeksforgeeks.org/reverse-a-doubly-linked-list/\" target=\"_blank\">Reverse a Doubly Linked List</a> for details.</div>",
        "keyword": "Linked List"
    },
    {
        "question": "Which of the following sorting algorithms can be used to sort a random linked list with minimum time complexity?",
        "answer": [
            "Insertion Sort",
            "Quick Sort",
            "Heap Sort",
            "Merge Sort"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> Both Merge sort and Insertion sort can be used for linked lists. \r\n\r\nThe slow random-access performance of a linked list makes other algorithms (such as quicksort) perform poorly, and others (such as heapsort) completely impossible.\r\n\r\nSince worst case time complexity of Merge Sort is O(nLogn) and Insertion sort is O(n^2), merge sort is preferred.\r\n\r\nSee following for implementation of merge sort using Linked List. \r\n\r\n<a href=\"http://www.geeksforgeeks.org/merge-sort-for-linked-list/\">http://www.geeksforgeeks.org/merge-sort-for-linked-list/</a></div>",
        "keyword": "Linked List"
    },
    {
        "question": "The following function reverse() is supposed to reverse a singly linked list.  There is one line missing at the end of the function.  \r\n\r\n\r\n/* Link list node */\r\nstruct node\r\n{\r\n    int data;\r\n    struct node* next;\r\n};\r\n\r\n/* head_ref is a double pointer which points to head (or start) pointer \r\n  of linked list */\r\nstatic void reverse(struct node** head_ref)\r\n{\r\n    struct node* prev   = NULL;\r\n    struct node* current = *head_ref;\r\n    struct node* next;\r\n    while (current != NULL)\r\n    {\r\n        next  = current->next;  \r\n        current->next = prev;   \r\n        prev = current;\r\n        current = next;\r\n    }\r\n    /*ADD A STATEMENT HERE*/\r\n}\r\n \r\n\r\n\r\nWhat should be added in place of \"/*ADD A STATEMENT HERE*/\", so that the function correctly reverses a linked list.",
        "answer": [
            "*head_ref = prev;",
            "*head_ref = current;",
            "*head_ref = next;",
            "*head_ref = NULL;"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> *head_ref = prev;\r\n\r\nAt the end of while loop, the <em>prev </em>pointer points to the last node of original linked list.  We need to change *head_ref so that the head pointer now starts pointing to the last node. \r\n\r\nSee the <a href=\"http://geeksquiz.com/data-structures-linked-list-question-5/\">following complete running program</a>.\r\n\r\n[sourcecode language=\"C\" highlight=\"22\"]\r\n#include<stdio.h>\r\n#include<stdlib.h>\r\n \r\n/* Link list node */\r\nstruct node\r\n{\r\n    int data;\r\n    struct node* next;\r\n};\r\n \r\n/* Function to reverse the linked list */\r\nstatic void reverse(struct node** head_ref)\r\n{\r\n    struct node* prev   = NULL;\r\n    struct node* current = *head_ref;\r\n    struct node* next;\r\n    while (current != NULL)\r\n    {\r\n        next  = current-&gt;next;  \r\n        current-&gt;next = prev;   \r\n        prev = current;\r\n        current = next;\r\n    }\r\n    *head_ref = prev;\r\n}\r\n \r\n/* Function to push a node */\r\nvoid push(struct node** head_ref, int new_data)\r\n{\r\n    /* allocate node */\r\n    struct node* new_node =\r\n            (struct node*) malloc(sizeof(struct node));\r\n            \r\n    /* put in the data  */\r\n    new_node-&gt;data  = new_data;\r\n                \r\n    /* link the old list off the new node */\r\n    new_node-&gt;next = (*head_ref);    \r\n        \r\n    /* move the head to point to the new node */\r\n    (*head_ref)    = new_node;\r\n}\r\n \r\n/* Function to print linked list */\r\nvoid printList(struct node *head)\r\n{\r\n    struct node *temp = head;\r\n    while(temp != NULL)\r\n    {\r\n        printf(\"%d  \", temp-&gt;data);    \r\n        temp = temp-&gt;next;  \r\n    }\r\n}    \r\n \r\n/* Drier program to test above function*/\r\nint main()\r\n{\r\n    /* Start with the empty list */\r\n    struct node* head = NULL;\r\n   \r\n     push(&amp;head, 20);\r\n     push(&amp;head, 4);\r\n     push(&amp;head, 15); \r\n     push(&amp;head, 85);      \r\n     \r\n     printList(head);    \r\n     reverse(&amp;head);                      \r\n     printf(\"\\n Reversed Linked list \\n\");\r\n     printList(head);    \r\n     return 0;\r\n}\r\n[/sourcecode]</stdlib.h></stdio.h></div>",
        "keyword": "Linked List"
    },
    {
        "question": "What is the output of following function for start pointing to first node of following linked list?\r\n\r\n1->2->3->4->5->6\r\n\r\n\r\nvoid fun(struct node* start)\r\n{\r\n  if(start == NULL)\r\n    return;\r\n  printf(\"%d  \", start->data); \r\n \r\n  if(start->next != NULL )\r\n    fun(start->next->next);\r\n  printf(\"%d  \", start->data);\r\n}\r\n",
        "answer": [
            "1 4 6 6 4 1",
            "1 3 5 1 3 5",
            "1 2 3 5",
            "1  3  5 5 3 1"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> fun() prints alternate nodes of the given Linked List, first from head to end, and then from end to head. If Linked List has even number of nodes, then skips the last node. </div>",
        "keyword": "Linked List"
    },
    {
        "question": "The following C function takes a simply-linked list as input argument. It modifies the list by moving the last element to the front of the list and returns the modified list. Some part of the code is left blank. Choose the correct alternative to replace the blank line.\r\n\r\n\r\ntypedef struct node \r\n{\r\n  int value;\r\n  struct node *next;\r\n}Node;\r\n \r\nNode *move_to_front(Node *head) \r\n{\r\n  Node *p, *q;\r\n  if ((head == NULL: || (head->next == NULL)) \r\n    return head;\r\n  q = NULL; p = head;\r\n  while (p-> next !=NULL) \r\n  {\r\n    q = p;\r\n    p = p->next;\r\n  }\r\n  _______________________________\r\n  return head;\r\n}\r\n\n",
        "answer": [
            " q = NULL; p->next = head; head = p;",
            " q->next = NULL; head = p; p->next = head;",
            "head = p; p->next = q; q->next = NULL;",
            "q->next = NULL; p->next = head; head = p;"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> See question 1 of <a href=\"http://www.geeksforgeeks.org/data-structures-and-algorithms-set-24/\" target=\"_blank\">http://www.geeksforgeeks.org/data-structures-and-algorithms-set-24/</a></div>",
        "keyword": "Linked List"
    },
    {
        "question": "The following C function takes a single-linked list of integers as a parameter and rearranges the elements of the list. The function is called with the list containing the integers 1, 2, 3, 4, 5, 6, 7 in the given order. What will be the contents of the list after the function completes execution?\r\n\r\n\r\nstruct node \r\n{\r\n  int value;\r\n  struct node *next;\r\n};\r\nvoid rearrange(struct node *list)\r\n{\r\n  struct node *p, * q;\r\n  int temp;\r\n  if ((!list) || !list->next) \r\n      return;\r\n  p = list;\r\n  q = list->next;\r\n  while(q) \r\n  {\r\n     temp = p->value;\r\n     p->value = q->value;\r\n     q->value = temp;\r\n     p = q->next;\r\n     q = p?p->next:0;\r\n  }\r\n}\r\n\n",
        "answer": [
            " 1,2,3,4,5,6,7 ",
            "2,1,4,3,6,5,7 ",
            " 1,3,2,5,4,7,6 ",
            " 2,3,4,5,6,7,1"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> The function rearrange() exchanges data of every node with its next node.  It starts exchanging data from the first node itself.</div>",
        "keyword": "Linked List"
    },
    {
        "question": "In the worst case, the number of comparisons needed to search a singly linked list of  length n for a given element is (GATE CS 2002)\r\n\r\n",
        "answer": [
            "log 2 n ",
            "n/2",
            "log 2 n â€“ 1 ",
            "n"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> In the worst case, the element to be searched has to be compared with all elements of linked list.</div>",
        "keyword": "Linked List"
    },
    {
        "question": "Suppose each set is represented as a linked list with elements in arbitrary order. Which of the operations among union, intersection, membership, cardinality will be the slowest? (GATE CS 2004)",
        "answer": [
            "union only",
            "\tintersection, membership",
            "membership, cardinality",
            "union, intersection"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> For getting intersection of L1 and L2, search for each element of L1 in L2 and print the elements we find in L2.  \r\n\r\nThere can be many ways for getting union of L1 and L2.  One of them is as follows\r\na) Print all the nodes of L1 and print only those which are not present in L2. \r\nb) Print nodes of L2.\r\nAll of these methods will require more operations than intersection as we have to process intersection node plus other nodes.</div>",
        "keyword": "Linked List"
    },
    {
        "question": "Consider the function f defined below. \r\n\r\nstruct item \r\n{ \r\n  int data; \r\n  struct item * next; \r\n}; \r\n\r\nint f(struct item *p) \r\n{ \r\n  return (\r\n          (p == NULL) || \r\n          (p->next == NULL) || \r\n          (( P->data <= p->next->data) && f(p->next))\r\n         ); \r\n} \r\n\r\nFor a given linked list p, the function f returns 1 if and only if  (GATE CS 2003)\r\n\r\n",
        "answer": [
            "not all elements in the list have the same data value.",
            "the elements in the list are sorted in non-decreasing order of data value ",
            "the elements in the list are sorted in non-increasing order of data value ",
            "None of them"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> \r\nThe function f() works as follows\r\n1) If linked list is empty return 1\r\n2) Else If linked list has only one element return 1\r\n3) Else if  node-&gt;data is smaller than equal to node-&gt;next-&gt;data and same thing holds for rest of the list then return 1 \r\n4) Else return 0</div>",
        "keyword": "Linked List"
    },
    {
        "question": "A circularly linked list is used to represent a Queue. A single variable p is used to access the Queue. To which node should p point such that both the operations enQueue and deQueue can be performed in constant time? (GATE 2004)\r\n\n",
        "answer": [
            "rear node",
            "front node",
            "not possible with a single pointer",
            "node next to front"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Answer is not \"(b) front node\", as we can not get rear from front in O(1), but if p is rear we can implement both enQueue and deQueue in O(1) because from rear we can get front in O(1).  Below are sample functions. Note that these functions are just sample are not working. Code to handle base cases is missing.\r\n\r\n[sourcecode language=C]\r\n/* p is pointer to address of rear (double pointer).  This function adds new \r\n   node after rear and updates rear which is *p to point to new node  */\r\nvoid  enQueue(struct node **p, struct node *new_node)\r\n{\r\n    /* Missing code to handle base cases like *p is NULL */\r\n     \r\n     new_node-&gt;next = (*p)-&gt;next;\r\n     (*p)-&gt;next = new_node;\r\n     (*p) = new_node /* new is now rear */\r\n     /* Note that p-&gt;next is again front and  p is rear */\r\n\r\n }\r\n\r\n/* p is pointer to rear. This function removes the front element and \r\n    returns the dequeued element from the queue */\r\nstruct node *deQueue(struct node *p)\r\n{\r\n    /* Missing code to handle base cases like p is NULL,\r\n        p-&gt;next is NULL,...  etc */\r\n\r\n    struct node *temp = p-&gt;next;\r\n    p-&gt;next = p-&gt;next-&gt;next;\r\n    return temp;\r\n    /* Note that p-&gt;next is again front and  p is rear */\r\n}[/sourcecode]<br/><a href=\"http://quiz.geeksforgeeks.org?page_id=148\">Quiz of this Question</a></div>",
        "keyword": "Linked List"
    },
    {
        "question": "What are the time complexities of finding 8th element from beginning and 8th element from end in a singly linked list?\r\n\r\nLet n be the number of nodes in linked list, you may assume that n > 8.",
        "answer": [
            "O(1) and O(n)",
            "O(1) and O(1)",
            "O(n) and O(1)",
            "O(n) and O(n)"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Finding 8th element from beginning requires 8 nodes to be traversed which takes constant time.\r\n\r\nFinding 8th from end requires the complete list to be traversed.</div>",
        "keyword": "Linked List"
    },
    {
        "question": "Is it possible to create a doubly linked list using only one pointer with every node.",
        "answer": [
            "Not Possible",
            "Yes, possible by storing XOR of addresses of previous and next nodes.",
            "Yes, possible by storing XOR of current node and next node",
            "Yes, possible by storing XOR of current node and previous node"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> <a href=\"http://www.geeksforgeeks.org/xor-linked-list-a-memory-efficient-doubly-linked-list-set-1/\" target=\"_blank\">XOR Linked List – A Memory Efficient Doubly Linked List | Set 1</a></div>",
        "keyword": "Linked List"
    },
    {
        "question": "Given pointer to a node X in a singly linked list.  Only one pointer is given, pointer to head node is not given, can we delete the node X from given linked list?",
        "answer": [
            "Possible if X is not last node. Use following two steps  (a) Copy the data of next of X to X.  (b) Delete next of X.",
            "Possible if size of linked list is even.",
            "Possible if size of linked list is odd",
            "Possible if X is not first node. Use following two steps  (a) Copy the data of next of X to X.  (b) Delete next of X."
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Following are simple steps.\r\n<pre>\r\n    struct node *temp  = X-&gt;next;\r\n    X-&gt;data  = temp-&gt;data;\r\n    X-&gt;next  = temp-&gt;next;\r\n    free(temp); </pre></div>",
        "keyword": "Linked List"
    },
    {
        "question": "You are given pointers to first and last nodes of a singly linked list, which of the following operations are dependent on the length of the linked list?",
        "answer": [
            "Delete the first element",
            "Insert a new element as a first element",
            " Delete the last element of the list",
            "Add a new element at the end of the list"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> a) Can be done in O(1) time by deleting memory and changing the first pointer.\r\n\r\nb) Can be done in O(1) time, see push() <a href=\"http://www.geeksforgeeks.org/write-a-function-to-get-nth-node-in-a-linked-list/\" target=\"_blank\">here</a>\r\n\r\nc) Delete the last element requires pointer to previous of last, which can only be obtained by traversing the list.\r\n\r\nd) Can be done in O(1) by changing next of last and then last.\r\n</div>",
        "keyword": "Linked List"
    },
    {
        "question": "Consider the following function to traverse a linked list.\r\n\r\n\r\nvoid traverse(struct Node *head)\r\n{\r\n   while (head->next != NULL)\r\n   {\r\n       printf(\"%d  \", head->data);\r\n       head = head->next;\r\n   }\r\n}\r\n\r\n\r\nWhich of the following is FALSE about above function?",
        "answer": [
            "The function may crash when the linked list is empty",
            "The function doesn't print the last node when the linked list is not empty",
            "The function is implemented  incorrectly because it changes head"
        ],
        "correct": "C",
        "explain": "None",
        "keyword": "Linked List"
    },
    {
        "question": "Let P be a singly linked list. Let Q be the pointer to an intermediate node x in the list. What is the worst-case time complexity of the best known algorithm to delete the node x from the list?",
        "answer": [
            "O(n) ",
            "O(log2 n) ",
            "O(logn) ",
            "O(1)"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> A <strong>simple solution</strong> is to traverse the linked list until you find the node you want to delete. But this solution requires pointer to the head node which contradicts the problem statement.\r\n\r\n<strong>Fast solution</strong> is to copy the data from the next node to the node to be deleted and delete the next node. Something like following.\r\n<pre>\r\n    // Find next node using next pointer\r\n    struct node *temp  = node_ptr-&gt;next;\r\n\r\n    // Copy data of next node to this node\r\n    node_ptr-&gt;data  = temp-&gt;data;\r\n\r\n    // Unlink next node\r\n    node_ptr-&gt;next  = temp-&gt;next;\r\n\r\n    // Delete next node\r\n    free(temp);\r\n</pre>\r\nTime complexity of this approach is O(1)\r\n\r\nRefer <a href=\"http://www.geeksforgeeks.org/given-only-a-pointer-to-a-node-to-be-deleted-in-a-singly-linked-list-how-do-you-delete-it/\">this</a> for implementation.\r\n\r\nNote that this approach doesn't work when node to deleted is last node.  Since the question says intermediate node, we can use this approach.\r\n</div>",
        "keyword": "Linked List"
    },
    {
        "question": "N items are stored in a sorted doubly linked list. For a delete operation, a pointer is provided to the record to be deleted. For a decrease-key operation, a pointer is provided to the record on which the operation is to be performed. An algorithm performs the following operations on the list in this order:\r\nΘ(N) delete, O(log N) insert, O(log N) find,  and Θ(N) decrease-key\r\n\r\nWhat  is  the  time  complexity  of  all  these operations put together",
        "answer": [
            "O(Log2N)",
            "O(N)",
            "O(N2)",
            "Θ(N2 Log N)"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> The time complexity of decrease-key operation is Θ(1) since we have the pointer to the record where we have to perform the operation. However, we must keep the doubly linked list sorted and after the decrease-key operation we need to find the new location of the key. This step will take Θ(N) time and since there are Θ(N) decrease-key operations, the time complexity becomes O(N²).\r\n\r\nNote that the other three operations have a lower bound than this one.</div>",
        "keyword": "Linked List"
    },
    {
        "question": "Let p be a pointer as shown in the figure in a single linked list.\r\n\r\nWhat do the following assignment statements achieve ?\r\nq: = p → next\r\np → next:= q → next \r\nq → next:=(q → next) → next \r\n(p → next) → next:= q",
        "answer": "None",
        "correct": "None",
        "explain": "<div class=\"mtq_explanation-text\"> Initially p points to i and q points to i+1.\r\n<ol>\n<li>p -&gt;next:= q -&gt;next : i next points to i+2</li>\n<li>q -&gt;next:=(q -&gt;next) ? next : i+1 next points to i+3</li>\n<li>(p -&gt;next) -&gt;next:= q : i+2 next points to i+1</li>\n</ol>\r\nDeducing finally i-&gt;i+2-&gt;i+1-&gt;i+3.\r\n\r\nSo, it swaps the two nodes next to p in the linked list. \r\n\r\n</div>",
        "keyword": "Linked List"
    },
    {
        "question": "The concatenation of two lists is to be performed in O(1) time. Which of the following implementations of a list should be used?",
        "answer": [
            "singly linked list",
            "doubly linked list",
            "circular doubly linked list",
            "array implementation of lists"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Singly linked list cannot be answer because we cannot find last element of a singly linked list in O(1) time.\r\n\r\nDoubly linked list cannot also not be answer because of the same reason as singly linked list.</div>",
        "keyword": "Linked List"
    },
    {
        "question": "Consider the following piece of 'C' code fragment that removes duplicates from an ordered list of integers.\r\nNode  *remove-duplicates(Node *head, int *j)\r\n{\r\n    Node *t1, *t2;\r\n    *j=0;\r\n    t1 = head;\r\n    if (t1! = NULL) t2 = t1 →next;\r\n    else return head;\r\n    *j = 1;\r\n    if(t2 == NULL)\r\n        return head;\r\n    while t2 != NULL)\r\n    {\r\n        if (t1.val != t2.val) --------------------------→ (S1)\r\n        {\r\n            (*j)++; t1 -> next = t2; t1 = t2: ----------→ (S2)\r\n        }\r\n        t2 = t2 →next;\r\n    }\r\n    t1 →next = NULL;\r\n    return head;\r\n}\r\n\r\nAssume the list contains n elements (n≥2) in the following questions.\r\na). How many times is the comparison in statement S1 made?\r\nb). What is the minimum and the maximum number of times statements marked S2 get executed?\r\nc). What is the significance of the value in the integer pointed to by j when the function completes?",
        "answer": "None",
        "correct": "None",
        "explain": "<div class=\"mtq_explanation-text\"> <ul>\n<li><b>(a).</b> n-1 times, since comparison is pairwise for n elements.\r\n</li>\n<li><b>(b).</b> maximum : n-1 for all distinct elements, minimum: 0 for all same elements.\r\n</li>\n<li><b>(C).</b> j keeps count of distinct nodes in the list.\r\n</li>\n</ul></div>",
        "keyword": "Linked List"
    },
    {
        "question": "Consider the following statements:\r\n\r\ni.   First-in-first out types of computations are efficiently supported by STACKS.\r\nii.  Implementing LISTS on linked lists is more efficient than implementing LISTS on\r\n     an array for almost all the basic LIST operations.\r\niii. Implementing QUEUES on a circular array is more efficient than implementing QUEUES\r\n     on a linear array with two indices.\r\niv.  Last-in-first-out type of computations are efficiently supported by QUEUES.\r\n\r\n\r\nWhich of the following is correct?\r\n ",
        "answer": [
            "(ii) and (iii) are true",
            "(i) and (ii) are true",
            "(iii) and (iv) are true",
            "(ii) and (iv) are true"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> i -STACK is the data structure that follows Last In First Out (LIFO) or First In Last Out (FILO) order, in which the element which is inserted at last is removed out first.  \r\n\r\nii - Implementing LISTS on linked lists is more efficient than implementing it on an array for almost all the basic LIST operations because the insertion and deletion of elements can be done in O(1) in Linked List but it takes O(N) time in Arrays. \r\n\r\niii- Implementing QUEUES on a circular array is more efficient than implementing it on a linear array with two indices because using circular arrays, it takes less space and can reuse it again. \r\n\r\niv - QUEUE is the data structure that follows First In First Out (FIFO) or Last In Last Out (LILO) order, in which the element which is inserted first is removed first.\r\n\r\nonly (ii) and (iii) are TRUE. \r\nOption (A) is correct.</div>",
        "keyword": "Linked List"
    },
    {
        "question": "Suppose there are two singly linked lists both of which intersect at some point and become a single linked list. The head or start pointers of both the lists are known, but the intersecting node and lengths of lists are not known.\r\nWhat is worst case time complexity of optimal algorithm to find intersecting node from two intersecting linked lists?",
        "answer": [
            "Θ(n*m), where m, n are lengths of given lists",
            "Θ(n^2), where m>n and m, n are lengths of given lists",
            "Θ(m+n), where m, n are lengths of given lists",
            "Θ(min(n, m)), where m, n are lengths of given lists"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> This takes Θ(m+n) time and O(1) space in worst case, where M and N are the total length of the linked lists.\r\n<ol>\n<li>Traverse the two linked list to find m and n.</li>\n<li>Get back to the heads, then traverse |m − n| nodes on the longer list.</li>\n<li>Now walk in lock step and compare the nodes until you found the common ones.</li>\n</ol>\r\n\r\nOption (C) is correct.</div>",
        "keyword": "Linked List"
    },
    {
        "question": "S1 : Anyone of the followings can be used to declare a node for a singly linked list. If we use the first declaration, “struct node * nodePtr;” would be used to declare pointer to a node. If we use the second declaration, “NODEPTR nodePtr;” can be used to declare pointer to a node.\r\n\r\n/* First declaration */\r\nstruct node {\r\nint data;\r\nstruct node * nextPtr;\r\n};\r\n\r\n/* Second declaration */\r\ntypedef struct node{\r\nint data;\r\nNODEPTR nextPtr;\r\n} * NODEPTR;\r\n\r\n\r\nS2 : Anyone of the following can be used to declare a node for a singly linked list and “NODEPTR nodePtr;” can be used to declare pointer to a node using any of the following \r\n\r\n/* First declaration */\r\ntypedef struct node\r\n{\r\n int data;\r\n struct node *nextPtr;\r\n}* NODEPTR;\r\n\r\n/* Second declaration */\r\nstruct node\r\n{\r\n int data;\r\n struct node * nextPtr;\r\n};\r\ntypedef struct node * NODEPTR;\r\n",
        "answer": [
            "Statement S1 is true and statement S2 is false",
            "Statement S2 is true and statement S1 is false",
            "Both statements S1 and S2 are true",
            "Neither statement S1 nor statement S2 is true"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> S1 : The <em>typedef</em> usage is incorrect. Basically, we can’t use yet to be typedef-ed data type inside while applying <em>typedef</em> itself. Here, NODEPTR is yet to be defined (i.e. typedef-ed) and we are using NODEPTR inside the struct itself.\r\n\r\n\r\nS2 : Yes. Both are equivalent. Either of the above declarations can be used for “NODEPTR nodePtr;”. In fact, first one is the compact form of second one.</div>",
        "keyword": "Linked List"
    },
    {
        "question": "A queue is implemented using a non-circular singly linked list. The queue has a head pointer and a tail pointer, as shown in the figure. Let n denote the number of nodes in the queue. Let 'enqueue' be implemented by inserting a new node at the head, and 'dequeue' be implemented by deletion of a node from the tail.\r\n\r\n\n\r\nWhich one of the following is the time complexity of the most time-efficient implementation of 'enqueue' and 'dequeue, respectively, for this data structure?",
        "answer": [
            "Θ(1),  Θ(1)",
            "Θ(1),  Θ(n)",
            "Θ(n),  Θ(1)",
            "Θ(n),  Θ(n)"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> For Enqueue operation, performs in constant amount of time (i.e., Θ(1)), because it modifies only two pointers, i.e., \r\n<pre>\r\nCreate a Node P.\r\nP--&gt;Data = Data\r\nP--&gt;Next = Head\r\nHead = P\r\n</pre>\r\n\r\nFor Dequeue operation, we need address of second last node of single linked list to make NULL of its next pointer. Since we can not access its previous node in singly linked list, so need to traverse entire linked list to get second last node of linked list, i.e.,\r\n<pre>\r\ntemp = head;\r\n While( temp-Next--&gt;Next != NULL){\r\n        temp = temp-Next;\r\n        }\r\ntemp--&gt;next = NULL;\r\nTail = temp;\r\n</pre>\r\nSince, we are traversing entire linked for each Dequeue, so time complexity will be Θ(n).\r\n\r\nOption (B) is correct.\r\n\r\n<iframe allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen=\"\" frameborder=\"0\" height=\"315\" src=\"https://www.youtube.com/embed/j9Vmf5yRw-I?start=2566\" title=\"YouTube video player\" width=\"560\"></iframe>\n</div>",
        "keyword": "Linked List"
    },
    {
        "question": "In a doubly linked list, the number of pointers affected for an insertion operation will be",
        "answer": [
            "4",
            "0",
            "1",
            "None of these"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> This depends on <a href=\"https://www.geeksforgeeks.org/doubly-linked-list/\" rel=\"noopener\" target=\"_blank\">whether we are inserting the new node </a>in the middle of the list (surrounded by two nodes), or at the head or tail of the list. Insertion at the middle node will affect 4 pointers whereas at the head or tail will affect only 2 pointers.\r\n\r\nSo, option (D) is correct.</div>",
        "keyword": "Linked List"
    },
    {
        "question": "Consider an implementation of unsorted single linked list. Suppose it has its representation with a head and a tail pointer (i.e. pointers to the first and last nodes of the linked list). Given the representation, which of the following operation can not be implemented in O(1) time ?",
        "answer": [
            "Insertion at the front of the linked list.",
            "Insertion at the end of the linked list.",
            "Deletion of the front node of the linked list.",
            "Deletion of the last node of the linked list."
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> \r\nDeletion of the last node of the linked list, we need address of second last node of single linked list to make NULL of its next pointer. Since we can not access its previous node in singly linked list, so need to traverse entire linked list to get second last node of linked list.\r\nSo, option (D) is correct.</div>",
        "keyword": "Linked List"
    },
    {
        "question": "Consider a single linked list where F and L are pointers to the first and last elements respectively of the linked list. The time for performing which of the given operations depends on the length of the linked list?\r\n\r\n\n",
        "answer": [
            "Delete the first element of the list",
            "Interchange the first two elements of the list",
            "Delete the last element of the list",
            "Add an element at the end of the list"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> If F and L are pointers to the first and last elements respectively of the linked list, then:\r\ni) Deleting the first element of the list will not depend on the length of the link list as F = F-&gt;next and delete first node.\r\nii) Interchanging the first two elements of the list will also not require the length of linked list, simply by taking a temp node, swap the two nodes of the list.\r\niii) Deleting the last element of the list will require the length traversal of the list so as to obtain the pointer of the node previous to the last node.\r\niv) Adding an element at the end of the list, can be done by making L-&gt;next = new node\r\n\r\nSo, correct option is (C).</div>",
        "keyword": "Linked List"
    },
    {
        "question": "The following steps in a linked list\r\n p = getnode()\r\n info (p) = 10\r\n next (p) = list\r\n list = p\r\nresult in which type of operation?",
        "answer": [
            "pop operation in stack",
            "removal of a node ",
            "inserting a node",
            "modifying an existing node"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> p = getnode() // getnode() allocates the space which is equal to the size of the node type structure and returns a pointer.\r\ninfo (p) = 10 // value of the new node is equal to 10\r\nnext (p) = list // adding new node to the list.\r\n\r\nClearly, through these steps, insertion of a node is performed. \r\nOption (C) is correct.</div>",
        "keyword": "Linked List"
    },
    {
        "question": "Consider the following conditions: \r\n(a)The solution must be feasible, i.e. it must satisfy all the supply and demand constraints. \r\n(b)The number of positive allocations must be equal to m1n21, where m is the number of rows and n is the number of columns. \r\n(c)All the positive allocations must be in independent positions. \r\nThe initial solution of a transportation problem is said to be non-degenerate basic feasible solution if it satisfies:\r\nCodes:\t\t\r\n",
        "answer": [
            "(a) and (b) only",
            "(a) and (c) only",
            "(b) and (c) only",
            "(a), (b) and (c)"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> The initial solution of a transportation problem is said to be non-degenerate basic feasible solution if it satisfies:\r\n(a)The solution must be feasible, i.e. it must satisfy all the supply and demand constraints. \r\n(b)The number of positive allocations must be equal to m1n21, where m is the number of rows and n is the number of columns. \r\n(c)All the positive allocations must be in independent positions. \r\nSo, option (D) is correct.</div>",
        "keyword": "Linked List"
    },
    {
        "question": "The time required to search an element in a linked list of length n is",
        "answer": [
            "O (log n)",
            "O (n)",
            "O (1)",
            "O(n2)"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> In the worst case, the element to be searched has to be compared with all elements of linked list. It will take O(n) time to search the element.\r\n\r\nSo, option (B) is correct.</div>",
        "keyword": "Linked List"
    },
    {
        "question": "Which of the following operations is performed more efficiently by doubly linked list than by linear linked list?\r\n",
        "answer": [
            "Deleting a node whose location is given",
            "Searching an unsorted list for a given item",
            " Inserting a node after the node with a given location",
            " Traversing the list to process each node"
        ],
        "correct": "A",
        "explain": "None",
        "keyword": "Linked List"
    },
    {
        "question": "The time required to search an element in a linked list of length n is",
        "answer": [
            "O (log n)",
            "O (n)",
            "O (1)",
            "O(n2)"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> In the worst case, the element to be searched has to be compared with all elements of linked list, so the time complexity is O(n).\r\n\r\nOption (B) is correct.</div>",
        "keyword": "Linked List"
    },
    {
        "question": "The minimum number of fields with each node of doubly linked list is",
        "answer": [
            "1",
            "2",
            "3",
            "4"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> In general, each node of doubly link list always has 3 fields, i.e., the previous node pointer, the data field, and the next node pointer, see - <a href=\"https://www.geeksforgeeks.org/doubly-linked-list/\" rel=\"noopener\" target=\"_blank\">doubly linked list introduction</a>\r\n\r\nSo, answer should be option (C) 3.\r\n\r\nHowever, each node of doubly linked list can have only 2 fields, i.e., XOR pointer field, and data field. This XOR pointer field can points both previous node and next node, this is the best case with data field. This is called as memory efficient doubly linked list, see - <a href=\"https://www.geeksforgeeks.org/xor-linked-list-a-memory-efficient-doubly-linked-list-set-1/\" rel=\"noopener\" target=\"_blank\">XOR linked list – a memory efficient doubly linked list | set 1</a> \r\n\r\n\r\nAlso, if we remove data node from the XOR linked list, then each node of this doubly linked list can have only 1 field, i.e., XOR pointer field. But, this is without data field so, this doubly linked list does not make sense.\r\n\r\n\r\n</div>",
        "keyword": "Linked List"
    },
    {
        "question": "A doubly linked list is declared as\r\nstruct Node {\r\n       int Value;\r\n       struct Node *Fwd;\r\n       struct Node *Bwd;\r\n);\r\nWhere Fwd and Bwd represent forward and backward link to the adjacent elements of the list. Which of the following segments of code deletes the node pointed to by X from the doubly linked list, if it is assumed that X points to neither the first nor the last node of the list?\r\n",
        "answer": [
            "X->Bwd->Fwd = X->Fwd; X->Fwd->Bwd = X->Bwd ;",
            "X->Bwd.Fwd = X->Fwd ; X.Fwd->Bwd = X->Bwd ;",
            "X.Bwd->Fwd = X.Bwd ; X->Fwd.Bwd = X.Bwd ;",
            "X->Bwd->Fwd = X->Bwd ; X->Fwd->Bwd = X->Fwd;"
        ],
        "correct": "A",
        "explain": "None",
        "keyword": "Linked List"
    },
    {
        "question": "Consider a singly linked list of the form where F is a pointer to the first element in the linked list and L is the pointer to the last element in the list. The time of which of the following operations depends on the length of the list?",
        "answer": [
            "Delete the last element of the list",
            "Delete the first element of the list",
            "Add an element after the last element of the list",
            "Interchange the first two elements of the list"
        ],
        "correct": "A",
        "explain": "None",
        "keyword": "Linked List"
    },
    {
        "question": "What is the worst case time complexity of inserting n elements into an empty linked list, if the linked list needs to be maintained in sorted order ?",
        "answer": [
            "Θ(n)",
            "Θ(n log n)",
            "Θ(n2)",
            "Θ(1)"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> This question is ambiguous: \"needs to be maintained in sorted order\", there are two possible cases:\r\n<ol>\n<li>Needs to be maintained in <i>sorted order on each step (after each insertion)</i>.\r\nWhen we are inserting <i>an element</i> in to empty linked list and to <a href=\"https://www.geeksforgeeks.org/given-a-linked-list-which-is-sorted-how-will-you-insert-in-sorted-way/\" rel=\"noopener\" target=\"_blank\">perform sorted order</a> list of every element will take O(n<sup>2</sup>).\r\n<a href=\"https://www.geeksforgeeks.org/linked-list-set-2-inserting-a-node/\" rel=\"noopener\" target=\"_blank\">Each Insertion into a sorted linked</a> list will take θ(n) and hence the total cost for n operations is θ(n<sup>2</sup>).\r\n</li>\n<li>Needs to be maintained in <i>sorted order on final step (only after all insertion)</i>.\r\nWhen we are inserting all elements into an empty linked list and to perform a sorted list (<a href=\"https://www.geeksforgeeks.org/merge-sort-for-linked-list/\" rel=\"noopener\" target=\"_blank\">using merge sort</a>) after inserting all elements will take O(n log n) time.\r\n</li>\n</ol>\r\n\r\nOfficial answer by GATE is Θ(n<sup>2</sup>).\r\n\r\n\r\n<iframe allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen=\"\" frameborder=\"0\" height=\"315\" src=\"https://www.youtube.com/embed/fP8QED8d6ws?start=2929\" title=\"YouTube video player\" width=\"560\"></iframe></div>",
        "keyword": "Linked List"
    },
    {
        "question": "Consider the following ANSI C program:\r\n\r\n#include < stdio.h >\r\n#include < stdlib.h >\r\nstruct Node{\r\n        int value;\r\n        struct Node *next;};\r\nint main( ) {\r\n    struct Node *boxE, *head, *boxN; int index=0;\r\n    boxE=head= (struct Node *) malloc(sizeof(struct Node));\r\n    head → value = index;\r\n    for (index =1; index<=3; index++){\r\n        boxN = (struct Node *) malloc (sizeof(struct Node));\r\n        boxE → next = boxN;\r\n        boxN → value = index;\r\n        boxE = boxN; }\r\nfor (index=0; index<=3; index++) {\r\n    printf(“Value at index %d is %dn”, index, head → value);\r\n    head = head → next;\r\n    printf(“Value at index %d is %dn”, index+1, head → value); } } \r\nWhich one of the following statements below is correct about the program?",
        "answer": [
            "Upon execution, the program creates a linked-list of five nodes",
            "Upon execution, the program goes into an infinite loop",
            "It has a missing return which will be reported as an error by the compiler",
            "It dereferences an uninitialized pointer that may result in a run-time error"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> <p>When you debug loop 1 you will get the linked list of size 4 </p>\n<p>In the second loop value will be printed 0 0 1 1 2 2 3 3 after that head will be pointing to some random location and result in run-time error. <br/>Correct Option (D)</p>\n<iframe allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen=\"\" frameborder=\"0\" height=\"315\" src=\"https://www.youtube.com/embed/I43aLH5qEBc?start=2774\" title=\"YouTube video player\" width=\"560\"></iframe></div>",
        "keyword": "Linked List"
    },
    {
        "question": "\nConsider the problem of reversing a singly linked list. To take an example, given the linked list below, \n\nthe reversed linked list should look like \n\nWhich one of the following statements is TRUE about the time complexity of algorithms that solve the above problem in O(1) space?\n",
        "answer": [
            "\nThe best algorithm for the problem takes [Tex]theta (n)   [/Tex] time in the worst case\n",
            "\nThe best algorithm for the problem takes [Tex]theta(nlogn)   [/Tex] time in the worst case. \n",
            "\nThe best algorithm for the problem takes [Tex]theta(n^{2})   [/Tex] time in the worst case\n",
            "\nIt is not possible to reverse a singly linked list in O(1) space. \n"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\">\n<p>The given linked list is a reverse linked list and the best algorithm in reverse linked list takes <img alt=\"theta (n)   \" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"27\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-70e6bb00da28511294ba9fcff0829bb6_l3.png\" style=\"vertical-align: -7px;\" title=\"Rendered by QuickLaTeX.com\" width=\"95\"> time in the worst case. So, option A is the correct answer. </img></p>\n</div>",
        "keyword": "Linked List"
    },
    {
        "question": "Following is C like pseudo code of a function that takes a number as an argument, and uses a stack S to do processing.\r\n\r\n\r\nvoid fun(int n)\r\n{\r\n    Stack S;  // Say it creates an empty stack S\r\n    while (n > 0)\r\n    {\r\n      // This line pushes the value of n%2 to stack S\r\n      push(&S, n%2);\r\n\r\n      n = n/2;\r\n    }\r\n\r\n    // Run while Stack S is not empty\r\n    while (!isEmpty(&S))\r\n      printf(\"%d \", pop(&S)); // pop an element from S and print it\r\n}\r\n\r\n\r\nWhat does the above function do in general?",
        "answer": [
            "Prints binary representation of n in reverse order",
            "Prints binary representation of n",
            "Prints the value of Logn",
            "Prints the value of Logn in reverse order"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> See method 2 of <a href=\"http://www.geeksforgeeks.org/binary-representation-of-a-given-number/\" target=\"_blank\">http://www.geeksforgeeks.org/binary-representation-of-a-given-number/</a> for explanation.</div>",
        "keyword": "Stack"
    },
    {
        "question": "Which one of the following is an application of Stack Data Structure?",
        "answer": [
            "Managing function calls",
            "The stock span problem",
            "Arithmetic expression evaluation",
            "All of the above"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> See <a href=\"http://en.wikipedia.org/wiki/Stack_(abstract_data_type)#Applications\" target=\"_blank\">http://en.wikipedia.org/wiki/Stack_(abstract_data_type)#Applications</a></div>",
        "keyword": "Stack"
    },
    {
        "question": "Which of the following is true about linked list implementation of stack?",
        "answer": [
            "In push operation, if new nodes are inserted at the beginning of linked list, then in pop operation, nodes must be removed from end.",
            "In push operation, if new nodes are inserted at the end, then in pop operation, nodes must be removed from the beginning.",
            "Both of the above ",
            "None of the above"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> To keep the <strong>L</strong>ast <strong>I</strong>n <strong>F</strong>irst <strong>O</strong>ut order, a stack can be implemented using linked list in two ways:\r\n\r\na) In push operation, if new nodes are inserted at the beginning of linked list, then in pop operation, nodes must be removed from beginning.\r\n\r\nb) In push operation, if new nodes are inserted at the end of linked list, then in pop operation, nodes must be removed from end.\r\n\r\n</div>",
        "keyword": "Stack"
    },
    {
        "question": "Consider the following pseudocode that uses a stack\r\n\r\n\r\n   declare a stack of characters\r\n   while ( there are more characters in the word to read )\r\n   {\r\n      read a character\r\n      push the character on the stack\r\n   }\r\n   while ( the stack is not empty )\r\n   {\r\n      pop a character off the stack\r\n      write the character to the screen\r\n   }\r\n\r\n\r\nWhat is output for input \"geeksquiz\"?\r\n",
        "answer": [
            "geeksquizgeeksquiz",
            "ziuqskeeg",
            "geeksquiz",
            "ziuqskeegziuqskeeg"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Since the stack data structure follows LIFO order.  When we pop() items from stack, they are popped in reverse order of their insertion (or push())</div>",
        "keyword": "Stack"
    },
    {
        "question": "Following is an incorrect pseudocode for the algorithm which is supposed to determine whether a sequence of parentheses is balanced:\r\n\r\n   declare a character stack \r\n   while ( more input is available)\r\n   {\r\n      read a character\r\n      if ( the character is a '(' ) \r\n         push it on the stack\r\n      else if ( the character is a ')' and the stack is not empty )\r\n         pop a character off the stack\r\n      else\r\n         print \"unbalanced\" and exit\r\n    }\r\n    print \"balanced\"\r\n\r\nWhich of these unbalanced sequences does the above code think is balanced?\r\n\r\nSource: http://www.cs.colorado.edu/~main/questions/chap07q.html",
        "answer": [
            "((())",
            "())(()",
            "(()()))",
            "(()))()"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> At the end of while loop, we must check whether the stack is empty or not.  For input ((()), the stack doesn't remain empty after the loop.  See <a href=\"http://www.geeksforgeeks.org/check-for-balanced-parentheses-in-an-expression/\" target=\"_blank\">http://www.geeksforgeeks.org/check-for-balanced-parentheses-in-an-expression/</a> for details.</div>",
        "keyword": "Stack"
    },
    {
        "question": "The following postfix expression with single digit operands is evaluated using a stack:\r\n              8 2 3 ^ / 2 3 * + 5 1 * - \r\nNote that ^ is the exponentiation operator. The top two elements of the stack after the first * is evaluated are:",
        "answer": [
            "6, 1",
            "5, 7",
            "3, 2",
            "1, 5"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> The algorithm for evaluating any postfix expression is fairly straightforward:\r\n<pre>1. While there are input tokens left\r\n    o Read the next token from input.\r\n    o If the token is a value\r\n       + Push it onto the stack.\r\n    o Otherwise, the token is an operator \r\n      (operator here includes both operators, and functions).\r\n       * It is known a priori that the operator takes n arguments.\r\n       * If there are fewer than n values on the stack\r\n       <strong> (Error)</strong> The user has not input sufficient values in the expression.\r\n       * Else, Pop the top n values from the stack.\r\n       * Evaluate the operator, with the values as arguments.\r\n       * Push the returned results, if any, back onto the stack.\r\n2. If there is only one value in the stack\r\n    o That value is the result of the calculation.\r\n3. If there are more values in the stack\r\n    o <strong>(Error) </strong> The user input has too many values.</pre>\r\nSource for algorithm: <a href=\"http://en.wikipedia.org/wiki/Reverse_Polish_notation#The_postfix_algorithm\">http://en.wikipedia.org/wiki/Reverse_Polish_notation#The_postfix_algorithm</a>\r\n\r\nLet us run the above algorithm for the given expression.\r\nFirst three tokens are values, so they are simply pushed. After pushing 8, 2 and 3, the stack is as follows\r\n<pre>    8, 2, 3</pre>\r\nWhen ^ is read, top two are popped and power(2^3) is calculated\r\n<pre>    8, 8</pre>\r\nWhen / is read, top two are popped and division(8/8) is performed\r\n<pre>    1</pre>\r\nNext two tokens are values, so they are simply pushed. After pushing 2 and 3, the stack is as follows\r\n<pre>    1, 2, 3</pre>\r\nWhen * comes, top two are popped and multiplication is performed.\r\n<pre>    1, 6</pre></div>",
        "keyword": "Stack"
    },
    {
        "question": "Let S be a stack of size n >= 1. Starting with the empty stack, suppose we push the first n natural numbers in sequence, and then perform n pop operations. Assume that Push and Pop operation take X seconds each, and Y seconds elapse between the end of one such stack operation and the start of the next operation. For m >= 1, define the stack-life of m as the time elapsed from the end of Push(m) to the start of the pop operation that removes m from S. The average stack-life of an element of this stack is",
        "answer": [
            "n(X+ Y)",
            "3Y + 2X",
            "n(X + Y)-X",
            "Y + 2X"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> We can easily arrive at the result by taking few examples.</div>",
        "keyword": "Stack"
    },
    {
        "question": "A single array A[1..MAXSIZE] is used to implement two stacks. The two stacks grow from opposite ends of the array. Variables top1 and top2 (topl< top 2) point to the location of the topmost element in each of the stacks. If the space is to be used efficiently, the condition for “stack full” is (GATE CS 2004)\r\n",
        "answer": [
            "(top1 = MAXSIZE/2) and (top2 = MAXSIZE/2+1)",
            "top1 + top2 = MAXSIZE",
            "(top1= MAXSIZE/2) or (top2 = MAXSIZE)",
            "top1= top2 -1"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> If we are to use space efficiently then size of the any stack can be more than MAXSIZE/2.  \r\nBoth stacks will grow from both ends and if any of the stack top reaches near to the other top then stacks are full. So the condition will be top1 = top2 -1 (given that top1 &lt; top2)</div>",
        "keyword": "Stack"
    },
    {
        "question": "Assume that the operators +, -, × are left associative and ^ is right associative. The order of precedence (from highest to lowest) is ^, x , +, -. The postfix expression corresponding to the infix expression a + b × c - d ^ e ^ f is ",
        "answer": [
            "abc × + def ^ ^ -",
            "abc × + de ^ f ^ -",
            "ab + c × d - e ^ f ^",
            "- + a × bc ^ ^ def"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> ^ is right assosciative.\r\n\r\n<a href=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/12/parul_10.png\"><img alt=\"parul_10\" class=\"alignnone size-full wp-image-29206\" height=\"535\" src=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/12/parul_10.png\" width=\"554\"/></a>\r\n\r\nSee <a href=\"http://geeksquiz.com/stack-set-2-infix-to-postfix/\" target=\"_blank\">http://geeksquiz.com/stack-set-2-infix-to-postfix/</a>\r\n\r\nThis solution is contributed by <strong>parul Sharma.</strong>\n</div>",
        "keyword": "Stack"
    },
    {
        "question": "\nTo evaluate an expression without any embedded function calls : \n",
        "answer": [
            "As many stacks as the height of the expression tree are needed",
            "One stack is enough",
            "Two stacks are needed",
            "A Turing machine is needed in the general case"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\">\n<p>Any expression can be converted into Postfix or Prefix form. <br/><br/><br/>Prefix and postfix evaluation can be done using a single stack. <br/><br/><br/>For example : Expression '10 2 8 * + 3 -' is given. <br/>PUSH 10 in the stack. <br/>PUSH 2 in the stack. <br/>PUSH 8 in the stack. <br/>When operator '*' occurs, POP 2 and 8 from the stack. <br/>PUSH 2 * 8 = 16 in the stack. <br/>When operator '+' occurs, POP 16 and 10 from the stack. <br/>PUSH 10 * 16 = 26 in the stack. <br/>PUSH 3 in the stack. <br/>When operator '-' occurs, POP 26 and 3 from the stack. <br/>PUSH 26 - 3 = 23 in the stack. <br/>So, 23 is the answer obtained using single stack. <br/><br/><br/> <br/><br/>Thus, option (A) is correct. <br/><br/> <br/><br/>Please comment below if you find anything wrong in the above post. <br/><br/> </p>\n</div>",
        "keyword": "Stack"
    },
    {
        "question": "The result evaluating the postfix expression 10 5 + 60 6 / * 8 –  is",
        "answer": [
            "284 ",
            "213",
            "142 ",
            "71"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> <a href=\"http://geeksquiz.com/stack-set-4-evaluation-postfix-expression/\">http://geeksquiz.com/stack-set-4-evaluation-postfix-expression/</a></div>",
        "keyword": "Stack"
    },
    {
        "question": "A function f defined on stacks of integers satisfies the following properties. f(∅) = 0 and f (push (S, i)) = max (f(S), 0) + i for all stacks S and integers i.\r\nIf a stack S contains the integers 2, -3, 2, -1, 2 in order from bottom to top, what is f(S)?",
        "answer": [
            "6",
            "4",
            "3",
            "2"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> <br/>\r\nf(S) = 0,  max(f(S), 0) = 0,  i = 2\r\nf(S)<sub>new</sub> = max(f(S), 0) + i = 0 + 2 = 2\r\n<br/>\r\nf(S) = 2,  max(f(S), 0) = 2,  i = -3\r\nf(S)<sub>new</sub> = max(f(S), 0) + i = 2 - 3 = -1\r\n<br/>\r\nf(S) = -1,  max(f(S), 0) = 0,  i = 2\r\nf(S)<sub>new</sub> = max(f(S), 0) + i = 0 + 2 = 2\r\n<br/>\r\nf(S) = 2,  max(f(S), 0) = 2,  i = -1\r\nf(S)<sub>new</sub> = max(f(S), 0) + i = 2  - 1 = 1\r\n<br/>\r\nf(S) = 1,  max(f(S), 0) = 1,  i = 2\r\nf(S)<sub>new</sub> = max(f(S), 0) + i = 1 + 2  = 3\r\n<br/> <br/>\r\nThus, option (C) is correct.\r\n<br/> <br/>\r\nPlease comment below if you find anything wrong in the above post.\r\n\r\n</div>",
        "keyword": "Stack"
    },
    {
        "question": "Consider the following C program:\r\n\r\n\r\n   #include \r\n           #define EOF -1\r\n           void push (int); /* push the argument on the stack */\r\n           int pop  (void); /* pop the top of the stack */\r\n           void flagError ();\r\n           int main ()\r\n          {         int c, m, n, r;\r\n                     while ((c = getchar ()) != EOF)\r\n                    { if  (isdigit (c) )\r\n                               push (c);\r\n                     else if ((c == '+') || (c == '*'))\r\n                    {          m = pop ();\r\n                                n = pop ();\r\n                                r = (c == '+') ? n + m : n*m;\r\n                                push (r);\r\n                      }\r\n                      else if (c != ' ')\r\n                               flagError ();\r\n             }\r\n              printf(\"% c\", pop ());\r\n}\r\n\r\n\r\nWhat is the output of the program for the following input ?\r\n5 2 * 3 3 2 + * +",
        "answer": [
            "15",
            "25",
            "30",
            "150"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\">  \r\n\r\n<span style=\"font-size: small;\">The function of the program is:-</span>\n<span style=\"font-size: small;\">1) If the current character is a digit it pushes into stack\r\n2) Else if the current character is operator,</span>  <span style=\"font-size: small;\">it pops two elements and then performs the operation.\r\n</span><span style=\"font-size: small;\">Finally it pushes the resultant element into stack.\r\nInitially stack s is empty. 5 2 * 3 3 2 + * +\r\n</span> <span style=\"font-size: small;\">1) 5 -&gt; It pushes into s\r\n</span> <span style=\"font-size: small;\">2) 2 -&gt; It pushes into s\r\n</span> <span style=\"font-size: small;\">3) * -&gt; It pops two elements n = 2, m=5 n*m = 10 It pushes 10 into s\r\n4) 3 -&gt; It pushes into s\r\n</span> <span style=\"font-size: small;\">5) 3 -&gt; It pushes into s\r\n6) 2 -&gt; It pushes into s\r\n7) + -&gt; n=2, m=3 n+m=5 It pushes 5 into s\r\n8) * -&gt; n=5, m=3 n*m=15 It pushes 15 into s\r\n</span> <span style=\"font-size: small;\">9) + -&gt; n=15, m=10 n+m = 25 It pushes 25 into s.</span>\r\n\r\n \r\n\r\n<span style=\"font-size: small;\">Finally the result value is the only element present in stack.</span>\r\n\r\nThis solution is contributed  by <span class=\"im\"><b class=\"gmail_sendername\">Anil Saikrishna Devarasetty</b></span>.\r\n\r\n<span style=\"font-size: small;\">Result = 25</span></div>",
        "keyword": "Stack"
    },
    {
        "question": "Suppose a stack is to be implemented with a linked list instead of an array. What would be the effect on the time complexity of the push and pop operations of the stack implemented using linked list (Assuming stack is implemented efficiently)?\r\n",
        "answer": [
            "O(1) for insertion and O(n) for deletion    ",
            "O(1) for insertion and O(1) for deletion\r\n",
            "O(n) for insertion and O(1) for deletion\r\n",
            "O(n) for insertion and O(n) for deletion\r\n"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Stack can be implemented using link list having O(1) bounds for both insertion as well as deletion by inserting and deleting the element from the beginning of the list.\r\n</div>",
        "keyword": "Stack"
    },
    {
        "question": "Consider n elements that are equally distributed in k stacks. In each stack, elements of it are arranged in ascending order (min is at the top in each of the stack and then increasing downwards). \r\n\r\nGiven a queue of size n in which we have to put all n elements in increasing order. What will be the time complexity of the best known algorithm? ",
        "answer": [
            "O(n logk)",
            "O(nk)    ",
            "O(n2)",
            "O(k2)"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> \r\n\r\nIn nlogk it can be done by creating a min heap of size k and adding all the top - elements of all the stacks. After extracting the min , add the next element from the stack from which we have got our 1st minimum.\r\nTime Complexity = O(k) (For Creating Heap of size k) + (n-k)log k (Insertions into the heap).</div>",
        "keyword": "Stack"
    },
    {
        "question": "A priority queue Q is used to implement a stack S that stores characters. PUSH(C) is implemented as INSERT(Q, C, K) where K is an appropriate integer key chosen by the implementation. POP is implemented as DELETEMIN(Q). For a sequence of operations, the keys chosen are in",
        "answer": [
            "Non-increasing order",
            "Non-decreasing order",
            "strictly increasing order",
            "strictly decreasing order"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> We are implementing a STACK using Priority Queue. Note that Stack implementation is always last in first out (LIFO) order.\r\n\r\nAs given \"POP is implemented as DELETEMIN(Q)\" that means Stack returns minimum element always. \r\n\r\nSo, we need to implement PUSH(C) using INSERT(Q, C, K) <b>where K is key chosen from strictly-decreasing order</b>(only this order will ensure stack will return minimum element when we POP an element). That will satify <b>Last In First Out (LIFO)</b> property of stack.\r\n\r\nThat is answer, option (D) is true. \r\n\r\nOption (A) non-increasing order can not be true because two same (identical) numbers can not have same priority as priority should be distinguishable for each number.\r\n\r\n\r\n</div>",
        "keyword": "Stack"
    },
    {
        "question": "Consider the following statements:\r\n\r\ni.   First-in-first out types of computations are efficiently supported by STACKS.\r\nii.  Implementing LISTS on linked lists is more efficient than implementing LISTS on\r\n     an array for almost all the basic LIST operations.\r\niii. Implementing QUEUES on a circular array is more efficient than implementing QUEUES\r\n     on a linear array with two indices.\r\niv.  Last-in-first-out type of computations are efficiently supported by QUEUES.\r\n\r\n\r\nWhich of the following is correct?\r\n ",
        "answer": [
            "(ii) and (iii) are true",
            "(i) and (ii) are true",
            "(iii) and (iv) are true",
            "(ii) and (iv) are true"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> i -STACK is the data structure that follows Last In First Out (LIFO) or First In Last Out (FILO) order, in which the element which is inserted at last is removed out first.  \r\n\r\nii - Implementing LISTS on linked lists is more efficient than implementing it on an array for almost all the basic LIST operations because the insertion and deletion of elements can be done in O(1) in Linked List but it takes O(N) time in Arrays. \r\n\r\niii- Implementing QUEUES on a circular array is more efficient than implementing it on a linear array with two indices because using circular arrays, it takes less space and can reuse it again. \r\n\r\niv - QUEUE is the data structure that follows First In First Out (FIFO) or Last In Last Out (LILO) order, in which the element which is inserted first is removed first.\r\n\r\nonly (ii) and (iii) are TRUE. \r\nOption (A) is correct.</div>",
        "keyword": "Stack"
    },
    {
        "question": "Which of the following permutation can be obtained in the same order using a stack assuming that input is the sequence 5, 6, 7, 8, 9 in that order?",
        "answer": [
            "7, 8, 9, 5, 6",
            "5, 9, 6, 7, 8",
            "7, 8, 9, 6, 5",
            "9, 8, 7, 5, 6"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> The sequence given in option (C) is one of the only possible sequence which can be obtained.\r\nWe can obtain the sequence by performing operations in the manner:\r\nPush 5\r\nPush 6\r\nPush 7\r\nPop 7\r\nPush 8\r\nPop 8\r\nPush 9\r\nPop 9\r\nPop 6\r\nPop 5.\r\nhence the sequence will be 7,8,9,6,5. </div>",
        "keyword": "Stack"
    },
    {
        "question": "The minimum number of stacks needed to implement a queue is",
        "answer": [
            "3",
            "1",
            "2",
            "4"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Refer: <a href=\"https://www.geeksforgeeks.org/isro-isro-cs-2017-question-53/\" rel=\"noopener\" target=\"_blank\">ISRO CS 2017 | Question 53</a>\r\nOption (C) is correct.</div>",
        "keyword": "Stack"
    },
    {
        "question": "The best data structure to check whether an arithmetic expression has balanced parenthesis is a",
        "answer": [
            "Queue",
            "Stack",
            "Tree",
            "List"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Stacks can check equal pair/ balanced pair of parenthesis efficiently. Whenever we get an opening parenthesis we can push it on the stack and when we get the corresponding closing parenthesis, we can pop it. After performing all push and pop operations, if at the end of the expression stack becomes empty then the expression has a balanced parenthesis.  </div>",
        "keyword": "Stack"
    },
    {
        "question": "The seven elements A, B, C, D, E, F and G are pushed onto a stack in reverse order, i.e., starting from G. The stack is popped five times and each element is inserted into a queue.Two elements are deleted from the queue and pushed back onto the stack. Now, one element is popped from the stack. The popped item is ________. ",
        "answer": [
            "A",
            "B",
            "F",
            "G"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> <img alt=\"22\" class=\"alignnone size-medium wp-image-189101\" src=\"https://www.geeksforgeeks.org/wp-content/uploads/22-4.png\"/>\r\nIn fig:-1 elements are inserted into a stack then in fig:-2 top 5 elements are popped and these 5 elements are inserted into a queue which is shown in fig:-3, now first two elements are deleted from queue and pushed into stack one by one which is shown in fig:-5.\r\nAt top of the stack element B is presented.\r\nSo, option (B) is correct.  </div>",
        "keyword": "Stack"
    },
    {
        "question": "If the sequence of operations - push (1), push (2), pop, push (1), push (2), pop, pop, pop, push (2), pop are performed on a stack, the sequence of popped out values",
        "answer": [
            "2,2,1,1,2",
            "2,2,1,2,2",
            "2,1,2,2,1",
            "2,1,2,2,2"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> The pop sequence can be seen from the following table: \r\n\r\n<img src=\"https://www.geeksforgeeks.org/wp-content/uploads/ttt.png\"/>\r\n\r\nOption (A) is correct. </div>",
        "keyword": "Stack"
    },
    {
        "question": "The five items: A, B, C, D, and E are pushed in a stack, one after other starting from A. The stack is popped four items and each element is inserted in a queue. The two elements are deleted from the queue and pushed back on the stack. Now one item is popped from the stack. The popped item is",
        "answer": [
            "A",
            "B",
            "C",
            "D"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> <img src=\"https://www.geeksforgeeks.org/wp-content/uploads/ISRO_43.png\"/>\r\n\r\nOption (D) is correct.</div>",
        "keyword": "Stack"
    },
    {
        "question": "Consider the following operations performed on a stack of size 5 :\r\nPush (a); Pop() ; Push(b); Push(c); Pop();\r\nPush(d); Pop();Pop(); Push (e)\r\nWhich of the following statements is correct?",
        "answer": [
            "Underflow occurs",
            "Stack operations are performed smoothly",
            "Overflow occurs",
            "None of the above"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> <img alt=\"22 (2)\" class=\"alignnone size-medium wp-image-194961\" src=\"https://www.geeksforgeeks.org/wp-content/uploads/22-2-1.png\">\r\nAll Stack operations are performed smoothly.\r\nSo, option (B) is correct.</img></div>",
        "keyword": "Stack"
    },
    {
        "question": "Which of the following is not an inherent application of stack?",
        "answer": [
            "Implementation of recursion",
            "Evaluation of a postfix expression",
            "Job scheduling",
            "Reverse a string"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> We can use stack for string reversal, evaluation of postfix expression and most important is implementation of recursion  but job scheduling is not done by stack.\r\nSo, option (C) is correct.</div>",
        "keyword": "Stack"
    },
    {
        "question": "The five items: A, B, C, D, and E are pushed in a stack, one after other starting from A. The stack is popped four items and each element is inserted in a queue. The two elements are deleted from the queue and pushed back on the stack. Now one item is popped from the stack. The popped item is",
        "answer": [
            "A",
            "B",
            "C",
            "D"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> When five items: A, B, C, D, and E are pushed in a stack:\r\nOrder of stack becomes: A, B, C, D, and E (A at the bottom and E at the top.)\r\nstack is popped four items and each element is inserted in a queue:\r\nOrder of queue: B, C, D, E (B at rear and E at the front)\r\nOrder of stack after pop operations = A\r\nTwo elements deleted from the queue and pushed back on the stack:\r\nNew order of stack = A, E, D(A at the bottom, D at the top)\r\nAs D is on the top so when pop operation occurs D will be popped out.\r\n\r\nSo, correct option is (D).\r\n</div>",
        "keyword": "Stack"
    },
    {
        "question": "Stack A has the entries a, b, c (with a on top). Stack B is empty. An entry popped out of stack A can be printed immediately or pushed to stack B. An entry popped out of the stack B can be only be printed. In this arrangement, which of the following permutations of a, b, c are not possible?",
        "answer": [
            "b a c",
            "b c a",
            "c a b\r\n",
            "a b c"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>Option (A):\r\nPop a from stack A\r\nPush a to stack B\r\nPrint b\r\nPrint a from stack B\r\nPrint c from stack A\r\nOrder = b a c\r\n\r\nOption (B):\r\nPop a from stack A\r\nPush a to stack B\r\nPrint b from stack A\r\nPrint c from stack A\r\nPrint a from stack A\r\nOrder = b c a\r\n\r\nOption (C):\r\nPop a from stack A\r\nPush a to stack B\r\nPop b from stack A\r\nPush b to stack B\r\nPrint c from stack A\r\nNow, printing a will not be possible.</pre>\r\n\r\nSo, option (C) is incorrect.\r\n</div>",
        "keyword": "Stack"
    },
    {
        "question": "The five items: A, B, C, D, and E are pushed in a stack, one after other starting from A. The stack is popped four items and each element is inserted in a queue. The two elements are deleted from the queue and pushed back on the stack. Now one item is popped from the stack. The popped item is",
        "answer": [
            "A",
            "B",
            "C",
            "D"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> When five items: A, B, C, D, and E are pushed in a stack: Order of stack becomes: A, B, C, D, and E (A at the bottom and E at the top.) stack is popped four items and each element is inserted in a queue: Order of queue: B, C, D, E (B at rear and E at the front) Order of stack after pop operations = A. Two elements deleted from the queue and pushed back on the stack: New order of stack = A, E, D(A at the bottom, D at the top) As D is on the top so when pop operation occurs D will be popped out. So, correct option is (D).</div>",
        "keyword": "Stack"
    },
    {
        "question": "Convert the following infix expression into its equivalent post fix expression (A + B^ D) / (E – F) + G",
        "answer": [
            "ABD^ + EF – / G+",
            "ABD + ^EF – / G+",
            "ABD + ^EF / – G+",
            "ABD^ + EF / – G+"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> (A + B^ D) / (E – F) + G\r\n= (A + B^ D)(E – F)/ + G\r\n=  (A + B^ D)(E – F)/G+\r\n= A + BD^(E – F)/G+\r\n= ABD^+EF-/G+\r\nSo, option (A) is correct.</div>",
        "keyword": "Stack"
    },
    {
        "question": "Consider the following sequence of operations on an empty stack.\r\n\r\nPush(54);push(52);pop();push(55);push(62);s=pop(); \r\nConsider the following sequence of operations on an empty queue.\r\n\r\nenqueue(21);enqueue(24);dequeue();enqueue(28);enqueue(32);q=dequeue(); \r\nThe value of s+q is ___________.",
        "answer": [
            "86",
            "68",
            "24",
            "94"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Let's construct an empty stack and do the operations. Stack follows LIFO order.\r\n\r\n1.Push(54)  // (54)\r\n2.Push(52) // (54,52)\r\n3.Pop() // (54)\r\n4.Push(55) //(54,55)\r\n5.Push(62) //(54,55,62)\r\n6.s=pop() // (54,55)\r\n s=62;\r\n\r\nLet's construct an empty queue and do the operations. Queue follows FIFO order.\r\n\r\n1.Enqueue(21) // [21]\r\n2.Enqueue(24) // [21,24]\r\n3.Dequeue() // [24]\r\n4.Enqueue(28) // [24,28]\r\n5.Enqueue(32) // [24,28,32]\r\n6.q=Dequeue() // [28,32]\r\nq=24;\r\n\r\ns+q=62+24\r\n\r\nSo, s+q=86 . \r\n\r\n<b>Alternative Way :</b>\n<a href=\"https://www.geeksforgeeks.org/stack-data-structure/\" rel=\"noopener\" target=\"_blank\">Stack</a> is last in first out data structure, so s = pop() = 62\r\n\r\n<a href=\"https://www.geeksforgeeks.org/queue-data-structure/\" rel=\"noopener\" target=\"_blank\">Queue</a> is first in first out data structure, so q = dequeue() = 24\r\n\r\nTherefore, \r\ns+q = 62+24 = 86\r\n\r\n<iframe allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen=\"\" frameborder=\"0\" height=\"315\" src=\"https://www.youtube.com/embed/I43aLH5qEBc?start=89\" title=\"YouTube video player\" width=\"560\"></iframe></div>",
        "keyword": "Stack"
    },
    {
        "question": "Following is C like pseudo code of a function that takes a Queue as an argument, and uses a stack S to do processing.\r\n\r\n\r\nvoid fun(Queue *Q)\r\n{\r\n    Stack S;  // Say it creates an empty stack S\r\n\r\n    // Run while Q is not empty\r\n    while (!isEmpty(Q))\r\n    {\r\n        // deQueue an item from Q and push the dequeued item to S\r\n        push(&S, deQueue(Q));\r\n    }\r\n\r\n    // Run while Stack S is not empty\r\n    while (!isEmpty(&S))\r\n    {\r\n      // Pop an item from S and enqueue the poppped item to Q\r\n      enQueue(Q, pop(&S));\r\n    }\r\n}\r\n\r\n\r\nWhat does the above function do in general?",
        "answer": [
            "Removes the last from Q",
            "Keeps the Q same as it was before the call",
            "Makes Q empty",
            "Reverses the Q"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> The function takes a queue Q as an argument.  It dequeues all items of Q and pushes them to a stack S.  Then pops all items of S and enqueues the items back to Q.  Since stack is LIFO order, all items of queue are reversed.</div>",
        "keyword": "Queue"
    },
    {
        "question": "Which one of the following is an application of Queue Data Structure?",
        "answer": [
            "When a resource is shared among multiple consumers.",
            "When data is transferred asynchronously (data not necessarily received at same rate as sent) between two processes",
            "Load Balancing",
            "All of the above"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> See <a href=\"http://www.geeksforgeeks.org/applications-of-queue-data-structure/\" target=\"_blank\">http://www.geeksforgeeks.org/applications-of-queue-data-structure/</a> for details.</div>",
        "keyword": "Queue"
    },
    {
        "question": "How many stacks are needed to implement a queue.  Consider the situation where no other data structure like arrays, linked list is available to you.",
        "answer": [
            "1",
            "2",
            "3",
            "4"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> A queue can be implemented using two stacks.  See following for implementation.\r\n\r\n<a href=\"http://www.geeksforgeeks.org/queue-using-stacks/\">http://www.geeksforgeeks.org/queue-using-stacks/</a></div>",
        "keyword": "Queue"
    },
    {
        "question": "How many queues are needed to implement a stack. Consider the situation where no other data structure like arrays, linked list is available to you.",
        "answer": [
            "1",
            "2",
            "3",
            "4"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> A stack can be implemented using two queues.  Please see following for details.\r\n\r\n<a href=\"http://www.geeksforgeeks.org/implement-stack-using-queue/\">http://www.geeksforgeeks.org/implement-stack-using-queue/</a></div>",
        "keyword": "Queue"
    },
    {
        "question": " A priority queue can efficiently implemented using which of the following data structures?  Assume that the number of insert and peek (operation to see the current highest priority item) and extraction (remove the highest priority item) operations are almost same.",
        "answer": [
            "Array",
            "Linked List",
            "Heap Data Structures like Binary Heap, Fibonacci Heap",
            "None of the above"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> See <a href=\"http://en.wikipedia.org/wiki/Priority_queue\" target=\"_blank\">http://en.wikipedia.org/wiki/Priority_queue</a></div>",
        "keyword": "Queue"
    },
    {
        "question": "Which of the following is true about linked list implementation of queue?",
        "answer": [
            "In push operation, if new nodes are inserted at the beginning of linked list, then in pop operation, nodes must be removed from end.",
            "In push operation, if new nodes are inserted at the end, then in pop operation, nodes must be removed from the beginning.",
            "Both of the above ",
            "None of the above"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> To keep the <strong>F</strong>irst <strong>I</strong>n <strong>F</strong>irst <strong>O</strong>ut order, a queue can be implemented using linked list in any of the given two ways.</div>",
        "keyword": "Queue"
    },
    {
        "question": "Suppose a circular queue of capacity (n – 1) elements is implemented with an array of n elements. Assume that the insertion and deletion operation are carried out using REAR and FRONT as array index variables, respectively. Initially, REAR = FRONT = 0. The conditions to detect queue full and queue empty are",
        "answer": [
            "Full: (REAR+1) mod n == FRONT, empty: REAR == FRONT",
            "Full: (REAR+1) mod n == FRONT, empty: (FRONT+1) mod n == REAR",
            " Full: REAR == FRONT, empty: (REAR+1) mod n == FRONT",
            "Full: (FRONT+1) mod n == REAR, empty: REAR == FRONT"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>\r\nSuppose we start filling the queue.\r\n\r\nLet the maxQueueSize ( Capacity of the Queue) is 4.\r\nSo the size of the array which is used to implement \r\nthis circular queue is 5, which is n.\r\n\r\nIn the beginning when the queue is empty, FRONT and REAR \r\npoint to 0 index in the array.\r\n\r\nREAR represents insertion at the REAR index.\r\nFRONT represents deletion from the FRONT index.\r\n\r\nenqueue(\"a\"); REAR = (REAR+1)%5; ( FRONT = 0, REAR = 1)\r\nenqueue(\"b\"); REAR = (REAR+1)%5; ( FRONT = 0, REAR = 2)\r\nenqueue(\"c\"); REAR = (REAR+1)%5; ( FRONT = 0, REAR = 3)\r\nenqueue(\"d\"); REAR = (REAR+1)%5; ( FRONT = 0, REAR = 4)\r\n\r\nNow the queue size is 4 which is equal to the maxQueueSize. \r\nHence overflow condition is reached.\r\n\r\nNow, we can check for the conditions.\r\n\r\nWhen Queue Full :\r\n\r\n( REAR+1)%n = (4+1)%5 = 0\r\n\r\nFRONT is also 0.\r\n\r\nHence ( REAR + 1 ) %n is equal to FRONT.\r\n\r\nWhen Queue Empty :\r\n\r\nREAR was equal to FRONT when empty ( because in the starting \r\nbefore filling the queue FRONT = REAR = 0 )\r\n\r\nHence Option A is correct. </pre>\n</div>",
        "keyword": "Queue"
    },
    {
        "question": "A Priority-Queue is implemented as a Max-Heap. Initially, it has 5 elements. The level-order traversal of the heap is given below:\r\n10, 8, 5, 3, 2\r\nTwo new elements ”1‘ and ”7‘ are inserted in the heap in that order. The level-order traversal of the heap after the insertion of the elements is:",
        "answer": [
            "10, 8, 7, 5, 3, 2, 1",
            "10, 8, 7, 2, 3, 1, 5",
            " 10, 8, 7, 1, 2, 3, 5",
            "10, 8, 7, 3, 2, 1, 5"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> See question 4 of<a href=\"http://www.geeksforgeeks.org/data-structures-and-algorithms-set-22/\"> http://www.geeksforgeeks.org/data-structures-and-algorithms-set-22/</a></div>",
        "keyword": "Queue"
    },
    {
        "question": "An implementation of a queue Q, using two stacks S1 and S2, is given below:\r\n\r\n\r\nvoid insert(Q, x) {\r\n   push (S1, x);\r\n}\r\n \r\nvoid delete(Q){\r\n   if(stack-empty(S2)) then \r\n      if(stack-empty(S1)) then {\r\n          print(“Q is empty”);\r\n          return;\r\n      }\r\n      else while (!(stack-empty(S1))){\r\n          x=pop(S1);\r\n          push(S2,x);\r\n      }\r\n   x=pop(S2);\r\n}\r\n\r\n\r\nLet n insert and m (<=n) delete operations be performed in an arbitrary order on an empty queue Q. Let x and y be the number of push and pop operations performed respectively in the process. Which one of the following is true for all m and n?",
        "answer": [
            "n+m <= x < 2n and 2m <= y <= n+m",
            " n+m <= x < 2n and 2m<= y <= 2n",
            "2m <= x < 2n and 2m <= y <= n+m",
            "2m <= x <2n and 2m <= y <= 2n"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> The order in which insert and delete operations are performed matters here.\r\nThe best case: Insert and delete operations are performed alternatively. In every delete operation, 2 pop and 1 push operations are performed. So, total m+ n push (n push for insert() and m push for delete()) operations and 2m pop operations are performed.\r\n\r\nThe worst case: First n elements are inserted and then m elements are deleted. In first delete operation, n + 1 pop operations and n push operation are performed. Other than first, in all delete operations, 1 pop operation is performed. So, total m + n pop operations and 2n push operations are performed (n push for insert() and n push for delete())</div>",
        "keyword": "Queue"
    },
    {
        "question": "Consider the following operation along with Enqueue and Dequeue operations on \r\nqueues, where k is a global parameter.\r\nMultiDequeue(Q){\r\n   m = k\r\n   while (Q is not empty and m  > 0) {\r\n      Dequeue(Q)\r\n      m = m - 1\r\n   }\r\n}\r\nWhat is the worst case time complexity of a sequence of n MultiDequeue() operations on an initially empty queue? (GATE CS 2013)\r\n(A) \r\n(B) \r\n(C) \r\n(D) \n",
        "answer": [
            "A",
            "B",
            "C",
            "D"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Since the queue is empty initially, the condition of while loop never becomes true. So the time complexity is <img alt=\"\\Theta(n)\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"27\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-13ebbf70ea41ddbd496e1f917a0a9f75_l3.png\" style=\"vertical-align: -7px;\" title=\"Rendered by QuickLaTeX.com\" width=\"54\"/>. </div>",
        "keyword": "Queue"
    },
    {
        "question": "Consider the following pseudo code.  Assume that IntQueue is an integer queue.  What does the function fun do?\r\n\r\n\r\nvoid fun(int n)\r\n{\r\n    IntQueue q = new IntQueue();\r\n    q.enqueue(0);\r\n    q.enqueue(1);\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        int a = q.dequeue();\r\n        int b = q.dequeue();\r\n        q.enqueue(b);\r\n        q.enqueue(a + b);\r\n        print(a);\r\n    }\r\n}\r\n",
        "answer": [
            "Prints numbers from 0 to n-1",
            "Prints numbers from n-1 to 0",
            "Prints first n Fibonacci numbers",
            "Prints first n Fibonacci numbers in reverse order."
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> The function prints first n Fibonacci Numbers.  Note that 0 and 1 are initially there in q.  In every iteration of loop sum of the two queue items is enqueued and the front item is dequeued.</div>",
        "keyword": "Queue"
    },
    {
        "question": "Consider the following operation along with Enqueue and Dequeue operations on queues, where k is a global parameter.\r\nMultiDequeue(Q){\r\n   m = k\r\n   while (Q is not empty and m  > 0) {\r\n      Dequeue(Q)\r\n      m = m - 1\r\n   }\r\n}\r\nWhat is the worst case time complexity of a sequence of n MultiDequeue() operations on an initially empty queue? (GATE CS 2013) \r\n(A) \r\n(B) \r\n(C) \r\n(D) \r\n",
        "answer": [
            "A",
            "B",
            "C",
            "D"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> See <a href=\"http://geeksquiz.com/data-structures-queue-question-10-2/\" target=\"_blank\">http://geeksquiz.com/data-structures-queue-question-10-2/</a></div>",
        "keyword": "Queue"
    },
    {
        "question": "Suppose implementation supports an instruction REVERSE, which reverses the order of elements on the stack, in addition to the PUSH and POP instructions. Which one of the following statements is TRUE with respect to this modified stack?\r\n",
        "answer": [
            "A queue cannot be implemented using this stack.",
            "A queue can be implemented where ENQUEUE takes a single instruction and DEQUEUE takes a sequence of two instructions.\r\n",
            "A queue can be implemented where ENQUEUE takes a sequence of three instructions and DEQUEUE takes a single instruction.\r\n",
            "A queue can be implemented where both ENQUEUE and DEQUEUE take a single instruction each."
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> To DEQUEUE an item, simply POP.\r\n\r\nTo ENQUEUE an item, we can do following 3 operations\r\n1) REVERSE\r\n2) PUSH\r\n3) REVERSE\r\n\r\n\r\n</div>",
        "keyword": "Queue"
    },
    {
        "question": "A queue is implemented using an array such that ENQUEUE and DEQUEUE operations are performed efficiently.  Which one of the following statements is CORRECT (n refers to the number of items in the queue)?\r\n",
        "answer": [
            " Both operations can be performed in O(1) time",
            "At most one operation can be performed in O(1) time but the worst case time for the other operation will be Ω(n) ",
            "The worst case time complexity for both operations will be Ω(n) ",
            " Worst case time complexity for both operations will be Ω(log n)"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> We can use circular array to implement both in O(1) time. See below article for details.\r\n\r\n \r\n<ul>\n<li><a href=\"http://geeksquiz.com/queue-set-1introduction-and-array-implementation/\" target=\"_blank\">Queue Introduction and Array Implementation</a></li>\n</ul>\r\n \r\n\r\n<iframe allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen=\"\" frameborder=\"0\" height=\"315\" src=\"https://www.youtube.com/embed/Key2RKhzRGY?start=87\" title=\"YouTube video player\" width=\"560\"></iframe></div>",
        "keyword": "Queue"
    },
    {
        "question": "Let Q denote a queue containing sixteen numbers and S be an empty stack. Head(Q) returns the element at the head of the queue Q without removing it from Q. Similarly Top(S) returns the element at the top of S without removing it from S. Consider the algorithm given below.\r\n\r\n\r\n\r\nThe maximum possible number of iterations of the while loop in the algorithm is______\r\n\r\n[This Question was originally a Fill-in-the-Blanks question]",
        "answer": [
            "16",
            "32",
            "256",
            "64"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> The worst case happens when the queue is sorted in decreasing order.  In worst case, loop runs n*n times.\r\n\r\n<pre>\r\nQueue: 4 3 2 1\r\nStack: Empty\r\n\r\n3 2 1\r\n4\r\n\r\n3 2 1 4\r\nEmpty\r\n\r\n2 1 4\r\n3\r\n\r\n2 1 4 3\r\nEmpty\r\n\r\n1 4 3\r\n2\r\n\r\n1 4 3 2\r\nEmpty\r\n\r\n4 3 2\r\n1\r\n\r\n3 2\r\n1 4\r\n\r\n3 2 4\r\n1\r\n\r\n2 4\r\n1 3\r\n\r\n2 4 3\r\n1\r\n\r\n4 3\r\n1 2\r\n\r\n3 \r\n1 2 4\r\n\r\n3 4 \r\n1 2\r\n\r\n4\r\n1 2 3\r\n\r\nEmpty\r\n1 2 3 4</pre>\n</div>",
        "keyword": "Queue"
    },
    {
        "question": "Suppose you are given an implementation of a queue of integers. The operations that can be performed on the queue are:\r\ni.   isEmpty (Q) — returns true if the queue is empty, false otherwise.\r\nii.  delete (Q) — deletes the element at the front of the queue and returns its value.\r\niii. insert (Q, i) — inserts the integer i at the rear of the queue.\r\nConsider the following function:\r\n\r\n void f (queue Q) {\r\nint i ;\r\nif (!isEmpty(Q)) {\r\n   i = delete(Q);\r\n   f(Q);\r\n   insert(Q, i);\r\n  }\r\n}\r\n\r\nWhat operation is performed by the above function f ?",
        "answer": [
            "Leaves the queue Q unchanged",
            "Reverses the order of the elements in the queue Q",
            "Deletes the element at the front of the queue Q and inserts it at the rear keeping the other elements in the same order",
            "Empties the queue Q\r\n"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> As it is recursive call, and removing from front while inserting from end, that means last element will be deleted at last and will be inserted 1<sup>st</sup> in the new queue. And like that it will continue till first call executes insert(Q,i) function.<br/>\r\nSo, the queue will be in reverse.\r\n</div>",
        "keyword": "Queue"
    },
    {
        "question": "Consider the following statements:\r\n\r\ni.   First-in-first out types of computations are efficiently supported by STACKS.\r\nii.  Implementing LISTS on linked lists is more efficient than implementing LISTS on\r\n     an array for almost all the basic LIST operations.\r\niii. Implementing QUEUES on a circular array is more efficient than implementing QUEUES\r\n     on a linear array with two indices.\r\niv.  Last-in-first-out type of computations are efficiently supported by QUEUES.\r\n\r\n\r\nWhich of the following is correct?\r\n ",
        "answer": [
            "(ii) and (iii) are true",
            "(i) and (ii) are true",
            "(iii) and (iv) are true",
            "(ii) and (iv) are true"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> i -STACK is the data structure that follows Last In First Out (LIFO) or First In Last Out (FILO) order, in which the element which is inserted at last is removed out first.  \r\n\r\nii - Implementing LISTS on linked lists is more efficient than implementing it on an array for almost all the basic LIST operations because the insertion and deletion of elements can be done in O(1) in Linked List but it takes O(N) time in Arrays. \r\n\r\niii- Implementing QUEUES on a circular array is more efficient than implementing it on a linear array with two indices because using circular arrays, it takes less space and can reuse it again. \r\n\r\niv - QUEUE is the data structure that follows First In First Out (FIFO) or Last In Last Out (LILO) order, in which the element which is inserted first is removed first.\r\n\r\nonly (ii) and (iii) are TRUE. \r\nOption (A) is correct.</div>",
        "keyword": "Queue"
    },
    {
        "question": "Which of the following option is not correct?\r\n\r\n\r\n\r\n\r\n",
        "answer": [
            "If the queue is implemented with a linked list, keeping track of a front pointer, Only rear pointer s will change during an insertion into an non-empty queue.",
            "Queue data structure can be used to implement least recently used (LRU) page fault algorithm and Quick short algorithm.",
            "Queue data structure can be used to implement Quick short algorithm but not least recently used (LRU) page fault algorithm.",
            "Both (A) and (C)"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> If the queue is implemented with a linked list, keeping track of a front pointer, Only rear pointer s will change during an insertion into an non-empty queue.\r\n\r\nQueue data structure can be used to implement least recently used (LRU) page fault algorithm and Quick short algorithm.\r\n\r\nOnly option (C) is not correct.\r\n</div>",
        "keyword": "Queue"
    },
    {
        "question": "A queue is implemented using a non-circular singly linked list. The queue has a head pointer and a tail pointer, as shown in the figure. Let n denote the number of nodes in the queue. Let 'enqueue' be implemented by inserting a new node at the head, and 'dequeue' be implemented by deletion of a node from the tail.\r\n\r\n\n\r\nWhich one of the following is the time complexity of the most time-efficient implementation of 'enqueue' and 'dequeue, respectively, for this data structure?",
        "answer": [
            "Θ(1),  Θ(1)",
            "Θ(1),  Θ(n)",
            "Θ(n),  Θ(1)",
            "Θ(n),  Θ(n)"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> For Enqueue operation, performs in constant amount of time (i.e., Θ(1)), because it modifies only two pointers, i.e., \r\n<pre>\r\nCreate a Node P.\r\nP--&gt;Data = Data\r\nP--&gt;Next = Head\r\nHead = P\r\n</pre>\r\n\r\nFor Dequeue operation, we need address of second last node of single linked list to make NULL of its next pointer. Since we can not access its previous node in singly linked list, so need to traverse entire linked list to get second last node of linked list, i.e.,\r\n<pre>\r\ntemp = head;\r\n While( temp-Next--&gt;Next != NULL){\r\n        temp = temp-Next;\r\n        }\r\ntemp--&gt;next = NULL;\r\nTail = temp;\r\n</pre>\r\nSince, we are traversing entire linked for each Dequeue, so time complexity will be Θ(n).\r\n\r\nOption (B) is correct.\r\n\r\n<iframe allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen=\"\" frameborder=\"0\" height=\"315\" src=\"https://www.youtube.com/embed/j9Vmf5yRw-I?start=2566\" title=\"YouTube video player\" width=\"560\"></iframe>\n</div>",
        "keyword": "Queue"
    },
    {
        "question": "The minimum number of stacks needed to implement a queue is",
        "answer": [
            "3",
            "1",
            "2",
            "4"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Refer: <a href=\"https://www.geeksforgeeks.org/isro-isro-cs-2017-question-53/\" rel=\"noopener\" target=\"_blank\">ISRO CS 2017 | Question 53</a>\r\nOption (C) is correct.</div>",
        "keyword": "Queue"
    },
    {
        "question": "Consider a standard Circular Queue 'q' implementation (which has the same condition for Queue Full and Queue Empty) whose size is 11 and the elements of the queue are q[0], q[1], q[2].....,q[10].\r\nThe front and rear pointers are initialized to point at q[2] . In which position will the ninth element be added?",
        "answer": [
            "q[0]",
            "q[1]",
            "q[9]",
            "q[10]"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Circular queue whose total size is 11, front and rear pointers are initialized to point at q[2]:\r\n\r\n<img alt=\"333\" class=\"aligncenter size-full wp-image-199203\" height=\"261\" src=\"https://www.geeksforgeeks.org/wp-content/uploads/333-4.png\" width=\"706\"/>\r\n\r\nTherefore, 9th element will be added at pointer q[0].\r\n\r\nSo, option (A) is correct.</div>",
        "keyword": "Queue"
    },
    {
        "question": "A priority queue is implemented as a max-heap. Initially, it has five elements. The level-order traversal of the heap is as follows:\r\n20, 18, 15, 13, 12\r\nTwo new elements ‘10’ and ‘17’ are inserted in the heap in that order. The level-order traversal of the heap after the insertion of the element is:",
        "answer": [
            "20, 18, 17, 15, 13, 12, 10",
            "20, 18, 17, 12, 13, 10, 15",
            "20, 18, 17, 10, 12, 13, 15",
            "20, 18, 17, 13, 12, 10, 15"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> Initially we have:\r\n<img alt=\"34 (1)\" class=\"alignnone size-medium wp-image-194308\" src=\"https://www.geeksforgeeks.org/wp-content/uploads/34-1-1.png\"/> \r\nWhen we insert 10 and 17:\r\n<img alt=\"34 (2)\" class=\"alignnone size-medium wp-image-194311\" src=\"https://www.geeksforgeeks.org/wp-content/uploads/34-2-1.png\"/>\r\n We have to maintain max-heap, so:\r\n<img alt=\"34 (3)\" class=\"alignnone size-medium wp-image-194312\" src=\"https://www.geeksforgeeks.org/wp-content/uploads/34-3.png\"/> \r\nThe level-order traversal of the heap after the insertion of the element is 20, 18, 17, 13, 12, 10, 15\r\nSo, option (D) is correct.\r\n</div>",
        "keyword": "Queue"
    },
    {
        "question": "Which of the following is a true about Binary Trees",
        "answer": [
            " Every binary tree is either complete or full.",
            "Every complete binary tree is also a full binary tree.",
            "Every full binary tree is also a complete binary tree.",
            "No binary tree is both complete and full.",
            "None of the above"
        ],
        "correct": "E",
        "explain": "<div class=\"mtq_explanation-text\"> A full binary tree (sometimes proper binary tree or 2-tree or strictly binary tree) is a tree in which every node other than the leaves has two children.\r\n\r\nA complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible.\r\n\r\nA) is incorrect.  For example, the following Binary tree is neither complete nor full\r\n<pre>\r\n     12\r\n   /  \r\n  20\r\n /\r\n30</pre>\r\n\r\n\r\nB) is incorrect.  The following binary tree is complete but not full\r\n<pre>\r\n     12\r\n   /   \\\r\n  20    30\r\n /\r\n30</pre>\r\n\r\n\r\nC) is incorrect.  Following Binary tree is full, but not complete\r\n\r\n<pre>\r\n     12\r\n   /   \\\r\n  20    30\r\n       /  \\  \r\n      20   40\r\n</pre>\r\n\r\n\r\n\r\nD) is incorrect.  Following Binary tree is both complete and full\r\n\r\n<pre>\r\n      12\r\n    /   \\\r\n   20    30\r\n  /  \\  \r\n 10   40\r\n</pre>\r\n\r\nPlease refer <a href=\"http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees\" target=\"_blank\">http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees</a>\n</div>",
        "keyword": "Binary Trees"
    },
    {
        "question": "If arity of operators is fixed, then which of the following notations can be used to parse expressions without parentheses?\r\n\r\na) Infix Notation (Inorder traversal of a expression tree)\r\nb) Postfix Notation (Postorder traversal of a expression tree)\r\nc) Prefix Notation (Preorder traversal of a expression tree)\r\n",
        "answer": [
            "b and c",
            "Only b",
            "a, b and c",
            "None of them"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> See <a href=\"http://en.wikipedia.org/wiki/Polish_notation\" target=\"_blank\">Polish notation</a></div>",
        "keyword": "Binary Trees"
    },
    {
        "question": "What are the main applications of tree data structure?\r\n\r\n1) Manipulate hierarchical data\r\n2) Make information easy to search (see tree traversal).\r\n3) Manipulate sorted lists of data\r\n4) Router algorithms \r\n5) Form of a multi-stage decision-making, like Chess Game.\r\n6) As a workflow for compositing digital images for visual effects",
        "answer": [
            "1, 2, 3, 4 and 6",
            "1, 2, 3, 4 and 5",
            "1, 3, 4, 5 and 6",
            "1, 2, 3, 4, 5 and 6"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> See <a href=\"http://en.wikipedia.org/wiki/Tree_(data_structure)#Common_uses\" target=\"_blank\">http://en.wikipedia.org/wiki/Tree_(data_structure)#Common_uses</a></div>",
        "keyword": "Binary Trees"
    },
    {
        "question": "Level of a node is distance from root to that node. For example, level of root is 1 and levels of left and right children of root is 2. The maximum number of nodes on level i of a binary tree is \r\n\r\nIn the following answers, the operator '^' indicates power.",
        "answer": [
            "2^(i-1) ",
            "2^i",
            "2^(i+1)",
            "2^[(i+1)/2]"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Number of nodes of binary tree will be maximum only when tree is <b>full complete</b>, therefore answer is 2^(i)-1\r\nSo, option (A) is true.</div>",
        "keyword": "Binary Trees"
    },
    {
        "question": "In a complete k-ary tree, every internal node has exactly k children or no child. The number of leaves in such a tree with n internal nodes is:",
        "answer": [
            "nk",
            "(n – 1) k+ 1",
            "n( k – 1) + 1",
            " n(k – 1)"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> For an k-ary tree where each node has k children or no children, following relation holds\r\nL = (k-1)*n + 1\r\n\r\nWhere L is the number of leaf nodes and n is the number of internal nodes.\r\n\r\nLet us see following for example <pre>\r\n             o\r\n        /    |    \\\r\n      o      o      o\r\n   / | \\          / | \\\r\n  o  o  o        o  o  o\r\n                  / | \\\r\n                 o  o  o\r\n\r\nk = 3\r\nNumber of internal nodes n = 4\r\nNumber of leaf nodes = (k-1)*n  + 1\r\n                     = (3-1)*4 + 1\r\n                     = 9 </pre></div>",
        "keyword": "Binary Trees"
    },
    {
        "question": "The maximum number of binary trees that can be formed with three unlabelled nodes is:\r\n\r\n",
        "answer": [
            "1",
            "5",
            "4",
            "3"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Following are all possible unlabeled binary trees\r\n<pre>\r\n\r\n             O\r\n          /     \\\r\n        O        O\r\n           (i)\r\n\r\n            O\r\n          /\r\n       O\r\n     /\r\n   O\r\n        (ii)\r\n\r\n         O\r\n       /\r\n     O\r\n        \\\r\n          O\r\n       (iii)\r\n\r\n  O\r\n     \\\r\n       O\r\n          \\\r\n           O\r\n    (iv)\r\n\r\n       O\r\n          \\\r\n            O\r\n          /\r\n       O\r\n    (v)</pre>\r\nNote that nodes are unlabeled. If the nodes are labeled, we get more number of trees.\r\nWe can find the number of binary tree by <a href=\"https://www.geeksforgeeks.org/program-nth-catalan-number/\" rel=\"noopener\" target=\"_blank\">Catalan number</a> number:\r\nHere n = 3\r\nNumber of binary tree =  (<sup>2n</sup>C<sub>n</sub>)/ n+1\r\n=  (<sup>2*3</sup>C<sub>3</sub>)/ 4+1\r\n= 5.\r\nSo, option (B) is correct.\r\n\r\n\r\n</div>",
        "keyword": "Binary Trees"
    },
    {
        "question": " The number of leaf nodes in a rooted tree of n nodes, with each node having 0 or 3 children is: ",
        "answer": [
            "n/2",
            "(n-1)/3",
            "(n-1)/2",
            "(2n+1)/3"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> Let L be the number of leaf nodes and I be the number of internal nodes, then following relation holds for above given tree (For details, please see question 3 of <a href=\"https://www.geeksforgeeks.org/data-structures-and-algorithms-set-11/\">this post</a>)\r\n<pre>  L = (3-1)I + 1 = 2I + 1</pre>\r\nTotal number of nodes(n) is sum of leaf nodes and internal nodes\r\n<pre>  n = L + I</pre>\r\nAfter solving above two, we get L = (2n+1)/3</div>",
        "keyword": "Binary Trees"
    },
    {
        "question": "A weight-balanced tree is a binary tree in which for each node. The number of nodes in the left sub tree is at least half and at most twice the number of nodes in the right sub tree. The maximum possible height (number of nodes on the path from the root to the farthest leaf) of such a tree on n nodes is best described by which of the following? ",
        "answer": "None",
        "correct": "None",
        "explain": "None",
        "keyword": "Binary Trees"
    },
    {
        "question": "A complete n-ary tree is a tree in which each node has n children or no children. Let I be the number of internal nodes and L be the number of leaves in a complete n-ary tree. If L = 41, and I = 10, what is the value of n?",
        "answer": [
            "6",
            "3",
            "4",
            "5"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> For an n-ary tree where each node has n children or no children, following relation holds\r\n<pre><strong>    L = (n-1)*I + 1</strong></pre>\r\nWhere L is the number of leaf nodes and I is the number of internal nodes.\r\n\r\nLet us find out the value of n for the given data.\r\n<pre>  L = 41 , I = 10\r\n  41 = 10*(n-1) + 1\r\n  (n-1) = 4\r\n  n = 5</pre></div>",
        "keyword": "Binary Trees"
    },
    {
        "question": "The height of a binary tree is the maximum number of edges in any root to leaf path. The maximum number of nodes in a binary tree of height h is:",
        "answer": [
            "2^h -1",
            "2^(h-1) – 1",
            "2^(h+1) -1",
            "2*(h+1)"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Maximum number of nodes will be there for a complete tree.\r\nNumber of nodes in a complete tree of height h = 1 + 2 + 2^2 + 2*3 + …. 2^h = 2^(h+1) – 1</div>",
        "keyword": "Binary Trees"
    },
    {
        "question": "A scheme for storing binary trees in an array X is as follows. Indexing of X starts at 1 instead of 0. the root is stored at X[1]. For a node stored at X[i], the left child, if any, is stored in X[2i] and the right child, if any, in X[2i+1]. To be able to store any binary tree on n vertices the minimum size of X should be. (GATE CS 2006)",
        "answer": "None",
        "correct": "None",
        "explain": "None",
        "keyword": "Binary Trees"
    },
    {
        "question": "Postorder traversal of a given binary search tree, T produces the following sequence of keys \r\n        10, 9, 23, 22, 27, 25, 15, 50, 95, 60, 40, 29\r\nWhich one of the following sequences of keys can be the result of an in-order traversal of the tree T? (GATE CS 2005)",
        "answer": [
            "9, 10, 15, 22, 23, 25, 27, 29, 40, 50, 60, 95",
            "9, 10, 15, 22, 40, 50, 60, 95, 23, 25, 27, 29",
            " 29, 15, 9, 10, 25, 22, 23, 27, 40, 60, 50, 95",
            "95, 50, 60, 40, 27, 23, 22, 25, 10, 9, 15, 29"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Inorder traversal of a <a href=\"http://en.wikipedia.org/wiki/Binary_search_tree\">BST </a>always gives elements in increasing order.  Among all four options, a) is the only increasing order sequence.</div>",
        "keyword": "Binary Trees"
    },
    {
        "question": "Consider the following nested representation of binary trees: (X Y Z) indicates Y and Z are the left and right sub stress, respectively, of node X. Note that Y and Z may be NULL, or further nested. Which of the following represents a valid binary tree?",
        "answer": [
            "(1 2 (4 5 6 7))",
            " (1 (2 3 4) 5 6) 7)",
            "(1 (2 3 4)(5 6 7))",
            " (1 (2 3 NULL) (4 5))"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> C is fine.\r\n\r\n<pre>\r\n(1 (2 3 4)(5 6 7))  represents following binary tree\r\n      1\r\n   /    \\\r\n  2      5 \r\n / \\    / \\\r\n3   4  6   7</pre>\r\n\r\n\r\nA) (1 2 (4 5 6 7)) is not fine as there are 4 elements in one bracket.\r\n\r\nB)  (1 (2 3 4) 5 6) 7) is not fine as there are 2 opening brackets and 3 closing.\r\n\r\nD)  (1 (2 3 NULL) (4 5)) is not fine one bracket has only two entries (4 5)\r\n\r\n\r\n</div>",
        "keyword": "Binary Trees"
    },
    {
        "question": "Consider a node X in a Binary Tree.  Given that X has two children, let Y be Inorder successor of X. Which of the following is true about Y?",
        "answer": [
            "Y has no right child",
            "Y has no left child",
            "Y has both children",
            "None of the above"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Since X has both children, Y must be leftmost node in right child of X.</div>",
        "keyword": "Binary Trees"
    },
    {
        "question": "In a binary tree with n nodes, every node has an odd number of descendants. Every node is considered to be its own descendant. What is the number of nodes in the tree that have exactly one child?",
        "answer": [
            "0",
            "1",
            "(n-1)/2",
            "n-1"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> It is mentioned that each node has odd number of descendants including node itself, so all nodes must have even number of descendants 0, 2, 4 so on.   Which means each node should have either 0 or 2 children. So there will be no node with 1 child.  Hence 0 is answer.\r\n\r\nFollowing are few examples. <pre>\r\n       a\r\n    /    \\\r\n   b      c\r\n\r\n\r\n      a\r\n    /   \\\r\n   b     c  \r\n  /  \\\r\n d    e</pre>\r\n  \r\n\r\nSuch a binary tree is <a href=\"http://geeksquiz.com/binary-tree-set-3-types-of-binary-tree/\">full binary tree</a> (a binary tree where every node has 0 or 2 children).  \r\n</div>",
        "keyword": "Binary Trees"
    },
    {
        "question": "The height of a binary tree is the maximum number of edges in any root to leaf path. The maximum number of nodes in a binary tree of height h is:  ",
        "answer": [
            "2h−1",
            "2h−1 -1",
            "2h+1-1",
            "2h+1"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> See Question 1 <a href=\"http://www.geeksforgeeks.org/data-structures-and-algorithms-set-10/\" target=\"_blank\">http://www.geeksforgeeks.org/data-structures-and-algorithms-set-10/</a></div>",
        "keyword": "Binary Trees"
    },
    {
        "question": "The height of a tree is the length of the longest root-to-leaf path in it. The maximum and minimum number of nodes in a binary tree of height 5 are",
        "answer": [
            "63 and 6, respectively",
            "64 and 5, respectively",
            " 32 and 6, respectively",
            "31 and 5, respectively"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>\r\nNumber of nodes is maximum for a perfect binary tree.\r\nA perfect binary tree of height h has 2<sup>h+1</sup> - 1 nodes\r\n\r\nNumber of nodes is minimum for a skewed binary tree.\r\nA perfect binary tree of height h has h+1 nodes.\r\n</pre>\n</div>",
        "keyword": "Binary Trees"
    },
    {
        "question": "A binary tree T has 20 leaves. The number of nodes in T having two children is",
        "answer": [
            "18",
            "19",
            "17",
            "Any number between 10 and 20"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> \r\n\r\nSum of all degrees = 2 * |E|.\r\n\r\nHere considering tree as a k-ary tree :\r\n<pre>\r\n\r\nSum of degrees of leaves + Sum of degrees for Internal Node except root + Root's degree = 2 * (No. of nodes - 1).\r\n\r\nPutting values of above terms,\r\n\r\nL + (I-1)*(k+1) + k = 2 * (L + I - 1)\r\n\r\nL + k*I - k + I -1 + k = 2*L + 2I - 2\r\n\r\nL + K*I + I - 1 = 2*L + 2*I - 2\r\n\r\nK*I + 1 - I = L\r\n\r\n(K-1)*I + 1 = L\r\n\r\nGiven k = 2, L=20\r\n\r\n==&gt; (2-1)*I + 1 = 20\r\n==&gt; I = 19\r\n==&gt; T has 19 internal nodes which are having two children.\r\n</pre>\n<!--The number of nodes with two children is always one less than the number of leaves.-->\n<a href=\"http://www.geeksforgeeks.org/handshaking-lemma-and-interesting-tree-properties/\">See Handshaking Lemma and Interesting Tree Properties</a> for proof. \r\n\r\n\r\nThis solution is contributed by <strong>Anil Saikrishna Devarasetty</strong></div>",
        "keyword": "Binary Trees"
    },
    {
        "question": "Consider a complete binary tree where the left and the right subtrees of the root are max-heaps. The lower bound for the number of operations to convert the tree to a heap is",
        "answer": [
            "Ω(logn)",
            "Ω(n)",
            "Ω(nlogn)",
            " Ω(n2)"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> The answer to this question is simply max-heapify function.  Time complexity of max-heapify is O(Log n) as it recurses at most through height of heap.\r\n\r\n<pre>\r\n// A recursive method to heapify a subtree with root at given index\r\n// This method assumes that the subtrees are already heapified\r\nvoid MinHeap::MaxHeapify(int i)\r\n{\r\n    int l = left(i);\r\n    int r = right(i);\r\n    int largest = i;\r\n    if (l &lt; heap_size &amp;&amp; harr[l] &lt; harr[i])\r\n        largest = l;\r\n    if (r &lt; heap_size &amp;&amp; harr[r] &lt; harr[smallest])\r\n        largest = r;\r\n    if (largest != i)\r\n    {\r\n        swap(↔[i], ↔[largest]);\r\n        MinHeapify(largest);\r\n    }\r\n}</pre>\r\n\r\nSee <a href=\"http://geeksquiz.com/binary-heap/\">Binary Heap </a>for details.</div>",
        "keyword": "Binary Trees"
    },
    {
        "question": "An array of integers of size n can be converted into a heap by adjusting the heaps rooted at each internal node of the complete binary tree starting at the node ⌊(n - 1) /2⌋, and doing this adjustment up to the root node (root node is at index 0) in the order ⌊(n - 1)/2⌋, ⌊(n - 3)/ 2⌋, ....., 0. The time required to construct a heap in this manner is",
        "answer": [
            "O(log n)",
            "O(n)",
            "O (n log log n)",
            "O(n log n)"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> The above statement is actually algorithm for building a Heap of an input array A.<span id=\"more-12580\"></span>\n<pre>BUILD-HEAP(A) \r\n    heapsize := size(A); \r\n    for i := floor(heapsize/2) downto 1 \r\n        do HEAPIFY(A, i); \r\n    end for \r\nEND\r\n</pre>\r\nUpper bound of time complexity is O(n) for above algo\r\n\r\n \r\n\r\nSee- http://www.geeksforgeeks.org/g-fact-85/</div>",
        "keyword": "Binary Trees"
    },
    {
        "question": "In a binary tree, for every node the difference between the number of nodes in the left and right subtrees is at most 2. If the height of the tree is h > 0, then the minimum number of nodes in the tree is:",
        "answer": [
            "2h - 1",
            "2h - 1 + 1",
            "2h - 1",
            "2h"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>Let there be n(h) nodes at height h.\r\n\r\nIn a perfect tree where every node has exactly \r\ntwo children, except leaves, following recurrence holds.\r\n\r\nn(h) = 2*n(h-1) + 1\r\n\r\nIn given case, the numbers of nodes are two less, therefore\r\nn(h) = 2*n(h-1) + 1 - 2\r\n     = 2*n(h-1) - 1\r\n\r\nNow if try all options, only option (b) satisfies above recurrence.\r\n\r\nLet us see option (B)\r\nn(h) = 2<sup>h - 1</sup> + 1\r\n\r\nSo if we substitute \r\nn(h-1) = 2<sup>h-2</sup> + 1, we should get n(h) = 2<sup>h-1</sup> + 1\r\n\r\nn(h) =  2*n(h-1) - 1\r\n     =  2*(2<sup>h-2</sup> + 1) -1\r\n     =  2<sup>h-1</sup> + 1.\r\n</pre>\n</div>",
        "keyword": "Binary Trees"
    },
    {
        "question": "Breadth First Search (BFS) is started on a binary tree beginning from the root vertex. There is a vertex t at a distance four from the root. If t is the n-th vertex in this BFS traversal, then the maximum possible value of n is ________\r\n\r\n[This Question was originally a Fill-in-the-blanks Question]\r\n",
        "answer": [
            "15",
            "16",
            "31",
            "32"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> It would be node number 31 for given distance 4.\r\n\r\nFor example if we consider at distance 2, below highlighted node G can be the farthest node at position 7.  \r\n<pre>\r\n            A\r\n         /    \\\r\n        B       C\r\n       / \\     / \\\r\n      D   E   F  <strong> G</strong>\r\n</pre>\n<b>Alternative Solution :</b>\r\nt is the n-th vertex in this BFS traversal at distance four from the root. So height of tree is 4.\r\nMax number of nodes = 2^{h+1} − 1 = 2^{5} − 1 = 31\r\nAt distance four, last node is 31. option (C).\r\n\r\n\r\n<iframe allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen=\"\" frameborder=\"0\" height=\"315\" src=\"https://www.youtube.com/embed/Key2RKhzRGY?start=2419\" title=\"YouTube video player\" width=\"560\"></iframe></div>",
        "keyword": "Binary Trees"
    },
    {
        "question": "In a binary tree, the number of internal nodes of degree 1 is 5, and the number of internal nodes of degree 2 is 10. The number of leaf nodes in the binary tree is\r\n\r\n ",
        "answer": [
            "10",
            "11",
            "12",
            "15"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> In a binary tree, the number of leaf nodes is always 1 more than number of internal nodes with 2 children, refer <a href=\"http://www.geeksforgeeks.org/handshaking-lemma-and-interesting-tree-properties/\">http://www.geeksforgeeks.org/handshaking-lemma-and-interesting-tree-properties/</a>\r\nSo,\r\nNumber of Leaf Nodes = Number of Internal nodes with 2 children + 1\r\nNumber of Leaf Nodes = 10 + 1\r\nNumber of Leaf Nodes = 11</div>",
        "keyword": "Binary Trees"
    },
    {
        "question": "The following three are known to be the preorder, inorder and postorder sequences of a binary tree. But it is not known which is which.\r\nMBCAFHPYK\r\nKAMCBYPFH\r\nMABCKYFPH\r\nPick the true statement from the following.\r\n\r\n",
        "answer": [
            "I and II are preorder and inorder sequences, respectively",
            "I and III are preorder and postorder sequences, respectively",
            "II is the inorder sequence, but nothing more can be said about the other two sequences",
            "II and III are the preorder and inorder sequences, respectively"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> \r\n\r\nThe approach to solve this question is to first find 2 sequences whose first and last element is same. The reason being first element in the Pre-order of any binary tree is the root and last element in the Post-order of any binary tree is the root.\r\nLooking at the sequences given, \r\nPre-order   =   KAMCBYPFH\r\nPost-order  =  MBCAFHPYK\r\nLeft-over sequence  MABCKYFPH will be in order.\r\nSince we have all the traversals identified, let's try to draw the binary tree if possible.\r\n\r\n<a href=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/12/pranjul.png\"><img alt=\"pranjul\" class=\"alignnone size-full wp-image-29232\" height=\"372\" src=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/12/pranjul.png\" width=\"561\"/></a>\r\n\r\nI. Post order<br/>\r\nII. Pre order<br/>\r\nIII. Inorder\r\n\r\n\r\nThis solution is contributed by <strong>Pranjul Ahuja.</strong></div>",
        "keyword": "Binary Trees"
    },
    {
        "question": "A binary tree with n > 1 nodes has n1, n2 and n3 nodes of degree one, two and three respectively. The degree of a node is defined as the number of its neighbors.\r\n\r\nn3 can be expressed as",
        "answer": [
            "n1 + n2 - 1",
            "n1 - 2",
            "[((n1 + n2)/2)]",
            "n2 - 1"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> <a href=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/05/2008_76_sol.jpg\"><img alt=\"2008_76_sol\" class=\"alignnone size-medium wp-image-26152\" height=\"160\" src=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/05/2008_76_sol-300x160.jpg\" width=\"300\"/></a></div>",
        "keyword": "Binary Trees"
    },
    {
        "question": "A binary tree with n > 1 nodes has n1, n2 and n3 nodes of degree one, two and three respectively. The degree of a node is defined as the number of its neighbors.\r\n\r\nStarting with the above tree, while there remains a node v of degree two in the tree, add an edge between the two neighbors of v and then remove v from the tree. How many edges will remain at the end of the process?",
        "answer": [
            "2 * n1 - 3",
            "n2 + 2 * n1 - 2",
            "n3 - n2",
            "n2 + n1 - 2"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> With reference to figure of answer of previous question:\r\n<a href=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/05/2008_77_sol.jpg\"><img alt=\"2008_77_sol\" class=\"alignnone size-medium wp-image-26154\" height=\"132\" src=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/05/2008_77_sol-300x132.jpg\" width=\"300\"/></a></div>",
        "keyword": "Binary Trees"
    },
    {
        "question": "Draw the binary tree with node labels a, b, c, d, e, f and g for which the inorder and postorder traversals result in the following sequences:\r\nInorder       a f b c d g e\r\nPostorder     a f c g e d b\r\n",
        "answer": "None",
        "correct": "None",
        "explain": "None",
        "keyword": "Binary Trees"
    },
    {
        "question": "A binary search tree contains the values 1, 2, 3, 4, 5, 6, 7, 8. The tree is traversed in pre-order and the values are printed out. Which of the following sequences is a valid output?",
        "answer": [
            "53124786",
            "53126487",
            "53241678",
            "53124768"
        ],
        "correct": "D",
        "explain": "None",
        "keyword": "Binary Trees"
    },
    {
        "question": "A size-balanced binary tree is a binary tree in which for every node, the difference between the number of nodes in the left and right subtree is at most 1. The distance of a node from the root is the length of the path from the root to the node. The height of a binary tree is the maximum distance of a leaf node from the root.\r\n\r\na. Prove, by using induction on h, that a size-balance binary tree of height h contains at least 2h nodes.\r\nb. In a size-balanced binary tree of height h≤1, how many nodes are at distance h−1 from the root? Write only the answer without any explanations.",
        "answer": "None",
        "correct": "None",
        "explain": "None",
        "keyword": "Binary Trees"
    },
    {
        "question": "In the balanced binary tree in the below figure, how many nodes will become unbalanced when a node is inserted as a child of the node “g”?\r\n         a\r\n       /   \r\n      b     e\r\n     /    /\r\n    c  d  f\r\n   /\r\n  g\r\n",
        "answer": [
            "1",
            "3",
            "7",
            "8"
        ],
        "correct": "B",
        "explain": "None",
        "keyword": "Binary Trees"
    },
    {
        "question": "Which of the following sequences denotes the post order traversal sequence of the given tree?\r\n         a\r\n       /   \r\n      b     e\r\n     /    /\r\n    c  d  f\r\n   /\r\n  g\r\n\n",
        "answer": [
            " f e g c d b a",
            " g c b d a f e",
            " g c d b f e a ",
            " f e d g c b a"
        ],
        "correct": "C",
        "explain": "None",
        "keyword": "Binary Trees"
    },
    {
        "question": "\nConsider an array representation of an n element binary heap where the elements are stored from index 1 to index n of the array. For the element stored at index i of the array (i<=n), the index of the parent is:  \n",
        "answer": [
            "ceiling (i/2)",
            "floor (i/2)",
            "ceiling ((i+1)/2)",
            "floor ((i+1)/2)"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\">\n<p>Refer: <a href='\"https://www.geeksforgeeks.org/gate-gate-cs-2001-question-15/\"'>GATE-CS-2001 | Question 15</a> <br/><br/>To find parent of node at i index we have to find floor(i/2). <br/><br/>So, option (C) is correct.<br/> </p>\n</div>",
        "keyword": "Binary Trees"
    },
    {
        "question": "The number of structurally different possible binary trees with 4 nodes is",
        "answer": [
            "14",
            "12",
            "336",
            "168"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> The total number of structurally different possible binary trees can be found out using the <a href=\"https://www.geeksforgeeks.org/applications-of-catalan-numbers/\" rel=\"noopener\" target=\"_blank\">Catalon number</a> which is (2n)!/ (n! *(n+1)!).\r\nHere n=4, so, answer is 14.</div>",
        "keyword": "Binary Trees"
    },
    {
        "question": "A strictly binary tree with 10 leaves",
        "answer": [
            " cannot have more than 19 nodes",
            "has exactly 19 nodes",
            "has exactly 17 nodes",
            "has exactly 20 nodes"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> A strict binary tree with ‘n’ leaf nodes always have ‘2n-1’ intermediate nodes. With 10 leaf nodes a strict binary tree will have exactly 19 nodes.\r\n\r\nSo, option (B) is correct.</div>",
        "keyword": "Binary Trees"
    },
    {
        "question": "What is the maximum height of any AVL tree with 7 nodes? Assume that height of tree with single node is 0.",
        "answer": [
            "2",
            "3",
            "4",
            "5"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Refer:<a href=\"https://www.geeksforgeeks.org/data-structures-and-algorithms-set-16/\" rel=\"noopener\" target=\"_blank\"> Data Structures and Algorithms | Set 16</a></div>",
        "keyword": "Binary Trees"
    },
    {
        "question": "Which one of the following property is correct for a red-black tree?",
        "answer": [
            "Every simple path from a node to a descendant leaf contains the same number of black nodes",
            "If a node is red, then one children is red and another is black",
            "If a node is red, then both its children are red",
            "Every leaf node (sentinel node) is red"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Refer:<a href=\"https://www.geeksforgeeks.org/red-black-tree-set-1-introduction-2/\" rel=\"noopener\" target=\"_blank\"> Red-Black Tree | Set 1 (Introduction)</a>\r\nOption (A) is correct.\r\n</div>",
        "keyword": "Binary Trees"
    },
    {
        "question": "The in-order and pre-order traversal of a binary tree are d b e a f c g and a b d e c f g respectively. The post order traversal of a binary tree is",
        "answer": [
            "e d b g f c a",
            "e d b f g c a",
            "d e b f g c a",
            "d e f g b c a"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Refer: <a href=\"https://www.geeksforgeeks.org/gate-gate-cs-2007-question-39/\" rel=\"noopener\" target=\"_blank\"> GATE-CS-2007 | Question 39</a> \r\n\r\nOption (C) is correct.</div>",
        "keyword": "Binary Trees"
    },
    {
        "question": "Consider a full binary tree with n internal nodes, internal path length i, and external path length e. The internal path length of a full binary tree is the sum, taken over all nodes of the tree, of the depth of each node. Similarly, the external path length is the sum, taken over all leaves of the tree, of the depth of each leaf. Which of the following is correct for the full binary tree?",
        "answer": [
            "e = i+n",
            "e = i+2n",
            "e = 2i+n",
            "e = 2n+i"
        ],
        "correct": "B",
        "explain": "None",
        "keyword": "Binary Trees"
    },
    {
        "question": "The order of a leaf node in a B+ tree is the maximum number of children it can have. Suppose that block size is 1 kilobytes, the child pointer takes 7 bytes long and search field value takes 14 bytes long. The order of the leaf node is ________. \r\n",
        "answer": [
            "16",
            "63",
            "64",
            "68"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>\r\nKey size = 14 bytes (given)\r\n\r\nChild pointer = 7 bytes (given)\r\n\r\nWe assume the order of B+ tree to be ‘n’.\r\n\r\nBlock size &gt;= (n – 1) * key size + n * child pointer\r\n512 &gt;= (n – 1) * 14 + n * 7\r\n512 &gt;= 14 * n – 14 + 7 * n \r\nn &lt;= (1024 + 14) / 20\r\nn &lt;= 1038 / 21\r\nn &lt;= 49.42\r\n</pre>\r\nSo, option (A) is correct.</div>",
        "keyword": "Binary Trees"
    },
    {
        "question": "A complete binary tree with n non-leaf nodes contains",
        "answer": [
            "log2 n nodes",
            "n+1 nodes",
            "2n nodes",
            "2n+1 nodes"
        ],
        "correct": "D",
        "explain": "None",
        "keyword": "Binary Trees"
    },
    {
        "question": "Suppose you are given a binary tree with n nodes, such that each node has exactly either zero or two children. The maximum height of the tree will be",
        "answer": [
            "n / 2  - 1",
            "n / 2  + 1",
            "(n – 1) / 2",
            "(n + 1) / 2"
        ],
        "correct": "C",
        "explain": "None",
        "keyword": "Binary Trees"
    },
    {
        "question": "The number of different binary trees with 6 nodes is ______.",
        "answer": [
            "6",
            "42",
            "132",
            "256"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> The number of different binary trees with 6 nodes is fact(2n) / fact(n+1) * fac(n) where n is no nodes:\r\n<pre>If n= 6, then  fact(2 * n) / fact(n+1) * fac(n) \r\n= fact(2 * 6) / fact(6 + 1) * fact(6) \r\n= fact(12) / fact(7) * fact(6) \r\n= 12 * 11 * 10 * 9 * 8 * fact(7) / fact(7) * fact(6) \r\n= 12 * 11 * 10 * 9 * 8  / 6 * 5 * 4 * 3 * 2 \r\n= 6 * 11 * 2 \r\n= 132.</pre>\r\nSo, option (C) is correct.\r\n</div>",
        "keyword": "Binary Trees"
    },
    {
        "question": "Which of the following number of nodes can form a full binary tree?",
        "answer": [
            "8",
            "15",
            "14",
            "13"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\">  a full binary tree is a binary tree in which all nodes except leaves have two children.\r\n\r\nIn a Full Binary, number of leaf nodes is number of internal nodes plus 1\r\n\r\nL = I + 1\r\n\r\nWhere L = Number of leaf nodes, I = Number of internal nodes\r\n\r\nSo, option (B) is correct.</div>",
        "keyword": "Binary Trees"
    },
    {
        "question": "A full binary tree with n leaves contains:",
        "answer": [
            "n nodes ",
            "log2 n nodes",
            "2n-1",
            "2n"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\">  A <a href=\"https://www.geeksforgeeks.org/binary-tree-set-3-types-of-binary-tree/\" rel=\"noopener\" target=\"_blank\">Binary Tree</a> is full if every node has 0 or 2 children. So, in such case, the binary tree with n leaves contains a total of 2*n-1 nodes.\r\n\r\nOption (C) is correct.</div>",
        "keyword": "Binary Trees"
    },
    {
        "question": "A complete binary tree with the property that the value at each node is as least as large as the values at its children is known as",
        "answer": [
            "binary search tree",
            "AVL tree",
            "completely balanced tree",
            "Heap"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> In a Max. Binary Heap, the key value at each node is as least as large as the values at its children. Similarly in Min Binary Heap, the key at root must be minimum among all keys present in Binary Heap.\r\n\r\nSo, correct option is (D).</div>",
        "keyword": "Binary Trees"
    },
    {
        "question": "A full binary tree with n leaves contains",
        "answer": [
            "n nodes",
            "log 2 n nodes",
            "2n –1 node",
            "2 n nodes"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\">  A Binary Tree is full if every node has 0 or 2 children. Following are examples of full binary tree. We can also say a full binary tree is a binary tree in which all nodes except leaves have two children. A full binary tree with n leaves contains  2 * n – 1 nodes.\r\nSo, option (C) is correct.\r\n</div>",
        "keyword": "Binary Trees"
    },
    {
        "question": "Any decision tree that sorts n elements has height",
        "answer": [
            "Ω(n)",
            "Ω(lgn)",
            "Ω(nlgn)",
            "Ω(n2)"
        ],
        "correct": "A",
        "explain": "None",
        "keyword": "Binary Trees"
    },
    {
        "question": "Find the inorder and postorder of the binary tree with the given preorder:\r\n60, 40, 20, 10, 30, 33, 50, 44, 51, 90, 70, 65, 80, 110, 100, 95, 99, 120. ",
        "answer": [
            "In order: 110, 100, 99, 90, 80, 70, 65, 60, 51, 50, 44, 40, 33, 30, 20, 10.\r\nPostorder: 110, 120, 100, 95, 99, 70, 80, 65, 60, 40, 50, 51, 44, 20, 30,  33, 10\r\n",
            "Inorder: 10, 20, 30, 33, 40,  44, 50, 51, 60,  65, 70,  80,  90, 95,  99, 100, 110, 120\r\nPostorder: 10, 33, 30, 20, 44, 51, 50, 40,  65, 80, 70, 99, 95, 100, 120, 110, 90, 60\r\n",
            "In order: 10, 33, 30, 20, 44, 51, 50, 40, 60, 65, 80, 70, 99, 95, 100, 120, 110,\r\nPostorder: 10, 20, 30, 33, 40,  44, 50, 51, 60,  65, 70,  80,  90, 95,  99, 100, 110\r\n",
            "In order: 10, 33, 30, 20, 44, 51, 60,  65, 80, 70, 99, 95, 100, 120, 110,\r\nPostorder: 110, 100, 99, 90, 80, 70, 65, 60, 51, 50, 44, 40, 33, 30, 20, 10."
        ],
        "correct": "B",
        "explain": "None",
        "keyword": "Binary Trees"
    },
    {
        "question": "A binary search tree in which every non-leaf node has non-empty left and right subtrees is called a strictly binary tree. Such a tree with 19 leaves :",
        "answer": [
            "cannot have more than 37 nodes",
            "has exactly 37 nodes",
            "has exactly 35 nodes",
            "cannot have more than 35 nodes"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> 2(n)-1 where n is the for the leaves nodes. So by that way we have exactly 37 nodes.\r\n\r\nOption (B) is correct.</div>",
        "keyword": "Binary Trees"
    },
    {
        "question": "What is the worst case time complexity of inserting n2 elements into an AVL-tree with n elements initially ?",
        "answer": [
            "Θ(n4)",
            "Θ(n2)",
            "Θ(n2 log n)",
            "Θ(n3)"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Since <a href=\"https://www.geeksforgeeks.org/avl-tree-set-1-insertion/\" rel=\"noopener\" target=\"_blank\">AVL tree</a> is balanced tree, the height is O(log n). So, time complexity to insert an element in an AVL tree is O(log n) in worst case. \r\n\r\n<b>Note:</b>\n<pre>Every insertion of element:\r\nFinding place to insert = O(log n)\r\nIf property not satisfied (after insertion) do rotation = O(log n)\r\n\r\nSo, an AVL insertion take = O(log n) + O(log n) = O(log n) in worst case. </pre>\r\n\r\nNow, given n<sup>2</sup> element need to insert into given AVL tree, therefore, total time complexity will be O(n<sup>2</sup> log n).\r\n\r\n<b>Alternative method:</b> Time complexity in worst case,\r\n<pre>1st insertion time complexity = O(log n)\r\n2nd insertion time complexity = O(log(n+1))\r\n.\r\n.\r\n.\r\nn<sup>2</sup>th insertion time complexity = O(log(n + n<sup>2</sup>)) </pre>\r\nSo, total time complexity will be,\r\n<pre>= O(log n) +  O(log n+1)) + .... +  O(log(n + n<sup>2</sup>))\r\n= O(log n*(n+1)*(n+2)*...(n+n<sup>2</sup>))\r\n= O(log n<sup>n<sup>2</sup></sup>)\r\n= O(n<sup>2</sup> log n) </pre>\r\n\r\nOption (C) is correct.\r\n\r\n\r\n<iframe allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen=\"\" frameborder=\"0\" height=\"315\" src=\"https://www.youtube.com/embed/fP8QED8d6ws?start=2708\" title=\"YouTube video player\" width=\"560\"></iframe></div>",
        "keyword": "Binary Trees"
    },
    {
        "question": "What is the worst-case number of arithmetic operations performed by recursive binary search on a sorted array of size n?",
        "answer": [
            "Θ(√n)",
            "Θ(log2(n))",
            "Θ(n2)",
            "Θ(n)"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Arithmetic operations performed by <a href=\"https://www.geeksforgeeks.org/binary-search/\" rel=\"noopener\" target=\"_blank\">binary search</a> on sorted data items means computation of mid element required arithmetic operation. So it will be computed log(n) time and Hence option (C) will be correct.</div>",
        "keyword": "Binary Trees"
    },
    {
        "question": "Consider a complete binary tree with 7 nodes. Let A denote the set of first 3 elements obtained by performing Breadth-First Search (BFS) starting from the root. Let B denote the set of first 3 elements obtained by performing Depth-First Search (DFS) starting from the root.\r\n\r\nThe value of ∣A−B∣ is _____________ .",
        "answer": [
            "1",
            "2",
            "3",
            "4"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> In case of BFS if we draw complete binary tree then in Set A we have level1+level2. \r\nIn DFS we have level1+ level 2 + level 3. \r\n\r\nSo A-B= remaining element of level 2. \r\n\r\n<iframe allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen=\"\" frameborder=\"0\" height=\"315\" src=\"https://www.youtube.com/embed/I43aLH5qEBc?start=1915\" title=\"YouTube video player\" width=\"560\"></iframe></div>",
        "keyword": "Binary Trees"
    },
    {
        "question": "What is the worst case time complexity for search, insert and delete operations in a general Binary Search Tree?",
        "answer": [
            "O(n) for all ",
            "O(Logn) for all",
            "O(Logn) for search and insert, and O(n) for delete",
            "O(Logn) for search, and O(n) for insert and delete"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> In skewed Binary Search Tree (BST), all three operations can take O(n).  See the following example BST and operations. \r\n\r\n<pre>\r\n          10\r\n        /\r\n       20\r\n      /\r\n     30\r\n    / \r\n   40\r\n\r\nSearch 40. \r\nDelete 40\r\nInsert 50.\r\n</pre></div>",
        "keyword": "Binary Search Trees"
    },
    {
        "question": "In delete operation of BST, we need inorder successor (or predecessor) of a node when the node to be deleted has both left and right child as non-empty.   Which of the following is true about inorder successor needed in delete operation?",
        "answer": [
            "Inorder Successor is always a leaf node",
            "Inorder successor is always either a leaf node or a node with empty left child",
            "Inorder successor may be an ancestor of the node",
            "Inorder successor is always either a leaf node or a node with empty right child"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Let X be the node to be deleted in a tree with root as 'root'.  There are three cases for deletion\r\n\r\n1) X is a leaf node: We change left or right pointer of parent to NULL (depending upon whether X is left or right child of its parent) and we delete X \r\n2) One child of X is empty: We copy values of non-empty child to X and delete the non-empty child\r\n3) Both children of X are non-empty:  In this case, we find inorder successor of X. Let the inorder successor be Y.  We copy the contents of Y to X, and delete Y.\r\n\r\nSp we need inorder successor only when both left and right child of X are not empty.  In this case, the inorder successor Y can never be an ancestor of X.  In this case, the inorder successor is the leftmost node in right subtree of X.  Since it is leftmost node, the left child of Y must be empty.  </div>",
        "keyword": "Binary Search Trees"
    },
    {
        "question": "We are given a set of n distinct elements and an unlabelled binary tree with n nodes. In how many ways can we populate the tree with the given set so that it becomes a binary search tree? (GATE CS 2011)",
        "answer": [
            "0",
            "1",
            "n!",
            " (1/(n+1)).2nCn"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> There is only one way.  The minimum value has to go to the leftmost node and the maximum value to the rightmost node.  Recursively, we can define for other nodes.</div>",
        "keyword": "Binary Search Trees"
    },
    {
        "question": "How many distinct binary search trees can be created out of 4 distinct keys?",
        "answer": [
            "4",
            "14",
            "24",
            "42"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> See question 2 of <a href=\"http://www.geeksforgeeks.org/data-structures-and-algorithms-set-23/\">http://www.geeksforgeeks.org/data-structures-and-algorithms-set-23/</a> for explanation.   The link also has a generalized solution.</div>",
        "keyword": "Binary Search Trees"
    },
    {
        "question": "Which of the following traversal outputs the data in sorted order in a BST?",
        "answer": [
            "Preorder",
            "Inorder",
            "Postorder",
            "Level order"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Inorder traversal of a BST outputs data in sorted order. <a href=\"http://www.geeksforgeeks.org/618/\" target=\"_blank\">Read here</a> for details.</div>",
        "keyword": "Binary Search Trees"
    },
    {
        "question": "Suppose the numbers 7, 5, 1, 8, 3, 6, 0, 9, 4, 2 are inserted in that order into an initially empty binary search tree. The binary search tree uses the usual ordering on natural numbers. What is the in-order traversal sequence of the resultant tree?",
        "answer": [
            "7 5 1 0 3 2 4 6 8 9",
            "0 2 4 3 1 6 5 9 8 7",
            "0 1 2 3 4 5 6 7 8 9",
            "9 8 6 4 2 3 0 1 5 7"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> In-order traversal of a BST gives elements in increasing order. So answer c is correct without any doubt.</div>",
        "keyword": "Binary Search Trees"
    },
    {
        "question": "\nThe following numbers are inserted into an empty binary search tree in the given order: 10, 1, 3, 5, 15, 12, 16. What is the height of the binary search tree (the height is the maximum distance of a leaf node from the root)? (GATE CS 2004) \n",
        "answer": [
            "\n2 \n",
            "\n3 \n",
            "\n4 \n",
            "\n6 \n"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\">\n<p>Constructed binary search tree will be.</p>\n<img sizes=\"100vw\" src=\"https://media.geeksforgeeks.org/wp-content/uploads/20220225200524/img-200x132.PNG\" srcset=\"https://media.geeksforgeeks.org/wp-content/uploads/20220225200524/img.PNG, \" width=\"200\"/>\n<p><br/><br/> </p>\n</div>",
        "keyword": "Binary Search Trees"
    },
    {
        "question": "The preorder traversal sequence of a binary search tree is 30, 20, 10, 15, 25, 23, 39, 35, 42. Which one of the following is the postorder traversal sequence of the same tree? ",
        "answer": [
            "10, 20, 15, 23, 25, 35, 42, 39, 30 ",
            "15, 10, 25, 23, 20, 42, 35, 39, 30",
            "15, 20, 10, 23, 25, 42, 35, 39, 30 ",
            " 15, 10, 23, 25, 20, 35, 42, 39, 30"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> The following is the constructed tree<pre>\r\n            30\r\n         /      \\\r\n        20       39 \r\n       /  \\     /  \\\r\n     10    25  35  42  \r\n      \\   /\r\n      15 23\r\n</pre></div>",
        "keyword": "Binary Search Trees"
    },
    {
        "question": "Consider the following Binary Search Tree \r\n\r\n               10\r\n             /    \r\n            5      20\r\n           /      /             \r\n          4     15    30\r\n               /  \r\n              11       \r\n\r\nIf we randomly search one of the keys present in above BST, what would be the expected number of comparisons?\r\n        ",
        "answer": [
            "2.75",
            "2.25",
            "2.57",
            "3.25"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Expected number of comparisons = (1*1 + 2*2 + 3*3 + 4*1)/7  = 18/7 = 2.57</div>",
        "keyword": "Binary Search Trees"
    },
    {
        "question": "Which of the following traversals is sufficient to construct BST from given traversals\r\n1) Inorder\r\n2) Preorder\r\n3) Postorder",
        "answer": [
            "Any one of the given three traversals is sufficient",
            "Either 2 or 3 is sufficient",
            "2 and 3",
            "1 and 3"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> When we know either preorder or postorder traversal, we can construct the BST.  Note that we can always sort the given traversal and get the inorder traversal.  Inorder traversal of BST is always sorted.\r\n</div>",
        "keyword": "Binary Search Trees"
    },
    {
        "question": "Consider the following code snippet in C. The function print() receives root of a Binary Search Tree (BST) and a positive integer k as arguments.\r\n\r\n\r\n// A BST node\r\nstruct node {\r\n    int data;\r\n    struct node *left, *right;\r\n};\r\n\r\nint count = 0;\r\n\r\nvoid print(struct node *root, int k)\r\n{\r\n    if (root != NULL && count <= k)\r\n    {\r\n        print(root->right, k);\r\n        count++;\r\n        if (count == k)\r\n          printf(\"%d \", root->data);\r\n       print(root->left, k);\r\n    }\r\n}\r\n\r\n\r\nWhat is the output of print(root, 3) where root represent root of the following BST.\r\n                   15\r\n                /     \r\n              10      20\r\n             /      /  \r\n            8  12   16  25   \r\n",
        "answer": [
            "10",
            "16",
            "20",
            "20 10"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> The code mainly finds out k'th largest element in BST, see <a href=\"http://www.geeksforgeeks.org/kth-largest-element-in-bst-when-modification-to-bst-is-not-allowed/\">K’th Largest Element in BST</a>  for details.</div>",
        "keyword": "Binary Search Trees"
    },
    {
        "question": "Consider the same code as given in above question.  What does the function print() do in general?\r\n\r\nThe function print() receives root of a Binary Search Tree (BST) and a positive integer k as arguments.  \r\n\n\r\n// A BST node\r\nstruct node {\r\n    int data;\r\n    struct node *left, *right;\r\n};\r\n\r\nint count = 0;\r\n\r\nvoid print(struct node *root, int k)\r\n{\r\n    if (root != NULL && count <= k)\r\n    {\r\n        print(root->right, k);\r\n        count++;\r\n        if (count == k)\r\n          printf(\"%d \", root->data);\r\n       print(root->left, k);\r\n    }\r\n}\r\n",
        "answer": [
            "Prints the kth smallest element in BST",
            "Prints the kth largest element in BST",
            "Prints the leftmost node at level k from root",
            "Prints the rightmost node at level k from root"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> The function basically does reverse inorder traversal of the given Binary Search Tree.  The reverse inorder traversal produces data in reverse sorted order.  Whenever a nod is visited, count is incremented by 1 and data of a node is printed only when count becomes k.</div>",
        "keyword": "Binary Search Trees"
    },
    {
        "question": "You are given the postorder traversal, P, of a binary search tree on the n elements 1, 2, ..., n. You have to determine the unique binary search tree that has P as its postorder traversal. What is the time complexity of the most efficient algorithm for doing this?",
        "answer": [
            "O(Logn)",
            "O(n)",
            "O(nLogn)",
            "none of the above, as the tree cannot be uniquely determined."
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> One important thing to note is, it is Binary Search Tree, not Binary Tree. In BST, inorder traversal can always be obtained by sorting all keys.\r\n\r\nSee method 2 of <a href=\"http://www.geeksforgeeks.org/construct-bst-from-given-preorder-traversa/\">http://www.geeksforgeeks.org/construct-bst-from-given-preorder-traversa/</a> for details.\r\n\r\nSame technique can be used for postorder traversal.</div>",
        "keyword": "Binary Search Trees"
    },
    {
        "question": "Suppose we have a balanced binary search tree T holding n numbers. We are given two numbers L and H and wish to sum up all the numbers in T that lie between L and H. Suppose there are m such numbers in T. If the tightest upper bound on the time to\r\ncompute the sum is O(nalogb n + mc logd n), the value of a + 10b + 100c + 1000d is ____.",
        "answer": [
            "60",
            "110",
            "210",
            "50"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>int getSum(node *root, int L, int H)\r\n{\r\n   // Base Case\r\n   if (root == NULL)\r\n      return 0;\r\n\r\n   if (root-&gt;key &lt; L)        \r\n       return getSum(root-&gt;right, L, H);\r\n\r\n  if (root-&gt;key &gt; H)\r\n      return getSum(root-&gt;left, L, H)\r\n\r\n   if (root-&gt;key &gt;= L &amp;&amp; root-&gt;key &lt;=H)        \r\n      return getSum(root-&gt;left, L, H) + root-&gt;key +\r\n             getSum(root-&gt;right, L, H);\r\n}</pre>\r\nThe above always takes O(m + Logn) time. Note that the code first traverses across height to find the node which lies in range.  Once such a node is found, it recurs for left and right children.  Two recursive calls are made only if the node is in range.  So for every node that is in range, we make at most one extra call (here extra call means calling for a node that is not in range).  \r\n</div>",
        "keyword": "Binary Search Trees"
    },
    {
        "question": "Let T(n) be the number of different binary search trees on n distinct elements.\r\nThen , where x is",
        "answer": [
            "n-k+1",
            "n-k",
            "n-k-1",
            "n-k-2"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> The idea is to make a key root, put (k-1) keys in one subtree and remaining n-k keys in other subtree.\r\n\r\n<span style=\"font-size: small;\">A Binary Search Tree (BST) is a tree in which all the nodes follow the below-mentioned properties −</span>\n<ul>\n<li><span style=\"font-size: small;\">The left sub-tree of a node has a key less than or equal to its parent node's key.</span></li>\n<li><span style=\"font-size: small;\">The right sub-tree of a node has a key greater than to its parent node's key.</span></li>\n</ul>\n<span style=\"font-size: small;\">Now construction binary search trees from n distinct number-\r\nLets for simplicity consider n distinct numbers as first n natural numbers (starting from 1)\r\n<u>If n=1 </u> We have only one possibility, therefore only 1 BST.\r\n<u>If n=2 </u>We have 2 possibilities , when smaller number is root and bigger number is the right child or second when the bigger number is root and smaller number as left child.</span>\r\n\r\n \r\n\r\n<a href=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/12/parul_1.png\"><img alt=\"parul_1\" class=\"alignnone size-full wp-image-29191\" height=\"137\" src=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/12/parul_1.png\" width=\"642\"/></a>\n<span style=\"font-size: small;\"><u>If n=3 </u>We have 5 possibilities. Keeping each number first as root and then arranging the remaining 2 numbers as in case of n=2.</span>\n<a href=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/12/parul_2.png\"><img alt=\"parul_2\" class=\"alignnone size-full wp-image-29192\" height=\"237\" src=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/12/parul_2.png\" width=\"486\"/></a>\r\n\r\n \r\n\r\n<span style=\"font-size: small;\"><u>If n=4 </u>We have 14 possibilities. Taking each number as root and arranging smaal numbers as left subtree and larger numbers as right subtree.\r\n<a href=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/12/parul_4.png\"><img alt=\"parul_4\" class=\"alignnone size-full wp-image-29193\" height=\"403\" src=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/12/parul_4.png\" width=\"533\"/></a>\n</span>\n<span style=\"font-size: small;\">Thus we can conclude that with n distinct numbers, if we take ‘k’ as root then all the numbers smaller than k will left subtree and numbers larger than k will be right subtree where the the right subtree and left subtree will again be constructed recursively like the root.\r\nTherefore,\r\n</span>\n<a href=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/12/parul5.png\"><img alt=\"parul5\" class=\"alignnone size-full wp-image-29194\" height=\"100\" src=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/12/parul5.png\" width=\"529\"/></a>\r\n\r\n \r\n\r\nThis solution is contributed by <strong>Parul Sharma.</strong></div>",
        "keyword": "Binary Search Trees"
    },
    {
        "question": "What are the worst-case complexities of insertion and deletion of a key in a binary search tree?",
        "answer": [
            "Θ(logn) for both insertion and deletion",
            "Θ(n) for both insertion and deletion",
            "Θ(n) for insertion and Θ(logn) for deletion",
            "Θ(logn) for insertion and Θ(n) for deletion"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> The time taken by search, insert and delete on a BST is always proportional to height of BST.  Height may become O(n) in worst case.</div>",
        "keyword": "Binary Search Trees"
    },
    {
        "question": "While inserting the elements 71, 65, 84, 69, 67, 83 in an empty binary search tree (BST) in the sequence shown, the element in the lowest level is\r\n",
        "answer": [
            "65",
            "67",
            "69 ",
            "83"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Here is The Insertion Algorithm For a Binary Search Tree :\r\n<pre>\r\nInsert(Root,key)\r\n{\r\n    if(Root is NULL)\r\n        Create a Node with value as key and return\r\n    Else if(Root.key &gt;= key)\r\n        Insert(Root.left,key)\r\n    Else\r\n        Insert(Root.right,key)\r\n}\r\n</pre>\r\nCreating the BST one by one using the above algorithm in the below given image : \r\n\r\n<a href=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2017/01/pranjul_23.png\"><img alt=\"pranjul_23\" class=\"alignnone size-full wp-image-29273\" height=\"514\" src=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2017/01/pranjul_23.png\" width=\"478\"/></a>\r\n\r\nThis solution is contributed by <strong>Pranjul Ahuja.</strong>\n</div>",
        "keyword": "Binary Search Trees"
    },
    {
        "question": "The number of ways in which the numbers 1, 2, 3, 4, 5, 6, 7 can be inserted in an empty binary search tree, such that the resulting tree has height 6, is _____________\r\n\r\nNote: The height of a tree with a single node is 0.\r\n\r\n[This question was originally a Fill-in-the-Blanks question]",
        "answer": [
            "2",
            "4",
            "64",
            "32"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\">  To get height 6, we need to put either 1 or 7 at root.\r\n\r\n\r\nSo count can be written as T(n) = 2*T(n-1) with T(1) = 1\r\n\r\n <pre>\r\n\r\n    7\r\n   / \r\n [1..6]  \r\n\r\n    1\r\n      \\\r\n     [2..7] </pre>\r\n\r\nTherefore count is 2<sup>6</sup> = 64\r\n\r\nAnother Explanation:\r\n\r\nConsider these cases,\r\n1 2 3 4 5 6 7\r\n1 2 3 4 5 7 6\r\n1 7 6 5 4 3 2\r\n1 7 6 5 4 2 3\r\n7 6 5 4 3 2 1\r\n7 6 5 4 3 1 2\r\n7 1 2 3 4 5 6\r\n7 1 2 3 4 6 5\r\n\r\nFor height 6, we have 2 choices. Either we select the root as 1 or 7.\r\nSuppose we select 7.\r\nNow, we have 6 nodes and remaining height = 5.\r\nSo, now we have 2 ways to select root for this sub-tree also.\r\nNow, we keep on repeating the same procedure till remaining height = 1\r\nFor this last case also, we have 2 ways.\r\n\r\nTherefore, total number of ways = 2<sup>6</sup>= 64\r\n                                </div>",
        "keyword": "Binary Search Trees"
    },
    {
        "question": "Suppose that we have numbers between 1 and 100 in a binary search tree and want to search for the number 55. Which of the following sequences CANNOT be the sequence of nodes examined?",
        "answer": [
            "{10, 75, 64, 43, 60, 57, 55}",
            "{90, 12, 68, 34, 62, 45, 55}",
            "{9, 85, 47, 68, 43, 57, 55}",
            "{79, 14, 72, 56, 16, 53, 55}"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> In BST, on right child of parent should be greater than parent and left child should be smaller than the parent, but in C after 47, 68 goes on the right side because it greater then parent, now everything below this point should be greater then 47 but 43 appears that does not satisfy the BST property.\r\n\r\n<img alt=\"\" class=\"aligncenter size-full wp-image-513840\" height=\"483\" src=\"https://media.geeksforgeeks.org/wp-content/cdn-uploads/20201116142856/1227.png\" width=\"555\"/></div>",
        "keyword": "Binary Search Trees"
    },
    {
        "question": "When searching for the key value 60 in a binary search tree, nodes containing the key values 10, 20, 40, 50, 70 80, 90 are traversed, not necessarily in the order given. How many different orders are possible in which these key values can occur on the search path from the root to the node containing the value 60?",
        "answer": [
            "35",
            "64",
            "128",
            "5040"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> There are two set of values, smaller than 60 and greater than 60. Smaller values 10, 20, 40 and 50 are visited, means they are visited in order. Similarly, 90, 80 and 70 are visited in order. <br/>\r\n= 7!/(4!3!)<br/>\r\n= 35</div>",
        "keyword": "Binary Search Trees"
    },
    {
        "question": "A Binary Search Tree (BST) stores values in the range 37 to 573. Consider the following sequence of keys. \r\nI.  81, 537, 102, 439, 285, 376, 305\r\nII. 52, 97, 121, 195, 242, 381, 472\r\nIII. 142, 248, 520, 386, 345, 270, 307\r\nIV. 550, 149, 507, 395, 463, 402, 270 \nSuppose the BST has been unsuccessfully searched for key 273. Which all of the above sequences list nodes in the order in which we could have encountered them in the search?",
        "answer": [
            "II and III only",
            "I and III only",
            "III and IV only",
            "III only"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> Key to be searched 273:\r\n<ul><li>I)  81, 537, 102, 439, 285, 376, 305 is not correct\r\n    We cannot go to 376 from 285 as 273 is smaller than 285.</li>\n<li>II) 52, 97, 121, 195, 242, 381, 472 is not correct.  \r\n    We cannot go to 472 from 381 as 273 is smaller than 381.</li>\n<li>III) 142, 248, 520, 386, 345, 270, 307 is correct \r\n<a href=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/05/2008_71_sol.jpg\"><img alt=\"2008_71_sol\" class=\"alignnone size-medium wp-image-26147\" height=\"111\" src=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/05/2008_71_sol-300x111.jpg\" width=\"300\"/></a></li>\n<li>550, 149, 507, 395, 463, 402, 270 is not correct.\r\n   We cannot go to 463 from 395 in search of 273</li></ul>\r\n\r\n\r\n  Following representation of the binary search trees is given below.\r\n\r\n<img alt=\"\" class=\"aligncenter size-full wp-image-513836\" height=\"531\" src=\"https://media.geeksforgeeks.org/wp-content/cdn-uploads/20201116142724/12233.png\" width=\"1072\"/></div>",
        "keyword": "Binary Search Trees"
    },
    {
        "question": "A Binary Search Tree (BST) stores values in the range 37 to 573. Consider the following sequence of keys.\r\nI. 81, 537, 102, 439, 285, 376, 305\r\n II. 52, 97, 121, 195, 242, 381, 472\r\n III. 142, 248, 520, 386, 345, 270, 307\r\n IV. 550, 149, 507, 395, 463, 402, 270\r\nWhich of the following statements is TRUE?",
        "answer": [
            "I, II and IV are inorder sequences of three different BSTs",
            "I is a preorder sequence of some BST with 439 as the root",
            "II is an inorder sequence of some BST where 121 is the root and 52 is a leaf",
            "IV is a postorder sequence of some BST with 149 as the root"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> A: I and IV are not in ascending order\r\nB: If 439 is root, It should be 1st element in preorder\r\nD: If 149 is root, It should be last element in postorder</div>",
        "keyword": "Binary Search Trees"
    },
    {
        "question": "How many distinct BSTs can be constructed with 3 distinct keys?",
        "answer": [
            "4",
            "5",
            "6",
            "9"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> <sup>2n</sup>C<sub>n</sub>/(n+1) = <sup>6</sup>C<sub>3</sub>/4 = 5</div>",
        "keyword": "Binary Search Trees"
    },
    {
        "question": "A binary search tree is generated by inserting in order the following integers:\r\n 50, 15, 62, 5, 20, 58, 91, 3, 8, 37, 60, 24 \r\nThe number of nodes in the left subtree and right subtree of the root respectively is",
        "answer": [
            "(4, 7)",
            "(7, 4)",
            "(8, 3)",
            "(3, 8)"
        ],
        "correct": "B",
        "explain": "None",
        "keyword": "Binary Search Trees"
    },
    {
        "question": "A binary search tree is used to locate the number 43. Which of the following probe sequences are possible and which are not? Explain",
        "answer": [
            "61   52   14   17   40   43",
            "2    3   50   40   60   43",
            "10   65   31   48   37   43",
            "81   61   52   14   41   43",
            "17   77   27   66   18   43"
        ],
        "correct": "A",
        "explain": "None",
        "keyword": "Binary Search Trees"
    },
    {
        "question": "The postorder traversal of a binary tree is 8, 9, 6, 7, 4, 5, 2, 3, 1. The inorder traversal of the same tree is 8, 6, 9, 4, 7, 2, 5, 1, 3. The height of a tree is the length of the longest path from the root to any leaf. The height of the binary tree above is ________ .\r\n\r\nNote -This was Numerical Type question.",
        "answer": [
            "2",
            "3",
            "4",
            "5"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Given, post-order - 8, 9, 6, 7, 4, 5, 2, 3, 1\r\nand in-order - 8, 6, 9, 4, 7, 2, 5, 1, 3\r\n\r\n<a href=\"https://www.geeksforgeeks.org/construct-a-binary-tree-from-postorder-and-inorder/\" rel=\"noopener\" target=\"_blank\">Construct a binary tree from postorder and inorder</a> traversal :\r\n\r\n<img alt=\"5\" class=\"aligncenter size-full wp-image-182164\" height=\"352\" src=\"https://www.geeksforgeeks.org/wp-content/uploads/5-5.png\" width=\"257\"/>\r\n\r\nThe height of the binary tree above is <b>4</b>.\r\n\r\n\r\n<iframe allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen=\"\" frameborder=\"0\" height=\"315\" src=\"https://www.youtube.com/embed/j9Vmf5yRw-I?start=3199\" title=\"YouTube video player\" width=\"560\"></iframe></div>",
        "keyword": "Binary Search Trees"
    },
    {
        "question": "The following numbers are inserted into an empty binary search tree in the given order:\r\n\r\n10, 1, 3, 5, 15, 12, 16 \r\n\r\nWhat is the height of the binary search tree ?",
        "answer": [
            "3",
            "4",
            "5",
            "6"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> We have 10, 1, 3, 5, 15, 12, 16 keys and we have to insert these keys into a binary search tree (BST):\r\n<ul>\n<li><b>Step-1.</b> Insert  10 into the BST.</li>\n<li><b>Step-2.</b> Compare 1 with 10 it is less than 10 So it will be left child for 10.</li>\n<li><b>Step-3.</b> Now compare next key ie 3 to 10, it is less than 10,it will be in left sub tree of 10. Now compare 3 with next node ie 1, 3 is greater than 1 so it will be right child to node 1. </li>\n<li><b>Step-4.</b> Next key is 5 follow the same procedure as in previous step. 5 will be right child for node 3.</li>\n<li><b>Step-5.</b> Key 15 will be compared to parent node first and it is greater than 10 so it will be right child to node 10.</li>\n<li><b>Step-6.</b> Key 12 will be compared to parent node first it is greater so  next comparison will be to the right child of parent node ie 15,now 12 is less than 15 so 12 will be left child node 15.</li>\n<li><b>Step-7.</b> Now the last key 16 will be compared to parent node first, it is greater than 10 so comparision will be shifted to right child of 10 ie 15 and key 16 is greater than 15 also so 16 will be right child to node 15.</li>\n<ul>\r\n\r\nHere is the constructed BST:\r\n<img alt=\"\" class=\"aligncenter size-full\" height=\"251\" src=\"https://www.geeksforgeeks.org/wp-content/uploads/BST.png\" width=\"256\"/>\r\n\r\nThis tree has 4 level and height of tree is <b>level - 1</b> So height of this tree will be 4-1 = 3.\r\n\r\nSo, option (A) is correct.\r\n</ul></ul></div>",
        "keyword": "Binary Search Trees"
    },
    {
        "question": "Postorder traversal of a given binary search tree T produces following sequence of keys:\r\n3, 5, 7, 9, 4, 17, 16, 20, 18, 15, 14\r\nWhich one of the following sequences of keys can be the result of an in-order traversal of the tree T?",
        "answer": [
            "3, 4, 5, 7, 9, 14, 20, 18, 17, 16, 15",
            "20, 18, 17, 16, 15, 14, 3, 4, 5, 7, 9",
            "20, 18, 17, 16, 15, 14, 9, 7, 5, 4, 3",
            "3, 4, 5, 7, 9, 14, 15, 16, 17, 18, 20"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> Since Inorder traversal of a BST always gives elements in increasing order. For this question sorted order of keys will always be the in-order tree traversal for post-order traversal.\r\nSo, option (D) is correct.  </div>",
        "keyword": "Binary Search Trees"
    },
    {
        "question": "A binary search tree is used to locate the number 43. Which one of the following probe sequence is not possible?",
        "answer": [
            "61, 52, 14, 17, 40, 43",
            "10, 65, 31, 48, 37, 43",
            "81, 61, 52, 14, 41, 43",
            "17, 77, 27, 66, 18, 43"
        ],
        "correct": "D",
        "explain": "None",
        "keyword": "Binary Search Trees"
    },
    {
        "question": "Which of the following statements is false ? \r\n(A) Optimal binary search tree construction can be performed efficiently using dynamic programming.\r\n(B) Breadth-first search cannot be used to find connected components of a graph.\r\n(C) Given the prefix and postfix walks of a binary tree, the tree cannot be re-constructed uniquely.\r\n(D) Depth-first-search can be used to find the connected components of a graph. ",
        "answer": [
            "A",
            "B",
            "C",
            "D"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> (A) Optimal binary search tree construction can be performed efficiently using dynamic programming.\r\n(B) Breadth-first search cannot be used to find connected components of a graph.\r\n(C) Given the prefix and postfix walks of a binary tree, the tree cannot be re-constructed uniquely.\r\n(D) Depth-first-search can be used to find the connected components of a graph.\r\nAll statements are correct except (B) because BFS can be used to check connectivity of graphs.\r\nSo, option (B) is correct.</div>",
        "keyword": "Binary Search Trees"
    },
    {
        "question": "Access time of the symbolic table will be logarithmic if it is implemented by",
        "answer": [
            "Linear list",
            "Search tree",
            "Hash table",
            "Self organization list"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Search tree has average O(log n) searching in <a href=\"https://www.geeksforgeeks.org/symbol-table-compiler/\" rel=\"noopener\" target=\"_blank\">symbol table</a>. Hashing can have O(n) searching if list is used to resolved Collison. \r\n\r\n\r\nOption (B) is correct.</div>",
        "keyword": "Binary Search Trees"
    },
    {
        "question": "Consider the following binary search tree T given below:\r\n Which node contains the fourth smallest element in T?\r\n\r\n",
        "answer": [
            "Q",
            "V",
            "W",
            "X"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> In a BST, value (left node) &lt; value(root) &lt; value(right node)\r\nWe can consider an example to find out the 4th smallest element:\r\n\r\n<img src=\"https://www.geeksforgeeks.org/wp-content/uploads/iii.png\"/>\r\n\r\nFrom the above BST, we can clearly see that 8 is the fourth smallest element.\r\nSo, option (C) is correct. \r\n</div>",
        "keyword": "Binary Search Trees"
    },
    {
        "question": "Consider the following binary search tree:\r\n\r\nIf we remove the root node, which of the node from the left subtree will be the new root?",
        "answer": [
            "11",
            "12",
            "13",
            "16"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> When we delete root node, tree will be\r\n<img alt=\"21 (1)\" class=\"alignnone size-medium wp-image-194926\" src=\"https://www.geeksforgeeks.org/wp-content/uploads/21-1-1.png\">\r\nbut this tree is not balance, so we will find inorder predecessor or inorder successor and replace it with root node now. In this problem we will use inorder predecessor-\r\n<img alt=\"21 (2)\" class=\"alignnone size-medium wp-image-194935\" src=\"https://www.geeksforgeeks.org/wp-content/uploads/21-2.png\"/>\r\nRoot node will be 16.\r\nSo, option (D) is correct.\r\n\r\n</img></div>",
        "keyword": "Binary Search Trees"
    },
    {
        "question": "Suppose that we have numbers between 1 and 1,000 in a binary search tree and want to search for the number 364. Which of the following sequences could not be the sequence of nodes examined ?",
        "answer": [
            "925, 221, 912, 245, 899, 259, 363, 364",
            "3, 400, 388, 220, 267, 383, 382, 279, 364",
            "926, 203, 912, 241, 913, 246, 364",
            "3, 253, 402, 399, 331, 345, 398, 364"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> We have to find 364 in BST:\r\n<ul><li>In first option 925 is root node, our key is less then 925 so we go for left BST. Next node is 221 → 912 → 245 → 899 → 259 → 363 → 364 respectively.</li>\n<li>In second option 3 is root node, we go for right BST i.e. 400 → 388 → 220 → 267 → 383 → 382 → 279 → 364 respectively.</li>\n<li>In third option 926 is root node, we go for left BST i.e. 203 → 912 → 241 next key is 913 we cant go for 913 after 241 because we are already in left BST of 912 our key will be surely in left BST of 912. This option is incorrect.</li>\n<li>In fourth option 3 is root node, we go for right BST i.e. 253 → 402 → 399 → 331 → 345 → 398 → 364.</li></ul>\r\nSo, option (C) is correct.  </div>",
        "keyword": "Binary Search Trees"
    },
    {
        "question": "The number of disk pages access in B - tree search, where h is height, n is the number of keys, and t is the minimum degree, is:",
        "answer": [
            " θ(logn h * t) ",
            " θ(logt n * h) ",
            " θ(logh n) ",
            " θ(logt n) "
        ],
        "correct": "D",
        "explain": "None",
        "keyword": "Binary Search Trees"
    },
    {
        "question": "How many distinct binary search trees can be created out of 4 distinct keys?",
        "answer": [
            "5",
            "14",
            "24",
            "35"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Distinct binary search trees that can be created out of 4 distinct keys can be found out using the Catalon number.\r\nCatalon number = (2n)!/(n! * (n+1)!)\r\nHere n = 4,\r\nNumber of distinct BST's = (4 x 2)! / (4! x 5!) = 14\r\nSo, correct option is (B)</div>",
        "keyword": "Binary Search Trees"
    },
    {
        "question": "The average depth of a binary search tree is:",
        "answer": [
            "O(n0.5)",
            "O(n)",
            "O(log n)",
            "O(n log n)"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> The average height of a <a href=\"https://www.geeksforgeeks.org/binary-search-tree-set-1-search-and-insertion/\" rel=\"noopener\" target=\"_blank\">Binary Search tree</a> is log(n)</div>",
        "keyword": "Binary Search Trees"
    },
    {
        "question": "The following numbers are inserted into an empty binary search tree in the given order: 10, 1, 3, 5, 15, 12, 16. What is the height of the binary search tree (the height is the maximum distance of a leaf node from the root)?",
        "answer": [
            "2",
            "3",
            "4",
            "6"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> <img src=\"https://www.geeksforgeeks.org/wp-content/uploads/isro_26.png\"/>\r\n\r\nSo, height of the tree is 3, option (B) is correct.</div>",
        "keyword": "Binary Search Trees"
    },
    {
        "question": "The preorder traversal of a binary search tree is 15, 10, 12, 11, 20, 18, 16, 19. Which one of the following is the postorder traversal of the tree ?",
        "answer": [
            "10, 11, 12, 15, 16, 18, 19, 20",
            "11, 12, 10, 16, 19, 18, 20, 15",
            "20, 19, 18, 16, 15, 12, 11, 10",
            "19, 16, 18, 20, 11, 12, 10, 15"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Please refer - <a href=\"https://www.geeksforgeeks.org/find-postorder-traversal-of-bst-from-preorder-traversal/\" rel=\"noopener\" target=\"_blank\">Find postorder traversal of BST from preorder traversal</a>\r\n\r\n[sourcecode language=CPP14]\r\n// C++ program for finding postorder \r\n// traversal of BST from preorder traversal \r\n#include <bits stdc++.h=\"\"> \r\nusing namespace std; \r\n\r\n// Function to find postorder traversal from \r\n// preorder traversal. \r\nvoid findPostOrderUtil(int pre[], int n, int minval, \r\n\t\t\t\t\tint maxval, int&amp; preIndex) \r\n{ \r\n\r\n\t// If entire preorder array is traversed then \r\n\t// return as no more element is left to be \r\n\t// added to post order array. \r\n\tif (preIndex == n) \r\n\t\treturn; \r\n\r\n\t// If array element does not lie in range specified, \r\n\t// then it is not part of current subtree. \r\n\tif (pre[preIndex] &lt; minval || pre[preIndex] &gt; maxval) { \r\n\t\treturn; \r\n\t} \r\n\r\n\t// Store current value, to be printed later, after \r\n\t// printing left and right subtrees. Increment \r\n\t// preIndex to find left and right subtrees, \r\n\t// and pass this updated value to recursive calls. \r\n\tint val = pre[preIndex]; \r\n\tpreIndex++; \r\n\r\n\t// All elements with value between minval and val \r\n\t// lie in left subtree. \r\n\tfindPostOrderUtil(pre, n, minval, val, preIndex); \r\n\r\n\t// All elements with value between val and maxval \r\n\t// lie in right subtree. \r\n\tfindPostOrderUtil(pre, n, val, maxval, preIndex); \r\n\r\n\tcout &lt;&lt; val &lt;&lt; \" \"; \r\n} \r\n\r\n// Function to find postorder traversal. \r\nvoid findPostOrder(int pre[], int n) \r\n{ \r\n\r\n\t// To store index of element to be \r\n\t// traversed next in preorder array. \r\n\t// This is passed by reference to \r\n\t// utility function. \r\n\tint preIndex = 0; \r\n\r\n\tfindPostOrderUtil(pre, n, INT_MIN, INT_MAX, preIndex); \r\n} \r\n\r\n// Driver code \r\nint main() \r\n{ \r\n\tint pre[] = { 15, 10, 12, 11, 20, 18, 16, 19 }; \r\n\r\n\tint n = sizeof(pre) / sizeof(pre[0]); \r\n\r\n\t// Calling function \r\n\tfindPostOrder(pre, n); \r\n\treturn 0; \r\n} \r\n[/sourcecode]\r\n\r\n<b>Code - </b> <a href=\"https://ide.geeksforgeeks.org/t49kAtJwr7\" rel=\"noopener\" target=\"_blank\">https://ide.geeksforgeeks.org/t49kAtJwr7</a>\r\n\r\n\r\nOption (B) is correct.\r\n\r\n\r\n<iframe allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen=\"\" frameborder=\"0\" height=\"315\" src=\"https://www.youtube.com/embed/fP8QED8d6ws?start=2269\" title=\"YouTube video player\" width=\"560\"></iframe></bits></div>",
        "keyword": "Binary Search Trees"
    },
    {
        "question": "In a balanced binary search tree with n elements, what is the worst case time complexity of reporting all elements in range [a,b] ? Assume that the number of reported elements is k.",
        "answer": [
            "Θ(log n)",
            "Θ(log(n)+k)",
            "Θ(k log n)",
            "Θ(n log k)"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> <ol>\n<li>Time complexity to check if element 'a' in given balanced binary search tree = O(log n)\r\n</li>\n<li>Time complexity to check if element 'a' in given balanced binary search tree = O(log n)\r\n</li>\n<li>Now, time complexity to traverse all element in range [a, b], those elements will be inorder sorted = θ(k)\r\n</li>\n</ol></div>",
        "keyword": "Binary Search Trees"
    },
    {
        "question": "A binary search tree T contains n distinct elements. What is the time complexity of picking an element in T that is smaller than the maximum element in T?",
        "answer": [
            "Θ(nlogn)",
            "Θ(n)",
            "Θ(logn)",
            "Θ(1)"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> Pick any two element from the root, and return minimum of these two. \r\n\r\nSo, time is Θ(1).</div>",
        "keyword": "Binary Search Trees"
    },
    {
        "question": "The worst case running time to search for an element in a balanced in a binary search tree with n2^n elements is \r\n\r\n(A) \r\n(B) \r\n(C) \r\n(D) \n",
        "answer": [
            "A",
            "B",
            "C",
            "D"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Time taken to search an element is <img alt=\"\\Theta (h) \" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"27\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-3c01131de6840f4917c9f91830102e1f_l3.png\" style=\"vertical-align: -7px;\" title=\"Rendered by QuickLaTeX.com\" width=\"53\"/> where h is the height of Binary Search Tree (BST).  The growth of height of a balanced BST is logerthimic in terms of number of nodes. So the worst case time to search an element would be <img alt=\"\\Theta (Log(n*2^n)) \" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"27\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-c034b69eb14de8ddfc4e15b12fe681a4_l3.png\" style=\"vertical-align: -7px;\" title=\"Rendered by QuickLaTeX.com\" width=\"170\"/> which is <img alt=\"\\Theta (Log(n) + Log(2^n)) \" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"27\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-e67615ae5d6574ec8aa05c99a100e773_l3.png\" style=\"vertical-align: -7px;\" title=\"Rendered by QuickLaTeX.com\" width=\"242\"/> Which is <img alt=\"\\Theta (Log(n) + n) \" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"27\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-e01bc73883a2f1af87784675b93daf8f_l3.png\" style=\"vertical-align: -7px;\" title=\"Rendered by QuickLaTeX.com\" width=\"167\"/> which can be written as <img alt=\"\\Theta (n) \" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"27\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-b211015f3dbe88830e22a6bacd8486ee_l3.png\" style=\"vertical-align: -7px;\" title=\"Rendered by QuickLaTeX.com\" width=\"54\"/>. </div>",
        "keyword": "Balanced Binary Search Trees"
    },
    {
        "question": "What is the maximum height of any AVL-tree with 7 nodes? Assume that the height of a tree with a single node is 0.",
        "answer": "None",
        "correct": "None",
        "explain": "None",
        "keyword": "Balanced Binary Search Trees"
    },
    {
        "question": "What is the worst case possible height of AVL tree?",
        "answer": [
            "2Logn   \r\nAssume base of log is 2",
            "1.44log n \r\nAssume base of log is 2",
            "Depends upon implementation",
            "Theta(n)"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> See <a href=\"http://lcm.csa.iisc.ernet.in/dsa/node112.html\" target=\"_blank\">http://lcm.csa.iisc.ernet.in/dsa/node112.html</a></div>",
        "keyword": "Balanced Binary Search Trees"
    },
    {
        "question": "Which of the following is AVL Tree?\r\n\r\n\r\n\r\nA\r\n        100\r\n     /      \r\n    50       200\r\n   /           \r\n 10            300\r\n\r\n\r\nB\r\n           100\r\n       /       \r\n     50        200\r\n    /        /     \r\n  10       150     300\r\n /\r\n5\r\n\r\n\r\nC\r\n            100\r\n       /          \r\n     50            200\r\n    /            /     \r\n  10    60       150     300\r\n /                         \r\n5                   180       400\r\n",
        "answer": [
            "Only A",
            "A and C",
            "A, B and C",
            "Only B"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> A Binary Search Tree is AVL if balance factor of every node is either -1 or 0 or 1.  Balance factor of a node X is [(height of X-&gt;left) - (height of X-&gt;right)].\r\n\r\nIn Tree B, the node with value 50 has balance factor 2.  That is why B is not an AVL tree.</div>",
        "keyword": "Balanced Binary Search Trees"
    },
    {
        "question": "Consider the following AVL tree. \r\n\r\n\r\n         60\r\n      /       \r\n    20      100\r\n           /   \r\n         80    120     \r\n\r\n\r\nWhich of the following is updated AVL tree after insertion of 70\r\n\r\n\r\nA\r\n        70\r\n      /      \r\n    60      100\r\n   /       /    \r\n 20       80    120 \r\n\r\nB\r\n        100\r\n      /      \r\n    60      120\r\n   /       /  \r\n 20   70   80   \r\n\r\n\r\nC\r\n        80\r\n      /      \r\n    60      100\r\n   /         \r\n 20   70      120\r\n\r\nD\r\n        80\r\n      /      \r\n    60      100\r\n   /       /   \r\n 20      70    120  ",
        "answer": [
            "A",
            "B",
            "C",
            "D"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Refer following for steps used in AVL insertion.\r\n\r\n<a href=\"http://www.geeksforgeeks.org/avl-tree-set-1-insertion/\" target=\"_blank\">AVL Tree | Set 1 (Insertion)</a>\n<pre>\r\nAfter insertion of 70, tree becomes following\r\n         60\r\n      /     \\  \r\n    20      100\r\n           /   \\\r\n         80    120     \r\n        /\r\n       70\r\n</pre>\r\nWe start from 50 and travel up.  We keep travelling up till we find an unbalanced node.  In above case, we reach the node 60 and see 60 got unbalanced after insertion and this is <a href=\"http://www.geeksforgeeks.org/avl-tree-set-1-insertion/\" target=\"_blank\">Right Left Case</a>.  So we need to apply two rotations\r\n<pre>\r\n         60                               60                            80\r\n      /     \\       Right Rotate(100)  /      \\     Left Rotate(60)   /    \\\r\n    20      100    -----------------&gt; 20        80 ---------------&gt; 60      100 \r\n           /   \\                              /   \\                /  \\        \\\r\n         80    120                          70     100            20   70       120  \r\n        /                                            \\    \r\n      70                                             120 \r\n</pre></div>",
        "keyword": "Balanced Binary Search Trees"
    },
    {
        "question": "Which of the following is a self-adjusting or self-balancing Binary Search Tree",
        "answer": [
            "Splay Tree",
            "AVL Tree",
            "Red Black Tree",
            "All of the above"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> See <a href=\"http://www.geeksforgeeks.org/splay-tree-set-1-insert/\">Splay Tree</a>, <a href=\"http://www.geeksforgeeks.org/avl-tree-set-1-insertion/\">AVL Tree</a> and <a href=\"http://www.geeksforgeeks.org/red-black-tree-set-2-insert/\">Red Black Tree</a></div>",
        "keyword": "Balanced Binary Search Trees"
    },
    {
        "question": "Consider the following left-rotate and right-rotate functions commonly used in self-adjusting BSTs\r\n\r\n\r\nT1, T2 and T3 are subtrees of the tree rooted with y (on left side) \r\nor x (on right side)           \r\n                y                               x\r\n               /      Right Rotation          /  \r\n              x   T3   – - – - – - – >        T1   y \r\n             /        < - - - - - - -            / \r\n            T1  T2     Left Rotation            T2  T3\r\n\r\n\r\nWhich of the following is tightest upper bound for left-rotate and right-rotate operations.\r\n",
        "answer": [
            "O(1)",
            "O(Logn)",
            "O(LogLogn)",
            "O(n)"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> The rotation operations (left and right rotate) take constant time as only few pointers are being changed there.  Following are C implementations of left-rotate and right-rotate\r\n\r\n[sourcecode language=\"C\"]\r\n// A utility function to right rotate subtree rooted with y\r\n// See the diagram given above.\r\nstruct node *rightRotate(struct node *y)\r\n{\r\n    struct node *x = y-&gt;left;\r\n    struct node *T2 = x-&gt;right;\r\n \r\n    // Perform rotation\r\n    x-&gt;right = y;\r\n    y-&gt;left = T2;\r\n \r\n    // Update heights\r\n    y-&gt;height = max(height(y-&gt;left), height(y-&gt;right))+1;\r\n    x-&gt;height = max(height(x-&gt;left), height(x-&gt;right))+1;\r\n \r\n    // Return new root\r\n    return x;\r\n}\r\n \r\n// A utility function to left rotate subtree rooted with x\r\n// See the diagram given above.\r\nstruct node *leftRotate(struct node *x)\r\n{\r\n    struct node *y = x-&gt;right;\r\n    struct node *T2 = y-&gt;left;\r\n \r\n    // Perform rotation\r\n    y-&gt;left = x;\r\n    x-&gt;right = T2;\r\n \r\n    //  Update heights\r\n    x-&gt;height = max(height(x-&gt;left), height(x-&gt;right))+1;\r\n    y-&gt;height = max(height(y-&gt;left), height(y-&gt;right))+1;\r\n \r\n    // Return new root\r\n    return y;\r\n}\r\n[/sourcecode]</div>",
        "keyword": "Balanced Binary Search Trees"
    },
    {
        "question": "Which of the following is true",
        "answer": [
            "The AVL trees are more balanced compared to Red Black Trees, but they may cause more rotations during insertion and deletion. ",
            "Heights of AVL and Red-Black trees are generally same, but AVL Trees may cause more rotations during insertion and deletion. ",
            "Red Black trees are more balanced compared to AVL Trees, but may cause more rotations during insertion and deletion. ",
            "Heights of AVL and Red-Black trees are generally same, but Red Black rees may cause more rotations during insertion and deletion. "
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> <a href=\"http://www.geeksforgeeks.org/red-black-tree-set-1-introduction-2/\">Red Black Tree</a> with n nodes has height &lt;= 2Log2(n+1)\r\n\r\n<a href=\"http://www.geeksforgeeks.org/avl-tree-set-1-insertion/\">AVL Tree</a> with n nodes has height less than Log<sub>φ</sub>(√5(n+2)) - 2.\r\n\r\nTherefore, the AVL trees are more balanced compared to Red Black Trees, but they may cause more rotations during insertion and deletion. So if your application involves many frequent insertions and deletions, then Red Black trees should be preferred. And if the insertions and deletions are less frequent and search is more frequent operation, then AVL tree should be preferred over Red Black Tree.</div>",
        "keyword": "Balanced Binary Search Trees"
    },
    {
        "question": "Which of the following is true about Red Black Trees?",
        "answer": [
            "The path from the root to the furthest leaf is no more than twice as long as the path from the root to the nearest leaf",
            "At least one children of every black node is red",
            "Root may be red",
            "A leaf node may be red"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> See <a href=\"http://en.wikipedia.org/wiki/Red%E2%80%93black_tree\" target=\"_blank\">http://en.wikipedia.org/wiki/Red%E2%80%93black_tree</a></div>",
        "keyword": "Balanced Binary Search Trees"
    },
    {
        "question": "Which of the following is true about AVL and Red Black Trees?",
        "answer": [
            "In AVL tree insert() operation, we first traverse from root to newly inserted node and then from newly inserted node to root.  While in Red Black tree insert(), we only traverse once from root to newly inserted node.",
            "In both AVL and Red Black insert operations, we traverse only once from root to newly inserted node,",
            "In both AVL and Red Black insert operations, we traverse twiceL first traverse root to newly inserted node and then from newly inserted node to root.",
            "None of the above"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Refer <a href=\"http://www.geeksforgeeks.org/red-black-tree-set-2-insert/\" target=\"_blank\">Red Black Tree Insertion</a> and <a href=\"http://www.geeksforgeeks.org/avl-tree-set-1-insertion/\">AVL Tree Insertion</a></div>",
        "keyword": "Balanced Binary Search Trees"
    },
    {
        "question": "What is the worst case possible height of Red-Black tree? \r\n\r\nAssume base of Log as 2 in all options",
        "answer": [
            "2Log(n+1)",
            "1.44 Logn",
            "4Logn",
            "None of the above"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Refer <a href=\"http://en.wikipedia.org/wiki/Red-black_tree#Proof_of_asymptotic_bounds\" target=\"_blank\">Wiki Page of Red-Black Tree</a></div>",
        "keyword": "Balanced Binary Search Trees"
    },
    {
        "question": "Is the following statement valid?\r\n\r\nA Red-Black Tree which is also a perfect Binary Tree can have all black nodes",
        "answer": [
            "Yes",
            "No"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> <p>A perfect BST with all black nodes doesn't violate any of the <a href=\"http://www.geeksforgeeks.org/red-black-tree-set-1-introduction-2/\" target=\"_blank\">Red-Black tree properties.</a></p></div>",
        "keyword": "Balanced Binary Search Trees"
    },
    {
        "question": "Which of the following operations are used by Red-Black trees to maintain balance during insertion/deletion?\r\n\r\na) Recoloring of nodes\r\nb) Rotation (Left and Right)",
        "answer": [
            "Only a",
            "Only b",
            "Both a and b",
            "Neither a nor b"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> <p>Both recoloring and rotation operations are used during insertion and deletion.</p></div>",
        "keyword": "Balanced Binary Search Trees"
    },
    {
        "question": "A program takes as input a balanced binary search tree with n leaf nodes and computes the value of a function g(x) for each node x. If the cost of computing g(x) is min{no. of leaf-nodes in left-subtree of x, no. of leaf-nodes in right-subtree of x} then the worst-case time complexity of the program is",
        "answer": [
            "Θ(n)",
            "Θ(nLogn)",
            "Θ(n2)",
            "Θ(n2log n)"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>\r\nThe recurrence relation for the recursive function is\r\nT(N) = 2 * T(N/2) + n/2\r\nWhere N is the total no. of nodes in the tree.\r\nT(N) = 2 * (2*T(N/2) + n/2) + n/2\r\n     = 4 * T(N/2) + 3(n/2)\r\nSolve this till T(1) i.e. till we reach the root.\r\nT(N) = c * T(N / 2^i) + (2*i - 1) * (n/2)\r\nWhere i = lg(N)\r\n= lg((2n - 1) / 2)\r\nO(c * T(N / 2^i) + (2*i - 1) * (n/2)) reduces to\r\nO((2*i - 1) * (n/2))\r\nO((2*( lg((2n - 1) / 2)) - 1) * (n/2)) ...sub the value of i.\r\nO(n * ln(n)) </pre>\r\n\r\nSource: <a href=\"http://www.nid.iitkgp.ernet.in/DSamanta/courses/IT60101_2/Archives/Assignment-%20IC%20Binary%20Trees%20Solutions.pdf\" target=\"_blank\">http://www.nid.iitkgp.ernet.in/DSamanta/courses/IT60101_2/Archives/Assignment-%20IC%20Binary%20Trees%20Solutions.pdf</a></div>",
        "keyword": "Balanced Binary Search Trees"
    },
    {
        "question": "Which of the following is TRUE?\r\n\r\n ",
        "answer": [
            "The cost of searching an AVL tree is θ (log n) but that of a binary search tree is O(n)",
            "The cost of searching an AVL tree is θ (log n) but that of a complete binary tree is θ (n log n)",
            "The cost of searching a binary search tree is O (log n ) but that of an AVL tree is θ(n)",
            "The cost of searching an AVL tree is θ (n log n) but that of a binary search tree is O(n)"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> AVL tree is a balanced tree.<br/>\r\nAVL tree's time complexity of searching = θ(logn)\r\n<br/>But a binary search tree, may be skewed tree, so in worst case BST searching time = θ(n)</div>",
        "keyword": "Balanced Binary Search Trees"
    },
    {
        "question": "Given two Balanced binary search trees, B1 having n elements and B2 having m elements, what is the time complexity of the best known algorithm to merge these trees to form another balanced binary tree containing m+n elements ? \r\n",
        "answer": [
            "O(m+n)    ",
            "O(mlogn)\r\n",
            "O(nlogm)\r\n",
            "O(m2 + n2)     \r\n"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> \r\nO(m+n) as we can first perform inorder on both the trees and store them in two separate arrays. Now we have two sorted sequences and we can merge them in O(m+n) using  standard merge algorithm and on the final sorted array we can use  the binary search to create the tree using Recursion. Recursively adding middle element at the root and repeating the same process for left and right subarrays.\r\n</div>",
        "keyword": "Balanced Binary Search Trees"
    },
    {
        "question": "Suppose the numbers 7, 5, 1, 8, 3, 6, 0, 9, 4, 2 are inserted in that order into an initially empty binary search tree. The binary search tree uses the reversal ordering on natural numbers i.e. 9 is assumed to be smallest and 0 is assumed to be largest. The in-order traversal of the resultant binary search tree is",
        "answer": [
            "9, 8, 6, 4, 2, 3, 0, 1, 5, 7",
            "0, 1, 2, 3, 4, 5, 6, 7, 8, 9",
            "0, 2, 4, 3, 1, 6, 5, 9, 8, 7",
            "9, 8, 7, 6, 5, 4, 3, 2, 1, 0"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> Inorder traversal of a binary search tree always produces the keys in increasing order. In this question Reverse ordering of natural numbers are used i.e. 9 is assumed to be the smallest and 0 to be the largest. So the sequence in increasing order will be 9, 8, 7, 6, 5, 4, 3, 2, 1, 0.\r\nSo, option (D) is correct.</div>",
        "keyword": "Balanced Binary Search Trees"
    },
    {
        "question": "The recurrence relation that arises in relation with the complexity of binary search is:",
        "answer": [
            "T(n) = 2T(n/ 2) + k , where k is constant",
            "T(n) = T(n / 2) + k , where k is constant",
            "T(n) = T(n / 2) + log n",
            "T(n) = T(n / 2) + n"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Binary Search is a linear searching algorithm and takes  O(log n) when array is sorted. Refer: <a href=\"https://www.geeksforgeeks.org/binary-search/\" rel=\"noopener\" target=\"_blank\">Binary Search</a>\r\nT(n) = T(n / 2) + k , where k is constant produces a complexity of O(log n) </div>",
        "keyword": "Balanced Binary Search Trees"
    },
    {
        "question": "A data structure is required for storing a set of integers such that each of the following operations can be done in O(log n) time, where n is the number of elements in the set.\r\nI. Deletion of the smallest element\r\nII. Insertion of an element if it is not already present in the set\r\n\r\nWhich of the following data structures can be used for this purpose?\r\n",
        "answer": [
            "A heap can be used but not a balanced binary search tree",
            "A balanced binary search tree can be used but not a heap",
            "Both balanced binary search tree and heap can be used",
            "Neither balanced search tree nor heap can be used"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> A self-balancing binary search tree containing n items allows the lookup, insertion, and removal of an item in O(log n) worst-case time. Since it’s a self balancing BST, we can easily find out minimum element in O(logn) time which is always the leftmost element.\r\n\r\nSince Heap is a balanced binary tree (or almost complete binary tree), insertion complexity for heap is O(logn). Also complexity to get minimum in a min heap is O(logn) because removal of root node causes a call to heapify (after removing the first element from the array) to maintain the heap tree property. But a heap cannot be used for the above purpose as the question says – insert an element if it is not already present. For a heap, we cannot find out in O(logn) if an element is present or not.\r\n\r\nSo, option (B) is correct.</div>",
        "keyword": "Balanced Binary Search Trees"
    },
    {
        "question": "What is the worst case time complexity of inserting n2 elements into an AVL-tree with n elements initially ?",
        "answer": [
            "Θ(n4)",
            "Θ(n2)",
            "Θ(n2 log n)",
            "Θ(n3)"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Since <a href=\"https://www.geeksforgeeks.org/avl-tree-set-1-insertion/\" rel=\"noopener\" target=\"_blank\">AVL tree</a> is balanced tree, the height is O(log n). So, time complexity to insert an element in an AVL tree is O(log n) in worst case. \r\n\r\n<b>Note:</b>\n<pre>Every insertion of element:\r\nFinding place to insert = O(log n)\r\nIf property not satisfied (after insertion) do rotation = O(log n)\r\n\r\nSo, an AVL insertion take = O(log n) + O(log n) = O(log n) in worst case. </pre>\r\n\r\nNow, given n<sup>2</sup> element need to insert into given AVL tree, therefore, total time complexity will be O(n<sup>2</sup> log n).\r\n\r\n<b>Alternative method:</b> Time complexity in worst case,\r\n<pre>1st insertion time complexity = O(log n)\r\n2nd insertion time complexity = O(log(n+1))\r\n.\r\n.\r\n.\r\nn<sup>2</sup>th insertion time complexity = O(log(n + n<sup>2</sup>)) </pre>\r\nSo, total time complexity will be,\r\n<pre>= O(log n) +  O(log n+1)) + .... +  O(log(n + n<sup>2</sup>))\r\n= O(log n*(n+1)*(n+2)*...(n+n<sup>2</sup>))\r\n= O(log n<sup>n<sup>2</sup></sup>)\r\n= O(n<sup>2</sup> log n) </pre>\r\n\r\nOption (C) is correct.\r\n\r\n\r\n<iframe allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen=\"\" frameborder=\"0\" height=\"315\" src=\"https://www.youtube.com/embed/fP8QED8d6ws?start=2708\" title=\"YouTube video player\" width=\"560\"></iframe></div>",
        "keyword": "Balanced Binary Search Trees"
    },
    {
        "question": "Which of the following is an advantage of adjacency list representation over adjacency matrix representation of a graph?",
        "answer": [
            "In adjacency list representation, space is saved for sparse graphs.",
            "DFS and BSF can be done in O(V + E) time for adjacency list representation. These operations take O(V^2) time in adjacency matrix representation. Here is V and E are number of vertices and edges respectively.",
            "Adding a vertex in adjacency list representation is easier than adjacency matrix representation.",
            "All of the above"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> See <a href=\"http://www.geeksforgeeks.org/graph-and-its-representations/\">http://www.geeksforgeeks.org/graph-and-its-representations/</a></div>",
        "keyword": "Graph"
    },
    {
        "question": "The degree sequence of a simple graph is the sequence of the degrees of the nodes in the graph in decreasing order. Which of the following sequences can not be the degree sequence of any graph?\r\n\nI. 7, 6, 5, 4, 4, 3, 2, 1\r\nII. 6, 6, 6, 6, 3, 3, 2, 2\r\nIII. 7, 6, 6, 4, 4, 3, 2, 2\r\nIV. 8, 7, 7, 6, 4, 2, 1, 1 \n",
        "answer": [
            "I and II",
            "III and IV",
            "IV only",
            " II and IV"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> See Question 3 of <a href=\"http://www.geeksforgeeks.org/data-structures-and-algorithms-set-25/\">http://www.geeksforgeeks.org/data-structures-and-algorithms-set-25/</a> for explanation.</div>",
        "keyword": "Graph"
    },
    {
        "question": "The time complexity of computing the transitive closure of a binary relation on a set of n elements is known to be:",
        "answer": [
            "O(n)",
            "O(nLogn)",
            "O(n ^ (3/2))",
            "O(n^3)"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> See question 3 of<a href=\"http://www.geeksforgeeks.org/data-structures-and-algorithms-set-22/\"> http://www.geeksforgeeks.org/data-structures-and-algorithms-set-22/</a></div>",
        "keyword": "Graph"
    },
    {
        "question": "The most efficient algorithm for finding the number of connected components in an undirected graph on n vertices and m edges has time complexity.",
        "answer": "None",
        "correct": "None",
        "explain": "None",
        "keyword": "Graph"
    },
    {
        "question": "Consider an undirected unweighted graph G. Let a breadth-first traversal of G be done starting from a node r. Let d(r, u) and d(r, v) be the lengths of the shortest paths from r to u and v respectively, in G. lf u is visited before v during the breadth-first traversal, which of the following statements is correct? (GATE CS 2001) ",
        "answer": [
            "d(r, u) < d (r, v) ",
            "d(r, u) > d(r, v) ",
            "d(r, u) <= d (r, v) ",
            "None of the above "
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> d(r, u) and d(r, v) will be equal when u and v are at same level, otherwise d(r, u) will be less than d(r, v)</div>",
        "keyword": "Graph"
    },
    {
        "question": "How many undirected graphs (not necessarily connected) can be constructed out of a given set V= {V 1, V 2,â€¦V n} of n vertices ? ",
        "answer": [
            "n(n-l)/2 ",
            "2^n ",
            "n! ",
            "2^(n(n-1)/2) \r\n"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> In an undirected graph, there can be maximum n(n-1)/2 edges. We can choose to have (or not have) any of the n(n-1)/2 edges.  So, total number of undirected graphs with n vertices is 2^(n(n-1)/2). </div>",
        "keyword": "Graph"
    },
    {
        "question": "Which of the following statements is/are TRUE for an undirected graph?\r\nP: Number of odd degree vertices is even\r\nQ: Sum of degrees of all vertices is even",
        "answer": [
            "P Only",
            "Q Only",
            "Both P and Q",
            "Neither P nor Q"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> P is true for undirected graph as adding an edge always increases degree of two vertices by 1.\r\n\r\nQ is true: If we consider sum of degrees and subtract all even degrees, we get an even number because every edge increases the sum of degrees by 2. So total number of odd degree vertices must be even.</div>",
        "keyword": "Graph"
    },
    {
        "question": "Consider an undirected random graph of eight vertices. The probability that there is an edge between a pair of vertices is 1/2. What is the expected number of unordered cycles of length three?",
        "answer": [
            "1/8",
            "1",
            "7",
            "8"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> A cycle of length 3 can be formed with 3 vertices. There can be total 8C3 ways to pick 3 vertices from 8. The probability that there is an edge between two vertices is 1/2. So expected number of unordered cycles of length 3 = (8C3)*(1/2)^3 = 7</div>",
        "keyword": "Graph"
    },
    {
        "question": "Given an undirected graph G with V vertices and E edges, the sum of the degrees of all vertices is",
        "answer": [
            "E",
            "2E",
            "V",
            "2V"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Since the given graph is undirected, every edge contributes as 2 to sum of degrees.\r\n\r\nSo the sum of degrees is 2E.</div>",
        "keyword": "Graph"
    },
    {
        "question": "How many undirected graphs (not necessarily connected) can be constructed out of a given set V = {v1, v2, ... vn} of n vertices?",
        "answer": [
            "n(n-1)/2",
            "2n",
            "n!",
            "2n(n-1)/2"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> There are total n*(n-1)/2 possible edges.  For every edge, there are to possible options, either we pick it or don't pick.   So total number of possible graphs is 2<sup>n(n-1)/2</sup>.</div>",
        "keyword": "Graph"
    },
    {
        "question": "What is the maximum number of edges in an acyclic undirected graph with n vertices?",
        "answer": [
            "n-1",
            "n",
            "n + 1 ",
            "2n-1"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> n * (n - 1) / 2 when cyclic. But acyclic graph with the maximum number of edges is actually a <b>spanning tree</b> and therefore, correct answer is n-1 edges.</div>",
        "keyword": "Graph"
    },
    {
        "question": "Let G be a weighted undirected graph and e be an edge with maximum weight in G. Suppose there is a minimum weight spanning tree in G containing the edge e. Which of the following statements is always TRUE?\r\n\r\n ",
        "answer": [
            "There exists a cutset in G having all edges of maximum weight.",
            "There exists a cycle in G having all edges of maximum weight",
            "Edge e cannot be contained in a cycle.",
            "All edges in G have the same weight"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> <strong>Background : </strong> Given a connected and undirected graph, a <a href=\"http://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/\">spanning tree</a> of that graph is a subgraph that is a tree and connects all the vertices together. \r\n\r\n<ol><li> A spanning tree has exactly V - 1 edges.</li>\n<li> A single graph can have many different spanning trees. A minimum spanning tree (MST) or minimum weight spanning tree for a weighted, connected and undirected graph is a spanning tree with weight less than or equal to the weight of every other spanning tree. The weight of a spanning tree is the sum of weights given to each edge of the spanning tree.</li>\n<li> There can be more that one possible spanning trees of a graph. For example, the graph in <a href=\"http://quiz.geeksforgeeks.org/gate-gate-cs-2014-set-2-question-62/\">this question</a> has 6 possible spanning trees.</li>\n<li> MST has lightest edge of every cutset. Remember <a href=\"http://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-minimum-spanning-tree-mst-2/\">Prim's algorithm</a> which basically picks the lightest edge from every cutset. </li></ol>\n<strong>Choices of this question : </strong>\n<em><strong>a) There exists a cutset in G having all edges of maximum weight </strong></em> : This is correct. If there is a heaviest edge in MST, then there exist a cut with all edges with weight equal to heavies edge.  See point 4 discussed in above background.\r\n<a href=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/11/MST.png\"><img alt=\"mst\" class=\"aligncenter size-full wp-image-28336\" height=\"392\" src=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/11/MST.png\" width=\"644\"/></a>\n<strong>b) There exists a cycle in G having all edges of maximum weight : </strong> Not always TRUE. The cutset of heaviest edge may contain only one edge.  In fact there may be overall one edge of heavies weight which is part of MST (Consider a graph with two components which are connected by only one edge and this edge is the heavies)\r\n\r\n<strong>c) Edge e cannot be contained in a cycle.</strong> Not Always True. The curset may form cycle with other edges.\r\n\r\n<strong>d) All edges in G have the same weight</strong> Not always True. As discussed in option b, there can be only one edge of heaviest weight.</div>",
        "keyword": "Graph"
    },
    {
        "question": "\nQ84 Part_B\n\nA sink in a directed graph is a vertex i such that there is an edge from every vertex j ≠ i to i and there is no edge from i to any other vertex. A directed graph G with n vertices is represented by its adjacency matrix A, where A[i] [j] = 1 if there is an edge directed from vertex i to j and 0 otherwise. The following algorithm determines whether there is a sink in the graph G.\n\r\ni = 0\r\ndo {\r\n    j = i + 1;\r\n    while ((j < n) && E1) j++;\r\n    if (j < n) E2;\r\n} while (j < n);\r\n\r\nflag = 1;\r\nfor (j = 0; j < n; j++)\r\n    if ((j! = i) && E3)\r\n        flag = 0;\r\n\r\nif (flag)\r\n    printf(\"Sink exists\");\r\nelse\r\n    printf(\"Sink does not exist\");\r\n\n\r\nChoose the correct expressions for E3\r\n\r\n ",
        "answer": [
            "(A[i][j] && !A[j][i])",
            "(!A[i][j] && A[j][i])",
            "(!A[i][j] | |  A[j][i])",
            "(A[i][j] | | !A[j][i])\r\n"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> <a href=\"http://quiz.geeksforgeeks.org/gate-gate-it-2005-question-88/\"><strong>Below explanation is for Previous Part of this question:</strong></a>\r\nFor vertex i to be a sink, there should be no edge from i to any other vertex.\r\n\r\n<a href=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/11/Sink.png\"><img alt=\"sink\" class=\"aligncenter size-full wp-image-28329\" height=\"173\" src=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/11/Sink.png\" width=\"292\"/></a>\r\n\r\nAccording the input given in question,\r\n<pre>\r\nA[i][j] = 1 means there is an edge from vertex i to j.\r\nA[i][j] = 0 means there is no edge from i to j\r\n</pre>\n<strong>For a node to i to be sink,</strong> <pre>\r\nA[i][j] should be 0 for all j \r\nA[j][i] should be 1 for all j.</pre>\r\n\r\n\r\nThe above pseudo code checks every vertex i for sink, starting from i = 0.  It basically checks every vertex j after i for being a sink.  The trick in pseudo code is, it doesn't check for j smaller than i.  The i picked by this loop may not be sink. It basically makes sure that we don't ignore a potential sink.  The check whether i is actually a sink or not is done later after do while loop.\r\n\r\nVertex i is a potential sink while A[i][j] is zero \r\nThus, <strong>E1 : !A[i][j] </strong>\r\n\r\nIf the above condition is false, then i is not a sink. All j &lt; i can also not be a sink because there is no edge from i to j.\r\nNow, the next potential sink can be j. \r\nSo, <strong>E2 : i = j</strong>\n<strong>Explanation for this question</strong>\r\nThe following pseudo code basically checks if the potential sink picked by the code above is actually a sink or not.\r\n<pre>\r\nflag = 1;\r\nfor (j = 0; j &lt; n; j++)\r\n    if ((j! = i) &amp;&amp; E3)\r\n        flag = 0;\r\n</pre>\n<strong>flag equals to 0 means i is not a sink. The code sets the flag 0 as soon as it finds out that i is not a sink.</strong>\n<pre>\r\nA node i is <strong>not</strong> a sink if either of the following \r\ntwo conditions become true for any j not equal to i.\r\nA[i][j] is 1 for any j \r\nOR\r\nA[j][i] is 0 for any j</pre>\n<strong>E3 : (A[i][j] | | !A[j][i])</strong>\r\n\r\nTherefore option D is correct\r\n</div>",
        "keyword": "Graph"
    },
    {
        "question": "Q85  Part_A\r\n\r\nConsider a simple graph with unit edge costs. Each node in the graph represents a router. Each node maintains a routing table indicating the next hop router to be used to relay a packet to its destination and the cost of the path to the destination through that router. Initially, the routing table is empty. The routing table is synchronously updated as follows. In each updation interval, three tasks are performed.\r\n\nA node determines whether its neighbours in the graph are accessible. If so, it sets the tentative cost to each accessible neighbour as 1. Otherwise, the cost is set to ∞.\nFrom each accessible neighbour, it gets the costs to relay to other nodes via that neighbour (as the next hop).\nEach node updates its routing table based on the information received in the previous two steps by choosing the minimum cost.\n\n\nFor the graph given above, possible routing tables for various nodes after they have stabilized, are shown in the following options. Identify the correct table.\n\n\n\n\n\n1)\nTable for node A\r\n\n\n\n A\n -\n -\n\n\n B\n B\n 1\n\n\n C\n C\n 1\n\n\n D\n B\n 3\n\n\n E\n C\n 3\n\n\n F\n C\n 4\n\n\n\n\n\n\n2)\nTable for node C\r\n\n\n\n A\n A\n 1\n\n\n B\n B\n 1\n\n\n C\n -\n -\n\n\n D\n D\n 1\n\n\n E\n E\n 1\n\n\n F\n E\n 3\n\n\n\n\n\n\n\n3)\nTable for node B\r\n\n\n\n A\n A\n 1\n\n\n B\n -\n -\n\n\n C\n C\n 1\n\n\n D\n D\n 1\n\n\n E\n C\n 2\n\n\n F\n D\n 2\n\n\n\n\n\n\n4)\nTable for node D\r\n\n\n\n A\n B\n 3\n\n\n B\n B\n 1\n\n\n C\n C\n 1\n\n\n D\n -\n-\n\n\n E\n E\n 1\n\n\n F\n F\n 1\n\n\n\n\n\n\n\n",
        "answer": [
            "A",
            "B",
            "C",
            "D"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> <a href=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/12/graph_05_90.png\"><img alt=\"graph_05_90\" class=\"alignnone size-full wp-image-28574\" height=\"775\" src=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/12/graph_05_90.png\" width=\"805\"/></a> <a href=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/12/graph_05_90_1.png\"><img alt=\"graph_05_90_1\" class=\"alignnone size-full wp-image-28575\" height=\"913\" src=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/12/graph_05_90_1.png\" width=\"833\"/></a>\r\n\r\n \r\n\r\nThis solution is contributed by Sandeep Pandey.</div>",
        "keyword": "Graph"
    },
    {
        "question": "Q85 Part_B\r\n\r\nConsider a simple graph with unit edge costs. Each node in the graph represents a router. Each node maintains a routing table indicating the next hop router to be used to relay a packet to its destination and the cost of the path to the destination through that router. Initially, the routing table is empty. The routing table is synchronously updated as follows. In each updation interval, three tasks are performed.\r\n\nA node determines whether its neighbours in the graph are accessible. If so, it sets the tentative cost to each accessible neighbour as 1. Otherwise, the cost is set to ∞.\nFrom each accessible neighbour, it gets the costs to relay to other nodes via that neighbour (as the next hop).\nEach node updates its routing table based on the information received in the previous two steps by choosing the minimum cost.\n\n\nFor the graph given above, possible routing tables for various nodes after they have stabilized, are shown in the following options. Identify the correct table.\n\n\n\n\n\n1)\nTable for node A\r\n\n\n\n A\n -\n -\n\n\n B\n B\n 1\n\n\n C\n C\n 1\n\n\n D\n B\n 3\n\n\n E\n C\n 3\n\n\n F\n C\n 4\n\n\n\n\n\n\n2)\nTable for node C\r\n\n\n\n A\n A\n 1\n\n\n B\n B\n 1\n\n\n C\n -\n -\n\n\n D\n D\n 1\n\n\n E\n E\n 1\n\n\n F\n E\n 3\n\n\n\n\n\n\n\n3)\nTable for node B\r\n\n\n\n A\n A\n 1\n\n\n B\n -\n -\n\n\n C\n C\n 1\n\n\n D\n D\n 1\n\n\n E\n C\n 2\n\n\n F\n D\n 2\n\n\n\n\n\n\n4)\nTable for node D\r\n\n\n\n A\n B\n 3\n\n\n B\n B\n 1\n\n\n C\n C\n 1\n\n\n D\n -\n-\n\n\n E\n E\n 1\n\n\n F\n F\n 1\n\n\n\n\n\n\n\r\nContinuing from the earlier problem, suppose at some time t, when the costs have stabilized, node A goes down. The cost from node F to node A at time (t + 100) is\r\n\r\n \r\n\r\n",
        "answer": [
            ">100 but finite",
            "∞",
            "3",
            ">3 and ≤100"
        ],
        "correct": "A",
        "explain": "None",
        "keyword": "Graph"
    },
    {
        "question": "The cyclomatic complexity of the flow graph of a program provides\r\n\r\n ",
        "answer": [
            "an upper bound for the number of tests that must be conducted to ensure that all statements have been executed at most once",
            "a lower bound for the number of tests that must be conducted to ensure that all statements have been executed at most once",
            "an upper bound for the number of tests that must be conducted to ensure that all statements have been executed at least once",
            "a lower bound for the number of tests that must be conducted to ensure that all statements have been executed at least once"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Option (C) is correct, because the <a href=\"https://www.geeksforgeeks.org/cyclomatic-complexity/\" rel=\"noopener\" target=\"_blank\">cyclomatic complexity</a> of the flow graph of a program provides an upper bound for the number of tests that must be conducted to ensure that all statements have been executed at least once.</div>",
        "keyword": "Graph"
    },
    {
        "question": "What is the largest integer m such that every simple connected graph with n vertices and n edges contains at least m different spanning trees?",
        "answer": [
            "1",
            "2",
            "3",
            "n"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> A graph is connected iff all nodes can be traversed from each node. For a graph with n nodes, there will be n-1 minimum number of edges. <br/>\r\nGiven that there are n edges, that means a cycle is there in the graph.<br/>\r\nThe simplex graph with these conditions may be:<br/>\n<img alt=\"\" src=\"https://cdncontribute.geeksforgeeks.org/wp-content/uploads/gateit24.png\"/><br/>\r\n\r\n\r\nNow we can make a different spanning tree by removing one edge from the cycle, one at a time.<br/>\r\nMinimum cycle length can be 3, So, there must be atleast 3 spanning trees in any such Graph. \r\n</div>",
        "keyword": "Graph"
    },
    {
        "question": "For the undirected, weighted graph given below, which of the following sequences of edges represents a correct execution of Prim's algorithm to construct a Minimum Span­ning Tree?",
        "answer": [
            "(a, b), (d, f), (f, c), (g, i), (d, a), (g, h), (c, e), (f, h)",
            "(c, e), (c, f), (f, d), (d, a), (a, b), (g, h), (h, f), (g, i)",
            "(d, f), (f, c), (d, a), (a, b), (c, e), (f, h), (g, h), (g, i)",
            "(h, g), (g, i), (h, f), (f, c), (f, d), (d, a), (a, b), (c, e)"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> In prims algorithm we start with any node and keep on exploring minimum cost neighbors of nodes already covered.</div>",
        "keyword": "Graph"
    },
    {
        "question": "Consider a directed graph with n vertices and m edges such that all edges have same edge weights. Find the complexity of the best known algorithm to compute the minimum spanning tree of the graph?\r\n",
        "answer": [
            "O(m+n)",
            "O(m logn)    ",
            " O(mn)",
            "O(n logm)\r\n"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> It’s a special case in which all edge weights are equal, so dfs would work and resultant depth first tree would be the spanning tree. So the answer would be O(m+n).\r\n</div>",
        "keyword": "Graph"
    },
    {
        "question": "You are given a graph containing n vertices and m edges and given that the graph doesn’t contain cycle of odd length. Time Complexity of the best  known algorithm to find out whether the graph is bipartite or not is ?\r\n\r\n",
        "answer": [
            "O(m+n)",
            "O(1)    ",
            "O(mn) ",
            "O(n2)\r\n"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> \r\nIt is by definition that a graph is bipartite iff it does not contain odd length cycles.\r\nSo the answer is O(1).<br/>\r\nFor more background reading, check this link \r\n\r\n<a href=\"https://proofwiki.org/wiki/Graph_is_Bipartite_iff_No_Odd_Cycles\">https://proofwiki.org/wiki/Graph_is_Bipartite_iff_No_Odd_Cycles</a>\n</div>",
        "keyword": "Graph"
    },
    {
        "question": "Let G be a simple graph with 20 vertices and 8 components. If we delete a vertex in G, then number of components in G should lie between ____.\r\n\r\n",
        "answer": [
            "8 and 20",
            "8 and 19",
            "7 and 19",
            "7 and 20"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> \r\nCase 1: If the vertex we are deleting from G is an isolated vertex, which is a component by itself, then number of components in G becomes 7.<br/>\r\nCase 2: If G is a start Graph, then by deleting the cut vertex of G, we get 19 components.\r\nHence, number of components in G should lie between 7 and 19.\r\n</div>",
        "keyword": "Graph"
    },
    {
        "question": "Let G be the graph with 100 vertices numbered 1 to 100. Two vertices i and j are adjacent iff |i−j|=8 or |i−j|=12. The number of connected components in G is",
        "answer": [
            "8",
            "4",
            "12",
            "25"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> When vertices are arranged with difference of 8 there are 8 components as shown by 8 columns in the image below:\r\n\r\n<img alt=\"\" class=\"aligncenter size-full\" height=\"346\" src=\"https://cdncontribute.geeksforgeeks.org/wp-content/uploads/gate_1997_42-2.png\" width=\"715\"/>\r\n\r\nWhen vertices are arranged with difference of 12 the number of components is reduced to 4 as first column will be connected with fifth column, second column will be connected with sixth column, third column will be connected with seventh column and fourth column will be connected with eighth column. No other form of connection exists so total 4 connected components are there.\r\n\r\nSo, option (B) is correct.\r\n\r\nThis explanation is contributed by <b>Pradeep Pandey</b>.</div>",
        "keyword": "Graph"
    },
    {
        "question": "A complete, undirected, weighted graph G is given on the vertex {0, 1,...., n−1} for any fixed ‘n’. Draw the minimum spanning tree of G if\r\n\r\na) the weight of the edge (u,v) is ∣ u−v ∣\r\nb) the weight of the edge (u,v) is u + v",
        "answer": "None",
        "correct": "None",
        "explain": "None",
        "keyword": "Graph"
    },
    {
        "question": "Let G be the directed, weighted graph shown in below figure\r\n\r\n\r\n\r\nWe are interested in the shortest paths from A.\r\n\r\n(a) Output the sequence of vertices identified by the Dijkstra’s algorithm for single source shortest path when the algorithm is started at node A.\r\n(b) Write down sequence of vertices in the shortest path from A to E.\r\n(c) What is the cost of the shortest path from A to E?",
        "answer": "None",
        "correct": "None",
        "explain": "<div class=\"mtq_explanation-text\"> According to <a href=\"https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/\" rel=\"noopener\" target=\"_blank\">Dijkstra's algorithm</a>:\r\n(a) Sequence of vertices when algorithm start traversing from A: A -&gt; B -&gt; D -&gt; C -&gt; F -&gt; E\r\n(b) The sequence remain same as answer (a).\r\n(c) Cost of the shortest path from A to E is 84.</div>",
        "keyword": "Graph"
    },
    {
        "question": "Which of the following data structure is useful in traversing a given graph by breadth first search?",
        "answer": [
            "Stack",
            "List",
            "Queue",
            "None of the above."
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> BFS performs level-order traversal which can be fairly done using a queue. A queue uses FIFO ordering and the nodes that we enqueue first are explored first maintaining the order of traversal. </div>",
        "keyword": "Graph"
    },
    {
        "question": "In the following graph, discovery time stamps and finishing time stamps of Depth First Search (DFS) are shown as x/y, where x is discovery time stamp and y is finishing time stamp.\r\n\n\r\nIt shows which of the following depth first forest?",
        "answer": [
            "{a, b, e} {c, d, f, g, h}",
            "{a, b, e} {c, d, h} {f, g}",
            "{a, b, e} {f, g} {c, d} {h}",
            "{a, b, c, d} {e, f, g} {h}"
        ],
        "correct": "A",
        "explain": "None",
        "keyword": "Graph"
    },
    {
        "question": "If we want to search any name in the phone directory , which is the most efficient data structure?",
        "answer": [
            "Binary search Tree",
            "Balanced BST",
            "Trie",
            "Linked list"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> In BST and balanced BST searching takes time in order of mlogn , where m is the maximum string length and n is the number of strings in tree . But searching in Trie will take O(m) time.\r\nHence ,  option C is the correct answer.</div>",
        "keyword": "Graph"
    },
    {
        "question": "Which of the following according to you is incorrect?",
        "answer": [
            "Trie is also known as prefix tree",
            "Trie requires less storage space than hashing",
            "Trie allows listing of all the words with same prefix",
            "Tries are collision free"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Both the hashing and the trie provides searching in the linear time. But trie requires extra space for storage and it is collision free. And trie allows finding all the strings with same prefix, so it is also called prefix tree.\r\nHence , option B is the correct option.</div>",
        "keyword": "Graph"
    },
    {
        "question": "Trie is also known as _____",
        "answer": [
            "Treap",
            " Binomial Tree",
            " 2-3 Tree",
            "Digital Tree"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> Trie is also known as Digital tree.\r\nHence , option D is the correct answer.</div>",
        "keyword": "Graph"
    },
    {
        "question": "Which kind of traversal order trie gives the lexicographical sorting of the set of the strings?",
        "answer": [
            "Preorder",
            "Postorder",
            "Level order",
            " Inorder"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> \r\nTo print the string in alphabetical order we have to first insert in the trie and then perform preorder traversal to print in alphabetical order.</div>",
        "keyword": "Graph"
    },
    {
        "question": " What is the worst case efficiency for a path compression algorithm?",
        "answer": [
            "O(M log N)",
            "O(N log N)",
            "O(log N)",
            "O(N)"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> The worst case efficiency for a path compression algorithm is mathematically found to be O(M log N).\r\nHence , option A is correct.</div>",
        "keyword": "Graph"
    },
    {
        "question": "In an undirected connected planar graph G, there are eight vertices and five faces. The number of edges in G is _________.",
        "answer": [
            "10",
            "11",
            "12",
            "6"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> By using Euler’s theorem, the number of regions = e - v + 2 \r\nR = e - v + 2\r\n5 = e - 8 + 2 = e-6\r\ne = 5+6 = 11\r\n</div>",
        "keyword": "Graph"
    },
    {
        "question": "Consider the following undirected graph with edge weights as shown:\r\n\r\n \r\n\r\n\r\n\r\nThe number of minimum-weight spanning trees of the graph is ___________.",
        "answer": [
            "3",
            "4",
            "5",
            "2"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> According to <a href=\"https://www.geeksforgeeks.org/kruskals-minimum-spanning-tree-using-stl-in-c/\" rel=\"noopener\" target=\"_blank\">Kruskal’s Minimum Spanning Tree using</a> :\r\n\r\n<img alt=\"\" class=\"alignnone size-full wp-image-573549\" height=\"171\" src=\"https://media.geeksforgeeks.org/wp-content/cdn-uploads/20210316134533/12332.png\" width=\"296\"/>\r\n\r\nNow, there are 3 edges between these components to connect them. \r\n\r\nAccording to Kruskal's algorithm, we will include minimum weights edges first if there is no cycle resultant.\r\n\r\nBut, we need only one edge to form spanning tree, and we have 3 options for one edge.\r\n\r\nHence, number of spanning trees are 3.\r\n\r\n </div>",
        "keyword": "Graph"
    },
    {
        "question": "A hash table of length 10 uses open addressing with hash function h(k)=k mod 10, and linear probing. After inserting 6 values into an empty hash table, the table is as shown below.\r\n\n\n\r\nWhich one of the following choices gives a possible order in which the key values could have been inserted in the table?",
        "answer": [
            "46, 42, 34, 52, 23, 33",
            "34, 42, 23, 52, 33, 46",
            "46, 34, 42, 23, 52, 33",
            "42, 46, 33, 23, 34, 52"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> See question 2 of <a href=\"http://www.geeksforgeeks.org/data-structures-and-algorithms-set-24/\">http://www.geeksforgeeks.org/data-structures-and-algorithms-set-24/</a></div>",
        "keyword": "Hash"
    },
    {
        "question": "How many different insertion sequences of the key values using the hash function h(k) = k mod 10 and linear probing will result in the hash table shown below?\r\n\n",
        "answer": [
            "10",
            "20",
            "30",
            "40"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> In a valid insertion sequence, the elements 42, 23 and 34 must appear before 52 and 33, and 46 must appear before 33.\r\nTotal number of different sequences = 3! x 5 = 30\r\nIn the above expression, 3! is for elements 42, 23 and 34 as they can appear in any order, and 5 is for element 46 as it can appear at 5 different places.</div>",
        "keyword": "Hash"
    },
    {
        "question": "The keys 12, 18, 13, 2, 3, 23, 5 and 15 are inserted into an initially empty hash table of length 10 using open addressing with hash function h(k) = k mod 10 and linear probing. What is the resultant hash table?\r\n\r\n",
        "answer": [
            "A",
            "B",
            "C",
            "D"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> To get the idea of open addressing concept, you can go through below lines from <a href=\"http://en.wikipedia.org/wiki/Open_addressing\">Wikipedia</a>\r\n.\r\nOpen addressing, or closed hashing, is a method of collision resolution in hash tables. With this method a hash collision is resolved by probing, or searching through alternate locations in the array (the probe sequence) until either the target record is found, or an unused array slot is found, which indicates that there is no such key in the table.  Well known probe sequences include:\r\n\r\n<em>linear probing </em>  in which the interval between probes is fixed--often at 1.\r\n<em>quadratic probing </em> in which the interval between probes increases linearly (hence, the indices are described by a quadratic function).\r\n<em>double hashing </em> in which the interval between probes is fixed for each record but is computed by another hash function. </div>",
        "keyword": "Hash"
    },
    {
        "question": "Consider a hash table of size seven, with starting index zero, and a hash function (3x + 4)mod7. Assuming the hash table is initially empty, which of the following is the contents of the table when the sequence 1, 3, 8, 10 is inserted into the table using closed hashing? Note that ‘_’ denotes an empty location in the table.",
        "answer": [
            " 8, _, _, _, _, _, 10",
            "1, 8, 10, _, _, _, 3",
            "1, _, _, _, _, _,3",
            "1, 10, 8, _, _, _, 3"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Please see <a href=\"http://lcm.csa.iisc.ernet.in/dsa/node38.html\">http://lcm.csa.iisc.ernet.in/dsa/node38.html</a> for closed hashing and probing.\r\n\r\nLet us put values 1, 3, 8, 10 in the hash of size 7.\r\n\r\nInitially, hash table is empty\r\n<pre>    -    -    -   -   -   -   -\r\n    0    1   2   3   4   5   6</pre>\r\nThe value of function (3x + 4)mod 7 for 1 is 0, so let us put the value at 0\r\n<pre>    1    -    -   -   -   -   -\r\n    0    1   2   3   4   5   6</pre>\r\nThe value of function (3x + 4)mod 7 for 3 is 6, so let us put the value at 6\r\n<pre>    1    -    -   -   -   -   3\r\n    0    1   2   3   4   5   6</pre>\r\nThe value of function (3x + 4)mod 7 for 8 is 0, but 0 is already occupied, let us put the value(8) at next available space(1)\r\n<pre>    1    8    -   -   -   -   3\r\n    0    1   2   3   4   5   6</pre>\r\nThe value of function (3x + 4)mod 7 for 10 is 6, but 6 is already occupied, let us put the value(10) at next available space(2)\r\n<pre>    1    8   10   -   -   -   3\r\n    0    1   2    3   4   5   6</pre>\r\n </div>",
        "keyword": "Hash"
    },
    {
        "question": "Consider a hash table of size seven, with starting index zero, and a hash function (3x + 4)mod7. Assuming the hash table is initially empty, which of the following is the contents of the table when the sequence 1, 3, 8, 10 is inserted into the table using closed hashing? Note that ‘_’ denotes an empty location in the table.",
        "answer": [
            " 8, _, _, _, _, _, 10",
            "1, 8, 10, _, _, _, 3",
            "1, _, _, _, _, _,3",
            "1, 10, 8, _, _, _, 3"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Please see <a href=\"http://lcm.csa.iisc.ernet.in/dsa/node38.html\">http://lcm.csa.iisc.ernet.in/dsa/node38.html</a> for closed hashing and probing.\r\n\r\nLet us put values 1, 3, 8, 10 in the hash of size 7.\r\n\r\nInitially, hash table is empty\r\n<pre>    -    -    -   -   -   -   -\r\n    0    1   2   3   4   5   6</pre>\r\nThe value of function (3x + 4)mod 7 for 1 is 0, so let us put the value at 0\r\n<pre>    1    -    -   -   -   -   -\r\n    0    1   2   3   4   5   6</pre>\r\nThe value of function (3x + 4)mod 7 for 3 is 6, so let us put the value at 6\r\n<pre>    1    -    -   -   -   -   3\r\n    0    1   2   3   4   5   6</pre>\r\nThe value of function (3x + 4)mod 7 for 8 is 0, but 0 is already occupied, let us put the value(8) at next available space(1)\r\n<pre>    1    8    -   -   -   -   3\r\n    0    1   2   3   4   5   6</pre>\r\nThe value of function (3x + 4)mod 7 for 10 is 6, but 6 is already occupied, let us put the value(10) at next available space(2)\r\n<pre>    1    8   10   -   -   -   3\r\n    0    1   2    3   4   5   6</pre>\r\n </div>",
        "keyword": "Hash"
    },
    {
        "question": "Given the following input (4322, 1334, 1471, 9679, 1989, 6171, 6173, 4199) and the hash function x mod 10, which of the following statements are true?\r\ni. 9679, 1989, 4199 hash to the same value\r\nii. 1471, 6171 hash to the same value\r\niii. All elements hash to the same value\r\niv. Each element hashes to a different value\r\n(GATE CS 2004)",
        "answer": [
            "i only",
            "ii only",
            "i and ii only",
            "iii or iv"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>Hash function given is mod(10).\r\n9679, 1989 and 4199 all these give same hash value i.e 9\r\n1471 and 6171 give hash value 1 </pre>\n</div>",
        "keyword": "Hash"
    },
    {
        "question": "Consider a hash table with 100 slots. Collisions are resolved using chaining. Assuming simple uniform hashing, what is the probability that the first 3 slots are unfilled after the first 3 insertions?",
        "answer": [
            "(97 × 97 × 97)/1003 ",
            "(99 × 98 × 97)/1003",
            "(97 × 96 × 95)/1003 ",
            " (97 × 96 × 95)/(3! × 1003)"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Simple Uniform hashing function is a hypothetical hashing function that evenly distributes items into the slots of a hash table. Moreover, each item to be hashed has an equal probability of being placed into a slot, regardless of the other elements already placed. (Source: <a href=\"https://en.wikipedia.org/wiki/SUHA_%28computer_science%29\">https://en.wikipedia.org/wiki/SUHA_%28computer_science%29</a>). \r\n\r\n<pre>\r\nProbability that the first 3 slots are unfilled after the first 3 insertions = \r\n                (probability that first item doesn't go in any of the first 3 slots)*\r\n                (probability that second item doesn't go in any of the first 3 slots)*\r\n                (probability that third item doesn't go in any of the first 3 slots)\r\n\r\n                 = (97/100) * (97/100) * (97/100) </pre></div>",
        "keyword": "Hash"
    },
    {
        "question": "\nWhich one of the following hash functions on integers will distribute keys most uniformly over 10 buckets numbered 0 to 9 for i ranging from 0 to 2020? \n",
        "answer": [
            "\nh(i) = (12 ∗ i) mod 10 \n",
            "\nh(i) = (11 ∗ i2) mod 10 \n",
            "\nh(i) =i3 mod 10 \n",
            "\nh(i) =i2 mod 10  \n"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\">\n<p>Since mod 10 is used, the last digit matters. <br/><br/>If you do cube all numbers from 0 to 9, you get following <br/><br/> </p>\n<pre>Number    Cube    Last Digit in Cube\n  0        0              0 \n  1        1              1 \n  2        8              8 \n  3        27             7 \n  4        64             4 \n  5        125            5 \n  6        216            6\n  7        343            3\n  8        512            2\n  9        729            9  </pre>\n<p><br/><br/>Therefore all numbers from 0 to 2020 are equally divided in 10 buckets. If we make a table for square, we don't get equal distribution. In the following table. 1, 4, 6 and 9 are repeated, so these buckets would have more entries and buckets 2, 3, 7 and 8 would be empty. <br/><br/> </p>\n<pre>Number   Square     Last Digit in Square\n  0        0              0 \n  1        1              <strong>1</strong> \n  2        4              <strong>4</strong> \n  3        9              <strong>9</strong> \n  4        16             <strong>6</strong>\n  5        25             5 \n  6        36             <strong>6</strong>\n  7        49             <strong>9</strong>\n  8        64             <strong>4</strong>\n  9        81             <strong>1</strong>  </pre>\n<p><br/><br/><br/><strong>Alternative approach -</strong> <br/>Using concept of power of cycle: <br/><br/>(a) (0,1,4,9,6,5,6,9,4,1,0) repeated <br/>(b) (0,1,8,7,4,5,6,3,2,9) repeated <br/>(c) (0,1,4,9,6,5,6,9,4,1,0) repeated <br/>(d) (0,2,4,6,8) repeated <br/><br/>So, only h(i) =i<sup>3</sup> mod 10 covers all the digits from 0 to 9. <br/>Option (B) is correct. <br/><br/><br/><br/> </p>\n</div>",
        "keyword": "Hash"
    },
    {
        "question": "Given a hash table T with 25 slots that stores 2000 elements, the load factor α for T is __________",
        "answer": [
            "80",
            "0.0125",
            "8000",
            "1.25"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> load factor = (no. of elements) / (no. of table slots) = 2000/25 = 80</div>",
        "keyword": "Hash"
    },
    {
        "question": "Which of the following statement(s) is TRUE?\r\n\nA hash function takes a message of arbitrary length and generates a fixed length code.\nA hash function takes a message of fixed length and generates a code of variable length.\nA hash function may give the same hash value for distinct messages.\n\r\n ",
        "answer": [
            "I only",
            "II and III only",
            "I and III only",
            "II only"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\">  \r\n\r\n<span style=\"font-size: small;\">Hash function is defined as any function that can be used to map data of arbitrary size of data to a fixed size data.. The values returned by a hash function are called hash values, hash codes, digests, or simply hashes  :  Statement 1 is correct\r\nYes, it is possible that a Hash Function maps a value to a same location in the memory that's why collision occurs and we have different technique to handle  this problem : Statement 3 is correct.\r\neg : we have hash function, h(x) = x mod 3</span>\n<span style=\"font-size: small;\">Acc to Statement 1, no matter what the value of 'x' is h(x) results in a fixed mapping location.\r\nAcc. to Statement 3, h(x) can result in same mapping mapping location for different value of 'x' e.g. if x = 4 or x = 7 , h(x) = 1 in both the cases, although collision occurs.</span>\r\n\r\n \r\n\r\nThis solution is contributed by <b class=\"gmail_sendername\">Mohit Gupta</b>.</div>",
        "keyword": "Hash"
    },
    {
        "question": "Consider a hash function that distributes keys uniformly. The hash table size is 20. After hashing of how many keys will the probability that any new key hashed collides with an existing one exceed 0.5.",
        "answer": [
            "5",
            "6",
            "7",
            "10"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> For each entry probability of collision is 1/20 {as possible total spaces =20, and an entry will go into only 1 place}<br/>\r\nSay after inserting x values probability becomes ½<br/>\r\n\t(1/20).x = ½<br/>\r\n\tX=10\r\n</div>",
        "keyword": "Hash"
    },
    {
        "question": "A hash function h defined h(key)=key mod 7, with linear probing, is used to insert the keys 44, 45, 79, 55, 91, 18, 63 into a table indexed from 0 to 6. What will be the location of key 18?",
        "answer": [
            "3",
            "4",
            "5",
            "6"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> keys 44, 45, 79, 55, 91, 18, 63\r\nh(key)= key mod 7\r\nh(44) = 44mod7 = 2\r\nh(45) = 45mod7 = 3\r\nh(79) = 79mod7 = 2\r\nbut 2 is already filled by 44, linear probing is applied but 3 is also filled by 45.\r\nSo, 79 will occupy 4.\r\nh(55) = 55mod7 = 6\r\nh(91) = 91mod7 = 0\r\nh(18) = 18mod7 = 4 but 4 is occupied by 79 so, it will occupy 5.\r\nh(63) = 63mod7 = 0. 0 is also occupied so, it will occupy 1.\r\nSo, option (C) is correct.</div>",
        "keyword": "Hash"
    },
    {
        "question": "An advantage of chained hash table (external hashing) over the open addressing scheme is\r\n\r\n",
        "answer": [
            "Worst case complexity of search operations is less",
            "Space used is less",
            "Deletion is easier",
            "None of the above"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>In Open Addressing scheme sometimes though element is present we can't delete it if empty bucket comes in between while searching for that element.\r\nExternal hashing scheme is free from this limitations .\r\nHence, Option c is correct answer. </pre></div>",
        "keyword": "Hash"
    },
    {
        "question": "Insert the characters of the string K R P C S N Y T J M into a hash table of size 10.\r\nUse the hash function\r\nh(x) = ( ord(x) – ord(\"a\") + 1 ) mod10\r\nIf linear probing is used to resolve collisions, then the following insertion causes collision",
        "answer": [
            "Y",
            "C",
            "M",
            "P"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> \r\n(a) The hash table with size 10 will have index from 0 to 9.\r\nhash function = h(x) = ((ord(x) - ord(A) + 1)) mod 10\r\nSo for string K R P C S N Y T J M:\r\nK will be inserted at index : (11-1+1) mod 10 = 1\r\nR at index: (18-1+1) mod 10 = 8\r\nP at index: (16-1+1) mod 10 = 6\r\nC at index: (3-1+1) mod 10 = 3\r\nS at index: (19-1+1) mod 10 = 9\r\nN at index: (14-1+1) mod 10 = 4\r\nY at index (25-1+1) mod 10 = 5\r\nT at index (20-1+1) mod 10 = 0\r\nJ at index (10-1+1) mod 10 = 0 // first collision occurs.\r\nM at index (13-1+1) mod 10 = 3 //second collision occurs.\r\n\r\nOnly J and M are causing the collision.\r\n\r\n(b) Final Hash table will be:\r\n\r\n<pre>\r\n0\tT\r\n1\tK\r\n2\tJ\r\n3\tC\r\n4\tN\r\n5\tY\r\n6\tP\r\n7\tM\r\n8\tR\r\n9\tS</pre>\n</div>",
        "keyword": "Hash"
    },
    {
        "question": "The characters of the string K R P C S N Y T J M are inserted into a hash table of size 10 using hash function\r\nh(x) = ((ord(x) - ord(A) + 1)) mod 10\r\nIf linear probing is used to resolve collisions, then the following insertion causes collision",
        "answer": [
            "Y",
            "C",
            "M",
            "P"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> The hash table with size 10 will have index from 0 to 9.\r\nhash function = h(x) = ((ord(x) - ord(A) + 1)) mod 10\r\nSo for string K R P C S N Y T J M:\r\nK will be inserted at index : (11-1+1) mod 10 = 1\r\nR at index: (18-1+1) mod 10 = 8\r\nP at index: (16-1+1) mod 10 = 6\r\nC at index: (3-1+1) mod 10 = 3\r\nS at index: (19-1+1) mod 10 = 9\r\nN at index: (14-1+1) mod 10 = 4\r\nY at index (25-1+1) mod 10 = 5\r\nT at index (20-1+1) mod 10 = 0\r\nJ at index (10-1+1) mod 10 = 0 // first collision occurs.\r\nM at index (13-1+1) mod 10 = 3 //second collision occurs.\r\n\r\nOnly J and M are causing the collision.\r\n\r\nFinal Hash table will be:\r\n\r\n<pre>\r\n0\tT\r\n1\tK\r\n2\tJ\r\n3\tC\r\n4\tN\r\n5\tY\r\n6\tP\r\n7\tM\r\n8\tR\r\n9\tS</pre>\r\n\r\n\r\nSo, option (C) is correct.</div>",
        "keyword": "Hash"
    },
    {
        "question": "A hash table with ten buckets with one slot per bucket is shown in the following figure. The symbols S1 to S7 initially entered using a hashing function with linear probing.The maximum number of comparisons needed in searching an item that is not present is\r\n\r\n",
        "answer": [
            "4",
            "5",
            "6",
            "3"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>We have to consider different cases to find the maximum number\r\n of comparisons needed in searching an item that is not present.\r\nIf searching starts at 0 index : 3 comparisons will be made at\r\n index 0, index 1 and finally at index 2 and terminate searching \r\nwhen index 2 found empty.\r\nSimilarly after checking on different indexes, the maximum number\r\nof comparisons will be required if searching starts from index 8,\r\nas in this case, total 5 comparisons will be made at index 8, 9, 0, 1 and 2.\r\nSo, correct option is (B).</pre>\n</div>",
        "keyword": "Hash"
    },
    {
        "question": "Consider a hash table of size m = 10000, and the hash function h(K) = floor (m(KA mod 1)) for A = ( √(5) – 1)/2. The key 123456 is mapped to location ______.",
        "answer": [
            "46",
            "41",
            "43",
            "48"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Given hash function: h(K) = floor (m (K*A mod 1)) \r\nwhere A = ( √(5) – 1)/2\r\n<pre>h(123456) = floor(10000 * (123456 * (√5 − 1) / 2) mod 1) \r\n          = floor(10000 * (76300.004115 mod 1)\r\n          = floor(10000 * (.004115))\r\n          = 41.15\r\n          = 41 </pre>\r\nSo, option (B) is correct.</div>",
        "keyword": "Hash"
    },
    {
        "question": "Consider a 13 element hash table for which f(key)=key mod 13 is used with integer keys. Assuming linear probing is used for collision resolution, at which location would the key 103 be inserted, if the keys 661, 182, 24 and 103 are inserted in that order?",
        "answer": [
            "0",
            "1",
            "11",
            "12"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> 661 mod 13 = 11\r\n182 mod 13 = 0\r\n24 mod 13 = 11, already filled, so after linear probing it will get index 12\r\n103 mod 13 = 12, already filled, so after linear probing it will get index 1\r\n\r\n<img src=\"https://www.geeksforgeeks.org/wp-content/uploads/fffgggg.png\"/> \r\n\r\nSo, option (B) is correct.</div>",
        "keyword": "Hash"
    },
    {
        "question": "What will be the cipher text produced by the following cipher function for the plain text ISRO with key k =7. [Consider 'A' = 0, 'B' = 1, .......'Z' = 25]. Ck(M) = (kM + 13) mod 26 ",
        "answer": [
            "RJCH ",
            "QIBG ",
            "GQPM",
            "XPIN"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>Ck(M) = (kM + 13) mod 26 \r\n\r\nHere, 'A' = 0, 'B' = 1, .......'Z' = 25\r\n\r\nI = Ck(I) = (7*8 + 13) mod 26 = 17 = R\r\nS = Ck(S) = (7*18 + 13) mod 26 = 9 = J\r\nR = Ck(R) = (7*17 + 13) mod 26 = 2 = C\r\nO = Ck(O) = (7*14 + 13) mod 26 = 7 = H  </pre>\r\n\r\nSo, option (A) is correct.</div>",
        "keyword": "Hash"
    },
    {
        "question": "Consider a hash table of size m = 100 and the hash function h(k) = floor(m(kA mod 1)) for \r\nCompute the location to which the key k = 123456 is placed in hash table.",
        "answer": [
            "77",
            "82",
            "88",
            "89"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> h(k) = floor(m(kA mod 1)) \r\nM = 100; k = 123456 \r\nh(k) = floor(100(123456 * 0.618033 mod 1))\r\nh(k) = floor(100(76189.882048 mod 1))\r\nh(k) = floor(100 * 0.882048)\r\nh(k) = floor(88.2048)\r\nh(k) = 88.\r\nSo, option (C) is correct.\r\n\r\n</div>",
        "keyword": "Hash"
    },
    {
        "question": "A hash table with 10 buckets with one slot per bucket is depicted here. The symbols, S1 to 57 are initially entered using a hashing function with linear probing. The maximum number of comparisons needed in searching an item that is not present is\r\n\r\n\n",
        "answer": [
            "4",
            "5",
            "6",
            "3"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> We have to consider different cases to find the maximum number of comparisons needed in searching an item that is not present.\r\nIf searching starts at 0 index : 3 comparisons will be made at index 0, index 1 and finally at index 2 and terminate searching when index 2 found empty.\r\nSimilarly after checking on different indexes, the maximum number of comparisons will be required if searching starts from index 8, as in this case, total 5 comparisons will be made at index 8, 9, 0, 1 and 2.\r\n\r\nSo, correct option is (B).</div>",
        "keyword": "Hash"
    },
    {
        "question": "A hash function h defined h(key)=key mod 7, with linear probing, is used to insert the keys 44, 45, 79, 55, 91, 18, 63 into a table indexed from 0 to 6. What will be the location of key 18 ?",
        "answer": [
            "3",
            "4",
            "5",
            "6"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> keys 44, 45, 79, 55, 91, 18, 63 \r\nh(key)=key mod 7\r\nh(44) = 44mod7 = 2 \r\nh(45) = 45mod7 = 3\r\nh(79) = 79mod7 = 2 \r\nbut 2 is already filled 44, linear probing is applied but 3 ias also filled.\r\nSo, 79 will occupy 4.\r\nh(55) = 55mod7 = 6\r\nh(91) = 91mod7 = 0\r\nh(18) = 18mod7 = 4 but 4 is occupied by 79 so, it will occupy 5.\r\nh(63) = 63mod7 = 0. 0 is also occupied so, it will occupy 1.\r\nSo, option (C) is correct. \r\n</div>",
        "keyword": "Hash"
    },
    {
        "question": "Consider a hash table of size seven, with starting index zero, and a hash function (7x+3) mod 4. Assuming the hash table is initially empty, which of the following is the contents of the table when the sequence 1, 3, 8, 10 is inserted into the table using closed hashing ? Here “__” denotes an empty location in the table.",
        "answer": [
            "3, 10, 1, 8, __ , __ , __",
            "1, 3, 8, 10, __ , __ , __",
            "1, __ , 3, __ , 8, __ , 10",
            "3, 10, __ , __ , 8, __ , __"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Keys are 1, 3, 8, 10.\r\nh(x) = (7*x + 3) <br/>\r\nh(1) = (10) mod 4 = 2 <br/>\r\nh(3) = (7 * 3 + 3) mod 4 = 24 mod 4 = 0<br/>\r\nh(8) = (7 * 8 + 3) mod 4 = 3 <br/>\r\nh(10)= (7 * 10 + 3)mod 4 = 1<br/>\r\ni.e.  3, 10, 1, 8, __ , __ , __<br/>\r\nSo, option (A) is correct.</div>",
        "keyword": "Hash"
    },
    {
        "question": "Consider a double hashing scheme in which the primary hash function is h1(k) = k mod 23, and the secondary hash function is h2(k) = 1+(k mod 19). Assume that the table size is 23. Then the address returned by probe 1 in the probe sequence (assume that the probe sequence begins at probe 0) for key value k = 90 is ________ .\r\n\r\n\r\nNote - This question was Numerical Type.",
        "answer": [
            "13",
            "15",
            "21",
            "23"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\">  Given, <br/> </div>",
        "keyword": "Hash"
    },
    {
        "question": "Consider a dynamic hashing approach for 4-bit integer keys:\r\n\n(A) There is a main hash table of size 4.\r\n\n(B) The 2 least significant bits of a key is used to index into the main hash table.\r\n\n(C) Initially, the main hash table entries are empty.\r\n\n(D) Thereafter, when more keys are hashed into it, to resolve collisions, the set of all keys corresponding to a main hash table entry is organized as a binary tree that grows on demand.\r\n\n(E) First, the 3rd least significant bit is used to divide the keys into left and right subtrees.\r\n\n(F) To resolve more collisions, each node of the binary tree is further sub-divided into left and right subtrees based on the 4th least significant bit.\r\n\n(G) A split is done only if it is needed, i.e., only when there is a collision.\r\n\n\r\n\r\nConsider the following state of the hash table.\r\n\r\n\r\n\r\n \r\n\r\nWhich of the following sequences of key insertions can cause the above state of the hash table (assume the keys are in decimal notation)?",
        "answer": [
            "5,9,4,13,10,7",
            "9,5,10,6,7,1",
            "10,9,6,7,5,13",
            "9,5,13,6,10,14"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Sequence given in option (A) is not possible, because of entry 4 (= 0100) which is not in final hash table.\r\n\r\nSequence given in option (B) is not possible, because of entry 1 (=0001) and 9 (=1001) resolving collision on 0 side based on third LSB. \r\n\r\nSequence given in option (C) is the correct sequence to get given final hash table.\r\n\r\nSequence given in option (D) is not possible, because of entry 6 (=0110), 10 (=1010), and 14 (=1110) in the third column, 3 sequence is not given in the final hash table.</div>",
        "keyword": "Hash"
    },
    {
        "question": "Consider double hashing of the form\r\nh(k,i)=(h​ 1​ (k)+ih​ 2​ (k)) mod m\r\nWhere h​ 1​ (k)=k mod m\r\nh​ 2​ (k)=1+(k mod n)\r\nWhere n=m-1and m=701\r\nfor k=123456, what is the difference between first and second probes in terms of slots?",
        "answer": [
            "255",
            "256",
            "257",
            "258"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Given that \r\n\r\n=&gt; h(k, i) = (h1(k)+ih2 (k)) mod m\r\n=&gt; Where h​1​(k)=k mod m,\r\n   h​2​ (k)=1+(k mod n)\r\n   n=m-1, \r\n   m=701 \r\n   k = 123456\r\n\r\nNow,\r\n\r\n=&gt; h1(k) = 123456 mod 701 = 80\r\n=&gt; h2(k) = 1 + (123456 mod 700) = 1 + 256 = 257\r\n\r\n1st probe: when i =1\r\n\r\n=&gt; h(k, i) = h1(k) + ih2(k)\r\n=&gt; h(k, 1) = h1(k) + h2(k) = 80 + 257 = 337\r\n\r\n2nd probe: when i =2\r\n\r\n=&gt; h(k,2) = h1(k) + 2*h2(k) \r\n          = 80 + 2*257\r\n\r\n=&gt; h(k,2) = 80 + 514 = 594\r\n\r\nSo, difference between first two probes = 594 – 337\r\n                                        = 257\r\n=&gt; Option C is answer.</div>",
        "keyword": "Hash"
    },
    {
        "question": "\nSuppose we are given n keys, m hash table slots, and two simple uniform hash functions h1 and h2. Further, suppose our hashing scheme uses h1 for the odd keys and h2 for the even keys. What is the expected number of keys in a slot? \n",
        "answer": [
            "\n[Tex]frac{n}{2m}[/Tex]\n",
            "\n[Tex]frac{n}{m}[/Tex]\n",
            "\n[Tex]frac{m}{n}[/Tex]\n",
            "\n[Tex]frac{2n}{m}[/Tex]\n"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\">\n<p>For a uniform hash function, regardless of the number of hash functions, the anticipated number of keys in a slot is always computed as (number of keys)/(number of slots). So, option B is the correct answer. </p>\n</div>",
        "keyword": "Hash"
    },
    {
        "question": "\nA program P reads in 500 integers in the range [0..100] representing the scores of 500 students. It then prints the frequency of each score above 50. What would be the best way for P to store the frequencies? (GATE CS 2005) \n",
        "answer": [
            "\nAn array of 50 numbers \n",
            "\nAn array of 100 numbers \n",
            "\nAn array of 500 numbers \n",
            "\nA dynamically allocated array of 550 numbers \n"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\">\n<p>See question 1 of <a href='\"http://www.geeksforgeeks.org/data-structures-and-algorithms-set-22/\"'>http://www.geeksforgeeks.org/data-structures-and-algorithms-set-22/</a><br/> </p>\n</div>",
        "keyword": "Array"
    },
    {
        "question": "Which of the following operations is not O(1) for an array of sorted data.  You may assume that array elements are distinct.",
        "answer": [
            "Find the ith largest element",
            "Delete an element",
            "Find the ith smallest element",
            "All of the above"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> The worst case time complexity for deleting an element from array can become O(n).</div>",
        "keyword": "Array"
    },
    {
        "question": "The minimum number of comparisons required to determine if an integer appears more than n/2 times in a sorted array of n integers is\r\n",
        "answer": [
            "Θ(n)",
            "Θ(logn)",
            "Θ(log*n)",
            "Θ(1)"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> If you answered Theta(1), then think of examples {1, 2, 2, 2, 4, 4}, {1, 1, 2, 2, 2, 2, 3, 3} \r\n\r\nThe Best way to find out whether an integer appears more than n/2 times in a sorted array(Ascending Order) of n integers, would be binary search approach.\r\n<ol>\n<li>The First occurence of an element can be found out in O(log(n)) time using divide and conquer technique,lets say it is i.\r\n</li>\n<li>The Last occurrence of an element can be found out in O(log(n)) time using divide and conquer technique,lets say it is j.\r\n</li>\n<li>Now number of occuerence of that element(count) is (j-i+1). Overall time complexity = log n +log n +1 = O(logn)\r\n</li>\n</ol>\r\n\r\nSee <a href=\"http://www.geeksforgeeks.org/check-for-majority-element-in-a-sorted-array/\" target=\"_blank\">Check for Majority Element in a sorted array</a>\r\n\r\nThis solution is contributed by <strong>Nirmal Bharadwaj</strong></div>",
        "keyword": "Array"
    },
    {
        "question": "Let A be a square matrix of size n x n. Consider the following program. What is the expected output?\r\n\r\n\r\n\r\nC = 100\r\nfor i = 1 to n do\r\n    for j = 1 to n do\r\n    {\r\n        Temp = A[i][j] + C\r\n        A[i][j] = A[j][i]\r\n        A[j][i] = Temp - C\r\n    } \r\nfor i = 1 to n do\r\n    for j = 1 to n do\r\n        Output(A[i][j]);\r\n",
        "answer": [
            "The matrix A itself",
            "Transpose of matrix A",
            "Adding 100 to the upper diagonal elements and subtracting 100 from diagonal elements of A",
            "None of the above"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> If we take look at the inner statements of first loops, we can notice that the statements swap A[i][j] and A[j][i] for all i and j. Since the loop runs for all elements, every element A[l][m] would be swapped twice, once for i = l and j = m and then for i = m and j = l. Swapping twice means the matrix doesn’t change.\r\n\r\nSource: <a href=\"http://www.geeksforgeeks.org/data-structures-algorithms-set-34/\" target=\"_blank\">http://www.geeksforgeeks.org/data-structures-algorithms-set-34/</a></div>",
        "keyword": "Array"
    },
    {
        "question": "An algorithm performs (logN)1/2 find operations, N insert operations, (logN)1/2 delete operations, and (logN)1/2 decrease-key operations on a set of data items with keys drawn from a linearly ordered set. For a delete operation, a pointer is provided to the record that must be deleted. For the decrease-key operation, a pointer is provided to the record that has its key decreased. Which one of the following data structures is the most suited for the algorithm to use, if the goal is to achieve the best total asymptotic complexity considering all the operations?",
        "answer": [
            "Unsorted array",
            "Min-heap",
            " Sorted array",
            "Sorted doubly linked list"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> The time complexity of insert in unsorted array is O(1), O(Logn) in Min-Heap, O(n) in sorted array and sorted DLL.\r\n<ol><li>For unsorted array, we can always insert an element at end and do insert in O(1) time</li>\n<li>For Min Heap, insertion takes O(Log n) time. Refer<a href=\"http://quiz.geeksforgeeks.org/binary-heap/\"> Binary Heap operations</a> for details. </li>\n<li>For sorted array, insert takes O(n) time as we may have to move all elements worst case. </li>\n<li>For sorted doubly linked list, insert takes O(n) time to find position of element to be inserted. </li> </ol>\r\n\r\nSince number of insertion operations is asymptotically higher, unsorted array is preferred.</div>",
        "keyword": "Array"
    },
    {
        "question": "Consider an array consisting of –ve and +ve numbers. What would be the worst case time complexity of an algorithm to segregate the numbers having same sign altogether i.e all +ve on one side and then all -ve on the other ?         ",
        "answer": [
            "O(N)\r\n",
            "O(N Log N)",
            "O(N * N)",
            "O(N Log Log N)\r\n"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> \r\nHere we can use the partition algorithm of <a href=\"https://www.geeksforgeeks.org/quick-sort/\">quick sort</a> for segregation and answer will be O(N). \r\nChoose the first element as pivot whatever may be its sign we don’t care and keep an extra index at pivot position .</div>",
        "keyword": "Array"
    },
    {
        "question": "Let A[1...n] be an array of n distinct numbers. If i < j and A[i] > A[j], then the pair (i, j) is called an inversion of A. What is the expected number of inversions in any permutation on n elements ?",
        "answer": [
            "n(n-1)/2",
            "n(n-1)/4",
            "n(n+1)/4",
            "2n[logn]"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> \r\nThere are n(n-1)/2 pairs such that i &lt; j. For a pair (a<sub>i</sub>, a<sub>j</sub>), probability of being inversion is 1/2. Therefore expected value of inversions = 1/2 * (n(n-1)/2) = n(n-1)/4.</div>",
        "keyword": "Array"
    },
    {
        "question": "A three dimensional array in ‘C’ is declared as int A[x][y][z]. Consider that array elements are stored in row major order and indexing begins from 0. Here, the address of an item at the location A[p][q][r] can be computed as follows (where w is the word length of an integer):\r\n\r\n\r\n",
        "answer": [
            "&A[0][0][0] + w(y *  z  * q + z * p + r)",
            "&A[0][0][0] + w(y * z * p + z*q + r)",
            "&A[0][0][0] + w(x * y * p + z * q+ r)",
            "&A[0][0][0] + w(x * y * q + z * p + r)"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> According to above question we have to find the address of A[p][q][r]\r\n\r\nTo reach pth row we must have to cross 0 to p-1 row i.e. p rows and each rows contains y∗z elements\r\n\r\nHence , \r\n\r\n= y∗z∗p\r\n\r\nNow to reach qth element in pth row we have to cross q rows and each row contains z(total columns) elements\r\n\r\n=z∗q  \r\n\r\nto reach rth elements we have to cross r elements in (p+1)th row\r\n\r\nTotal elements to cross =(y∗z∗p+z∗q+r)\r\n\r\nNow each element occupies m amount of space  in memory \r\n\r\nTherefore total space occupied by these elements = m(y∗z∗p+z∗q+r)  \r\n\r\nHence , address of A[p][q][r]=base address+ Space Occupied by the Elements Before it.\r\n\r\n                                   =&amp;A[0][0][0]+m(y*z*p+z*q+r)\r\n\r\nHence Option (B) is correct.</div>",
        "keyword": "Array"
    },
    {
        "question": "Which of the following correctly declares an array?",
        "answer": [
            " int geeks[20];",
            "int geeks;",
            " geeks{20};",
            "array geeks[20];\r\n"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>Option A is correct. Int is the data type used,geeks is the name of the array and [20] is the size of the array.</pre></div>",
        "keyword": "Array"
    },
    {
        "question": "Consider a two dimensional array A[20][10]. Assume 4 words per memory cell, the base address of array A is 100, elements are stored in row-major order and first element is A[0][0]. What is the address of A[11][5] ? ",
        "answer": [
            "560",
            "460",
            "570",
            "575"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Element A[11][0] is stored at \"Base Address + 11 * 10 * 4\" which is  \"Base Address + 440\" = 540.  So A[11][5] is stored at 540 + 5*4 = 560.</div>",
        "keyword": "Array"
    },
    {
        "question": "An array A consists of n integers in locations A[0], A[1] ....A[n-1]. It is required to shift the elements of the array cyclically to the left by k places, where 1 <= k <= (n-1). An incomplete algorithm for doing this in linear time, without using another array is given below. Complete the algorithm by filling in the blanks. Assume alt the variables are suitably declared.\r\n\r\nmin = n; i = 0;\r\nwhile (___________) {\t\r\n     temp = A[i]; j = i;\r\n     while (________) {\r\n     A[j] = ________\t\r\n     j= (j + k) mod n ;\r\n     If ( j< min ) then\r\n         min = j;\r\n}\r\nA[(n + i â€” k) mod n] = _________\r\ni = __________\r\n\n",
        "answer": [
            "i > min; j!= (n+i)mod n; A[j + k]; temp; i + 1 ;",
            "i < min; j!= (n+i)mod n; A[j + k]; temp; i + 1;",
            "i > min; j!= (n+i+k)mod n; A[(j + k)]; temp; i + 1;",
            "i < min; j!= (n+i-k)mod n; A[(j + k)mod n]; temp; i + 1;\r\n"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> In the five blanks given in the question, the last two blanks must be temp and i+1 because all the given options for the fourth and fifth blanks have temp and i+1.\r\n\r\nNow, for the first blank, it must be i<min because=\"\" i=\"\" if=\"\" is=\"\" it=\"\">min then the control goes out of the while loop in the initial case when i=0 and min=n  \r\n\r\nSo, the first blank is i &lt; min which implies either option (B) or option (D) is correct.\r\n\r\nAssume option (B) is correct then in the bracket of while we have j!=(n+i)modn\r\n\r\nThat means whenever j becomes equal to (n+i)modn  then control goes out of the while loop.\r\n\r\nNow (n+i)modn=i and j is always equal to i because in line 3 of the code we are assigning the value of i to j.\r\n\r\nSo, if option (B) is true control never enters the second while loop but it has to enter the second while loop to shift the nos. K places left.\r\n\r\nHence, option (D) is correct.</min></div>",
        "keyword": "Array"
    },
    {
        "question": "Which data structure is used for balancing of symbols?",
        "answer": [
            "Stack",
            "Queue",
            "Tree",
            "Graph"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Stack is used for balancing of symbols. This is extensively used by the compiler to check for missing or additional symbols. The start of the symbol(like (, [, {) are pushed to the stack. When the end of the symbol(like ), \\, }) are encountered, it is matched with the corresponding peek element of the stack. If the match is found, the element is popped, else error is flashed.</div>",
        "keyword": "Data Structures Misc"
    },
    {
        "question": "Which data structure is used in redo-undo feature?",
        "answer": [
            "Stack",
            "Queue",
            "Tree",
            "Graph"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Stack data structure is most suitable to implement redo-undo feature. This is because the stack is implemented with LIFO(last in first out) order which is equivalent to redo-undo feature i.e. the last re-do is undo first.</div>",
        "keyword": "Data Structures Misc"
    },
    {
        "question": "Which data structure is most efficient to find the top 10 largest items out of 1 million items stored in file?",
        "answer": [
            "Min heap",
            "Max heap",
            "BST",
            "Sorted array"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Min heap of size 10 is sufficient to find the top 10 largest items. The algorithm can be given as follows:\r\n1. Create the min heap with first 10 items.\r\n2. For each remaining item, check if\r\n   2.1 The item is greater than the item stored in the head of the min heap. \r\n      2.1.1 If yes, replace it with this new item. Balance the min heap.\r\n      2.1.2 If no, do nothing.\r\n\r\nAt last, the min heap will contain the top 10 largest items.</div>",
        "keyword": "Data Structures Misc"
    },
    {
        "question": "The best data structure to check whether an arithmetic expression has balanced parentheses is a  (GATE CS 2004)",
        "answer": "None",
        "correct": "None",
        "explain": "None",
        "keyword": "Data Structures Misc"
    },
    {
        "question": "A data structure is required for storing a set of integers such that each of the following operations can be done in (log n) time, where n is the number of elements in the set. \r\n\r\n   o\tDelection of the smallest element \r\n   o\tInsertion of an element if it is not already present in the set\r\n   \r\nWhich of the following data structures can be used for this purpose? ",
        "answer": [
            "A heap can be used but not a balanced binary search tree ",
            " A balanced binary search tree can be used but not a heap ",
            "Both balanced binary search tree and heap can be used ",
            "Neither balanced binary search tree nor heap can be used "
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> A <a href=\"http://en.wikipedia.org/wiki/Self-balancing_binary_search_tree\">self-balancing balancing binary search tree</a> containing n items allows the lookup, insertion, and removal of an item in O(log n) worst-case time.  Since it's a BST, we can easily find out minimum element in O(nlogn). See our post <a href=\"https://www.geeksforgeeks.org/find-the-minimum-element-in-a-binary-search-tree/\">Find the minimum element in a Binary Search Tree</a> for details.\r\n\r\nSince <a href=\"http://en.wikipedia.org/wiki/Binary_heap\">Heap </a> is a balanced binary tree (or almost complete binary tree), insertion complexity for heap is O(logn). Also complexity to get minimum in a min heap is O(logn) because removal of root node causes a call to <a href=\"http://www.cs.virginia.edu/~luebke/cs332.fall00/lecture4/index.htm\">heapify</a> (after removing the first element from the array) to maintain the heap tree property.  But a heap cannot be used for the above purpose as the question says - insert an element if it is not already present.  For a heap, we cannot find out in O(logn) if an element is present or not. Thanks to game for providing the correct solution.</div>",
        "keyword": "Data Structures Misc"
    },
    {
        "question": "The most appropriate matching for the following pairs",
        "answer": "None",
        "correct": "None",
        "explain": "None",
        "keyword": "Data Structures Misc"
    },
    {
        "question": "Which among the following data structures is best suited for storing very large numbers (numbers that cannot be stored in long long int).  Following are the operations needed for these large numbers.",
        "answer": [
            "Array",
            "Linked List",
            "Binary Tree",
            "Hash"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> The only two choices that make sense are Array and Linked List.  Since array sizes are limited, they can create problems for following operations.\r\n\r\nX = X*Y where X and Y are very large numbers.\r\n\r\n</div>",
        "keyword": "Data Structures Misc"
    },
    {
        "question": "Which data structure is best suited for converting recursive implementation to iterative implementation of an algorithm?",
        "answer": [
            "Queue",
            "Stack",
            "Tree",
            "Graph"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Since function calls are executed in <strong>L</strong>ast <strong>I</strong>n <strong>F</strong>irst <strong>O</strong>ut order, stack is the data structure for converting recursive to iterative implementation.</div>",
        "keyword": "Data Structures Misc"
    },
    {
        "question": "Consider a situation where a client receives packets from a server.  There may be differences in speed of the client and the server.  Which data structure is best suited for synchronization?",
        "answer": [
            "Circular Linked List",
            "Queue",
            "Stack",
            "Priority Queue"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Since packets need to be processed in First In First Out order, a queue can be used for synchronization.</div>",
        "keyword": "Data Structures Misc"
    },
    {
        "question": "Which of the following data structures is best suited for efficient implementation of priority queue?",
        "answer": [
            "Array",
            "Linked List",
            "Heap",
            "Stack"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Refer <a href=\"http://geeksquiz.com/binary-heap/\">http://geeksquiz.com/binary-heap/</a></div>",
        "keyword": "Data Structures Misc"
    },
    {
        "question": "Which data structure in a compiler is used for managing information about variables and their attributes?",
        "answer": [
            "Abstract syntax tree",
            "Symbol table",
            "Semantic stack",
            "Parse Table"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> <a href=\"http://en.wikipedia.org/wiki/Symbol_table\" target=\"_blank\">Symbol table</a> is a data structure used by a language translator such as a compiler or interpreter, where each identifier in a program's source code is associated with information relating to its declaration or appearance in the source, such as its type, scope level and sometimes its location (Source: <a href=\"http://en.wikipedia.org/wiki/Symbol_table\">http://en.wikipedia.org/wiki/Symbol_table</a>)\r\n\r\n\r\n<iframe allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen=\"\" frameborder=\"0\" height=\"315\" src=\"https://www.youtube.com/embed/xcubPntmL3Y?start=1743\" title=\"YouTube video player\" width=\"560\"></iframe></div>",
        "keyword": "Data Structures Misc"
    },
    {
        "question": "An Abstract Data Type (ADT) is:",
        "answer": [
            "Same as an abstract class",
            "A data type that cannot be instantiated",
            "A data type type for which only the operations defined on it can be used, but none else",
            "All of the above "
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> See <a href=\"http://en.wikipedia.org/wiki/Abstract_data_type\" target=\"_blank\">http://en.wikipedia.org/wiki/Abstract_data_type</a>\n</div>",
        "keyword": "Data Structures Misc"
    },
    {
        "question": " A data structure is required for storing a set of integers such that each of the following operations can be done in (log n) time, where n is the number of elements in the set. ",
        "answer": "None",
        "correct": "None",
        "explain": "None",
        "keyword": "Data Structures Misc"
    },
    {
        "question": "A Young tableau is a 2D array of integers increasing from left to right and from top to bottom. Any unfilled entries are marked with ∞, and hence there cannot be any entry to the right of, or below a ∞. The following Young tableau consists of unique entries.\r\n\r\n1     2     5      14\r\n3     4     6      23       \r\n10    12    18     25  \r\n31    ∞     ∞       ∞ \r\nWhen an element is removed from a Young tableau, other elements should be moved into its place so that the resulting table is still a Young tableau (unfilled entries may be filled in with a ∞). The minimum number of entries (other than 1) to be shifted, to remove 1 from the given Young tableau is ____________",
        "answer": [
            "2",
            "5",
            "6",
            "18"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Initially\r\n<pre>\r\n<strong>1</strong>     2     5      14\r\n3     4     6      23       \r\n10    12    18     25  \r\n31    ∞     ∞       ∞ </pre>\r\n\r\nWhen 1 is removed, it is replaced by the smallest adjacent which is 2. \r\n<pre>\r\n2     <strong>2</strong>     5      14\r\n3     4     6      23       \r\n10    12    18     25  \r\n31    ∞     ∞       ∞ </pre>\r\n\r\nWhen 2 is moved in place of 1, it is replaced by smallest adjacent which is 4\r\n<pre>\r\n2     4     5      14\r\n3     <strong>4</strong>     6      23       \r\n10    12    18     25  \r\n31    ∞     ∞       ∞ </pre>\r\n\r\nWhen 4 is moved in place of 2, it is replaced by smallest adjacent which is 6\r\n<pre>\r\n2     4     5      14\r\n3     6     <strong>6</strong>      23       \r\n10    12    18     25  \r\n31    ∞     ∞       ∞ </pre>\r\n\r\nWhen 6 is moved in place of 4, it is replaced by smallest adjacent which is 18.\r\n<pre>\r\n2     4     5      14\r\n3     6     18     23       \r\n10    12    <strong>18</strong>     25  \r\n31    ∞     ∞       ∞ </pre>\r\n\r\nWhen 18 is moved in place of 6, it is replaced by smallest adjacent which is 25.\r\n<pre>\r\n2     4     5      14\r\n3     6     18     23       \r\n10    12    25     <strong>25</strong>  \r\n31    ∞     ∞       ∞ </pre>\r\n\r\nWhen 25 is moved in place of 18, it is replaced by smallest adjacent which is  ∞.\r\n<pre>\r\n2     4     5      14\r\n3     6     18     23       \r\n10    12    25      ∞  \r\n31    ∞     ∞       ∞ </pre>\r\n\r\nShifted numbers are  2, 4, 6, 18, 25\r\n</div>",
        "keyword": "Data Structures Misc"
    },
    {
        "question": "What is the value of \r\n\r\n ",
        "answer": [
            "-1",
            "1",
            "0",
            "π"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> <p>In the above  integral </p>\n<p>f(x) = (x- π)^3 (sinx)</p>\n<p>f(2π - x) = (2π - x - π)^3 (sinx)</p>\n<p>              = (π - x )^3 (sinx)</p>\n<p>              =  -( x - π  )^3 (sinx)</p>\n<p>               =-f(x)</p>\n<p>so ,  ∫ (x- π)^3 (sinx) dx =1</p>\n<p>since , </p>\n<p>  ∫f(x)dx= 1</p>\n<p>whenever f(2π - x)  = -f(x)</p>\n<p>hence option B is correct</p></div>",
        "keyword": "Data Structures Misc"
    },
    {
        "question": "A language L is a subset of Pascal with the following constructs:\r\n\r\na). Expressions involving the operators '+' and '<' only\r\nb). Assignment statements\r\nc). 'while' statements and\r\nd). Compound statements with the syntax 'begin..............end'\r\n\r\nGive an unambiguous grammar for L.",
        "answer": "None",
        "correct": "None",
        "explain": "None",
        "keyword": "Data Structures Misc"
    },
    {
        "question": "Consider the following program fragment in Pascal:\r\nProgram Main;\r\n    var X : integer;\r\n    procedure A:\r\n       var Y : integer;\r\n    procedure B:\r\n       var Z : integer;\r\n    procedure C:\r\n       var Z : integer;\r\n    begin(*Procedure C*)\r\n    .\r\n    .\r\n    end(*Procedure C*)\r\n begin(*Procedure B*)\r\n    .\r\n    .\r\n C; (*call to C*)\r\n A; (*call to A*)\r\n        .\r\n        .\r\n\r\n end(*Procedure B*)\r\n begin(*Procedure A*)\r\n        .\r\n        .\r\n        B; (*call to B*)\r\n        .\r\n        .\r\n  end(*Procedure A*)\r\nbegin (*Main*)\r\n\r\nAssume that there are no calls to any procedures other than the ones indicated above. It is known that at some point of time during the execution of this program five activation records exist on the run-time stack. Describe the run-time stack at this point of time by clearly indicating the following: the top of the stack, the contents of the static link and dynamic link, and allocation of the local variables in each record.",
        "answer": "None",
        "correct": "None",
        "explain": "None",
        "keyword": "Data Structures Misc"
    },
    {
        "question": "Match the pairs in the following questions:\r\n\n",
        "answer": [
            "A – 2, B – 1, C – 4, D – 3 ",
            "A – 3, B – 4, C – 1, D – 2 ",
            "A – 3, B – 1, C – 4, D – 2 ",
            "A – 2, B – 4, C – 1, D – 3 "
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Correct matching is A – 3, B – 1, C – 4, D – 2 \r\nOption (C) is correct.</div>",
        "keyword": "Data Structures Misc"
    },
    {
        "question": "Consider a 2D-array  A[10][20] using row major order in memory and the memory location we want to access is A[y, z]. Known that each memory address occupies 4-bytes.\r\nBelow is the 3-address code for the same, fill the blank spaces with correct value :\r\n\r\nx : A[y, z]\r\n\r\nt1 = ---(1)--- * ---(2)---\r\nt2 = t1  +  z\r\nt3 = t2  *  ---(3)---\r\n---(4)--- = base address of A\r\nx = t4[---(5)---]\r\n\n",
        "answer": [
            "(1) : x\r\n(2) : 10\r\n(3) : 4\r\n(4) : t4\r\n(5) : t3",
            "(1) : y\r\n(2) : 10\r\n(3) : t4\r\n(4) : 4\r\n(5) : t3",
            "(1) : y\r\n(2) : 20\r\n(3) : 4\r\n(4) : t4\r\n(5) : t3",
            "None of these"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> (1) : y\r\n(2) : 20\r\n(3) : 4\r\n(4) : t4\r\n(5) : t3</div>",
        "keyword": "Data Structures Misc"
    },
    {
        "question": "The number of possible min-heaps containing each value from {1, 2, 3, 4, 5, 6, 7} exactly once is _______.\r\n\r\n\r\nNote -This was Numerical Type question.",
        "answer": [
            "80",
            "8",
            "20",
            "210"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Set minimum element as root (i.e <strong>1</strong>), now 6 are remaining and left subtree will have 3 elements, each left subtree combination can be permuted in 2! ways.\r\n\r\nTotal ways to design min-heap with 7-elements = <img alt=\"^6C_3 \" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"28\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-099502d06a6f2e2d140221dfc77286cf_l3.png\" style=\"vertical-align: -4px;\" title=\"Rendered by QuickLaTeX.com\" width=\"40\"/> *2! * 2! = 20*2*2 = <b>80</b>\n<b>Alternative approach -</b> Total number of min or max heap tree with 1 to N elements are using recurrence relation:\r\n<pre>\r\nT(N) =(N-1)Ck * T(k) * T(N-k-1), where k = number of nodes on left subtree\r\n\r\nT(1) = 1\r\nT(2) = 1\r\nT(3) = 2\r\nT(4) = 3C2 * T(2) * T(1) = 3\r\nT(5) = 4C3 * T(3) * T(1) = 8\r\nT(6) = 5C3 * T(3) * T(2) = 20\r\nT(7) = 5C3 * T(3) * T(3) = 80\r\n</pre>\r\n\r\nSo, answer is 80.\r\n\r\n\r\n</div>",
        "keyword": "Data Structures Misc"
    },
    {
        "question": "Let G be a simple undirected graph. Let TD be a depth first search tree of G. Let TB be a breadth first search tree of G. Consider the following statements.\r\n\r\n(I) No edge of G is a cross edge with respect to TD. (A cross edge in G is between two nodes neither of which is an ancestor of the other in TD).\r\n\r\n(II) For every edge (u, v) of G, if u is at depth i and v is at depth j in TB, then ∣i − j∣ = 1.\r\n\r\nWhich of the statements above must necessarily be true?\r\n\r\n\r\n\r\n",
        "answer": [
            "I only",
            "II only",
            "Both I and II",
            "Neither I nor II"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> There are four types of edges can yield in DFS. These are tree, forward, back, and cross edges. In undirected connected graph, forward and back egdes are the same thing. A cross edge in a graph is an edge that goes from a vertex v to another vertex u such that u is neither an ancestor nor descendant of v. Therefore, cross edge is not possible in undirected graph.\r\nSo, statement (I) is correct.\r\n \r\nFor statement (II) take counterexample of complete graph of three vertices, i.e., K3 with XYZ, where X is source and Y and Z are in same level. Also,there is an edge between vertices Y and Z, i.e., |i-j| = 0 ≠ 1 in BFS. So, statement became false.\r\n\r\nOption (A) is correct.\r\n</div>",
        "keyword": "Data Structures Misc"
    },
    {
        "question": "A list of n strings, each of length n, is sorted into lexicographic order using merge - sort algorithm. The worst case running time of this computation is :\r\n",
        "answer": [
            "O(n log n)",
            "O(n2log n)",
            "O(n2 + log n)",
            "O(n3)"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Refer: <a href=\"https://www.geeksforgeeks.org/gate-gate-cs-2012-question-39/\" rel=\"noopener\" target=\"_blank\"></a> <a href=\"https://www.geeksforgeeks.org/gate-gate-cs-2012-question-39/\" rel=\"noopener\" target=\"_blank\">GATE-CS-2012 | Question 37</a>\r\n\r\nOption (B) is correct.</div>",
        "keyword": "Data Structures Misc"
    },
    {
        "question": "Heap allocation is required for languages that",
        "answer": [
            "use dynamic scope rules",
            "support dynamic data structures",
            "support recursion",
            "support recursion and dynamic data structures"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Heap allocation is required for the languages which support dynamic data structure.\r\n\r\nSo, option (B) is correct.</div>",
        "keyword": "Data Structures Misc"
    },
    {
        "question": "If h is chosen from a universal collection of hash functions and is used to hash n keys into a table of size m, where n ≤ m, the expected number of collisions involving a particular key x is less than _______. ",
        "answer": [
            "1",
            "1/n",
            "1/m",
            "n/m"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> <b>Universal hashing</b> states that:- If h is chosen from a universal collection of hash functions and is used to hash n keys into a table of size m, where n ≤ m, the expected number of collisions involving a particular key x is less than 1. \r\nSo, option (A) is correct.</div>",
        "keyword": "Data Structures Misc"
    },
    {
        "question": "Below are the few steps given for scan-converting a circle using Bresenham’s Algorithm. Which of the given steps is not correct ?",
        "answer": [
            "Compute d = 3 – 2r (where r is radius)",
            "Stop if x > y",
            "If d < 0, then d = 4x + 6 and x = x + 1",
            "If d ≥ 0, then d = 4 ∗ (x – y) + 10, x = x + 1 and y = y + 1"
        ],
        "correct": "D",
        "explain": "None",
        "keyword": "Data Structures Misc"
    },
    {
        "question": "Consider a line AB with A = (0, 0) and B = (8, 4). Apply a simple DDA algorithm and compute the first four plots on this line.",
        "answer": [
            "[(0, 0), (1, 1), (2, 1), (3, 2)]",
            "[(0, 0), (1, 1.5), (2, 2), (3, 3)]",
            "[(0, 0), (1, 1), (2, 2.5), (3, 3)]",
            "[(0, 0), (1, 2), (2, 2), (3, 2)]"
        ],
        "correct": "A",
        "explain": "None",
        "keyword": "Data Structures Misc"
    },
    {
        "question": "The minimum number of scalar multiplication required, for parenthesization of a matrix-chain product whose sequence of dimensions for four matrices is <5, 10, 3, 12, 5> is",
        "answer": [
            "630",
            "580",
            "480",
            "405"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> Minimum number of scalar multiplication:\r\n<img alt=\"34\" class=\"alignnone size-medium wp-image-191371\" src=\"https://www.geeksforgeeks.org/wp-content/uploads/34-1.png\"/>\r\n405 multiplication is minimum.\r\nSo, option (D) is correct.</div>",
        "keyword": "Data Structures Misc"
    },
    {
        "question": "Consider the following AO graph:\r\n\r\nWhich is the best node to expand next by AO* algorithm?",
        "answer": [
            "A",
            "B",
            "C",
            "B and C"
        ],
        "correct": "A",
        "explain": "None",
        "keyword": "Data Structures Misc"
    },
    {
        "question": "A t-error correcting q-nary linear code must satisfy:\r\n\r\nWhere M is the number of code words and X is",
        "answer": [
            "qn",
            "qt",
            "q-n",
            "q-t"
        ],
        "correct": "A",
        "explain": "None",
        "keyword": "Data Structures Misc"
    },
    {
        "question": "Consider the following statements:\r\nS1: A queue can be implemented using two stacks.\r\nS2: A stack can be implemented using two queues.\r\nWhich of the following is correct?",
        "answer": [
            "S1 is correct and S2 is not correct.",
            "S1  is not correct and S2 is correct.",
            "Both S1 and S2 are correct.",
            "Both S1 and S2 are incorrect."
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> A queue can be implemented using minimum two stacks.\r\nA stack can be implemented using minimum two queues.\r\nBoth statement are true.\r\nSo, option (C) is correct.\r\n</div>",
        "keyword": "Data Structures Misc"
    },
    {
        "question": "Given the following prefix expression:\r\n* + 3 + 3 ↑ 3 + 3 3 3\r\nWhat is the value of the prefix expression ?",
        "answer": [
            "2178",
            "2199",
            "2205",
            "2232"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> We have prefix expression:\r\n<pre>* + 3 + 3 ↑ 3 + 3 3 3\r\n= * + 3 + 3 ↑ 3 6 3\r\n= * + 3 + 3 729 3\r\n= * + 3 732 3\r\n= * 735 3\r\n= 2205</pre>\r\nSo, option (C) is correct.\r\n</div>",
        "keyword": "Data Structures Misc"
    },
    {
        "question": "In how many ways can the string\r\nA ∩ B – A ∩ B – A\r\nbe fully parenthesized to yield an infix expressionp?",
        "answer": [
            "15",
            "14",
            "13",
            "12"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Formula is :- \r\n\r\n1/N * 2(N-1)C(N-1)\r\n\r\nWhere N is number of operands in the expression A ∩ B – A ∩ B – A\r\n\r\ni.e 5 \r\n\r\nHence ,\r\n\r\n=1/5 * 8C4\r\n\r\n=14\r\n\r\nHence option B is correct</div>",
        "keyword": "Data Structures Misc"
    },
    {
        "question": "Consider a source with symbols A, B, C, D with probabilities 1/2, 1/4, 1/8, 1/8 respectively. What is the average number of bits per symbol for the Huffman code generated from above information ?",
        "answer": [
            "2 bits per symbol",
            "1.75 bits per symbol",
            "1.50 bits per symbol",
            "1.25 bits per symbol"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> <img alt=\"59\" class=\"alignnone size-medium wp-image-195544\" src=\"https://www.geeksforgeeks.org/wp-content/uploads/59.png\"/>\r\nBits required per symbol:\r\nA - 0 (1 bit)\r\nB - 10 (2 bit)\r\nC - 110 (3 bit)\r\nD - 111 (3 bit)\r\nAverage number of bits per symbol = 1 * 1 / 2 + 2 * 1 / 4 + 3 * 1 / 8 + 3 * 1 / 8 = 7 / 4 = 1.75.\r\nSo, option (B) is correct.</div>",
        "keyword": "Data Structures Misc"
    },
    {
        "question": "Match the following:\r\n\n",
        "answer": [
            "(1)",
            "(2)",
            "(3)",
            "(4)"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> <ul><li>Forword reference table used linked list data structure.</li><li>Mnemonic table contains machine OP code.</li><li>Segment Register table uses array data structure.</li><li>EQU is assembler directive.</li></ul>\r\nSo, option (D) is correct.</div>",
        "keyword": "Data Structures Misc"
    },
    {
        "question": "A symbol table of length 152 is processing 25 entries at any instant. What is occupation density?",
        "answer": [
            "0.164",
            "127",
            "8.06",
            "6.08"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>Occupation Density = Number of entries/ Length of symbol table\r\n                   = 25 / 152\r\n                   = 0.164</pre>\r\n\r\nOption (A) is correct.</div>",
        "keyword": "Data Structures Misc"
    },
    {
        "question": "Given the symbols A, B, C, D, E, F, G and H with the probabilities 1 / 30, 1 / 30, 1 / 30, 2 / 30, 3 / 30, 5 / 30, 5 / 30, and 12 / 30 respectively. The average Huffman code size in bits per symbol is:",
        "answer": [
            "67 / 30 ",
            "70 / 30",
            "76 / 30",
            "78/ 30"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> <img alt=\"\" class=\"alignnone size-medium wp-image-206577\" src=\"https://www.geeksforgeeks.org/wp-content/uploads/Screenshot-from-2018-06-20-155447.png\"/>\r\nA - 10100 - 5 bits \r\nB - 10101 - 5 bits\r\nC -  1100 - 4 bits\r\nD -  1101 - 4 bits\r\nE -  1011 - 4 bits\r\nF -   100 - 3 bits\r\nG -   111 - 3 bits\r\nH -     0 - 1 bit\r\naverage Huffman code size =  5 * (1 / 30 ) + 5 * (1 / 30 ) + 4 * (2 / 30 ) + 4 * (3 / 30 ) + 3 * (5 / 30 ) + 3 * (5 / 30 ) + 1 * (12 / 30 ) = 76 / 30.\r\nSo, option (D) is correct.\r\n</div>",
        "keyword": "Data Structures Misc"
    },
    {
        "question": "A 5-ary tree is tree in which every internal node has exactly 5 children. The number of left nodes in such a tree with 8 internal nodes will be:",
        "answer": [
            "30",
            "33",
            "45",
            "130"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> In a complete n-ary tree,\r\n\r\nnumber of leaf (L)  node will be :- \r\n\r\n L=(n−1)∗I+1  \r\n\r\n where ,\r\n\r\nL = No. of leaf nodes \r\n\r\nI = No. of Internal nodes=8\r\n\r\nn= order of tree =5\r\n\r\nTherefore, \r\n\r\n L = (5-1) * 8 + 1 = 4 * 8 + 1 = 33\r\n\r\nHence option B is correct</div>",
        "keyword": "Data Structures Misc"
    },
    {
        "question": "Consider the following two sentences :\r\n(a) The planning graph data structure can be used to give a better heuristic for a planning problem.\r\n(b) Dropping negative effects from every action schema in a planning problem results in a relaxed problem.\r\nWhich of the following is correct with respect to the above sentences ?",
        "answer": [
            "Both sentence (a) and sentence (b) are false.",
            "Both sentence (a) and sentence (b) are true.",
            "Sentence (a) is true but sentence (b) is false.",
            "Sentence (a) is false but sentence (b) is true."
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> <li>The planning graph data structure can be used to give a better heuristic for a planning problem.<strong>True</strong></li>\n<li>Dropping negative effects from every action schema in a planning problem results in a relaxed problem.<strong>True</strong></li> \r\nSo, option (B) is correct.</div>",
        "keyword": "Data Structures Misc"
    },
    {
        "question": "Question",
        "answer": [
            "1",
            "2",
            "3",
            "4"
        ],
        "correct": "B",
        "explain": "None",
        "keyword": "Data Structures Misc"
    },
    {
        "question": "Consider double hashing of the form\r\nh(k,i)=(h​ 1​ (k)+ih​ 2​ (k)) mod m\r\nWhere h​ 1​ (k)=k mod m\r\nh​ 2​ (k)=1+(k mod n)\r\nWhere n=m-1and m=701\r\nfor k=123456, what is the difference between first and second probes in terms of slots?",
        "answer": [
            "255",
            "256",
            "257",
            "258"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Given that \r\n\r\n=&gt; h(k, i) = (h1(k)+ih2 (k)) mod m\r\n=&gt; Where h​1​(k)=k mod m,\r\n   h​2​ (k)=1+(k mod n)\r\n   n=m-1, \r\n   m=701 \r\n   k = 123456\r\n\r\nNow,\r\n\r\n=&gt; h1(k) = 123456 mod 701 = 80\r\n=&gt; h2(k) = 1 + (123456 mod 700) = 1 + 256 = 257\r\n\r\n1st probe: when i =1\r\n\r\n=&gt; h(k, i) = h1(k) + ih2(k)\r\n=&gt; h(k, 1) = h1(k) + h2(k) = 80 + 257 = 337\r\n\r\n2nd probe: when i =2\r\n\r\n=&gt; h(k,2) = h1(k) + 2*h2(k) \r\n          = 80 + 2*257\r\n\r\n=&gt; h(k,2) = 80 + 514 = 594\r\n\r\nSo, difference between first two probes = 594 – 337\r\n                                        = 257\r\n=&gt; Option C is answer.</div>",
        "keyword": "Data Structures Misc"
    },
    {
        "question": "Consider a B+-tree in which the maximum number of keys in a node is 5. What is the minimum number of keys in any non-root node? (GATE CS 2010)",
        "answer": [
            "1",
            "2",
            "3",
            "4"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Since the maximum number of keys is 5, maximum number of children a node can have is 6. By<a href=\"http://en.wikipedia.org/wiki/B-tree#Definition\">definition of B Tree</a>, minimum children that a node can have would be 6/2 = 3. Therefore, minimum number of keys that a node can have becomes 2 (3-1).</div>",
        "keyword": "B and B+ Trees"
    },
    {
        "question": "Which one of the following is a key factor for preferring B-trees to binary search trees for indexing database relations?",
        "answer": [
            "Database relations have a large number of records",
            "Database relations are sorted on the primary key",
            "B-trees require less memory than binary search trees",
            "Data transfer form disks is in blocks."
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> A disk block contains fairly large number of keys. Unlike BST where each node contains only one key, B-Tree is designed to contain large number of keys so that tree height is small.</div>",
        "keyword": "B and B+ Trees"
    },
    {
        "question": "B+ trees are preferred to binary trees in databases because (GATE CS 2000)",
        "answer": "None",
        "correct": "None",
        "explain": "None",
        "keyword": "B and B+ Trees"
    },
    {
        "question": "Which of the following is FALSE about B/B+ tree",
        "answer": [
            "B/B+ trees grow upward while Binary Search Trees grow downward.",
            "Time complexity of search operation in B/B+ tree is better than Red Black Trees in general.",
            "Number of child pointers in a B/B+ tree node is always equals to number of keys in it plus one.",
            "A B/B+ tree is defined by a term minimum degree.  And minimum degree depends on hard disk block size, key and address sizes."
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Asymptotic time complexity of both is of order logn.  </div>",
        "keyword": "B and B+ Trees"
    },
    {
        "question": "A B-tree of order 4 is built from scratch by 10 successive insertions. What is the maximum number of node splitting operations that may take place?",
        "answer": [
            "3",
            "4",
            "5",
            "6"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>Insertion of 3 keys\r\n10 20 30\r\n\r\nInsertion of 4th key (1st split)\r\n     30\r\n   /   \\\r\n10*20   40\r\n\r\n\r\nInsertion of 5th key no split \r\nTo maximize splits, let us insert a value in a node that has\r\nkey in access. Let us insert 5\r\n      30\r\n   /     \\\r\n5*10*20   40\r\n\r\n\r\nInsertion of 6th key (2nd Split)\r\nTo maximize splits, let us insert a value in a node that has\r\nkey in access. Let us insert 6\r\n      8*30\r\n   /   |   \\\r\n5    10*20   40 \r\n\r\n\r\nInsertion of 7th key\r\nTo maximize splits, let us insert a value in a node that has\r\nkey in access. Let us insert 15\r\n        8*30\r\n   /     |    \\\r\n5    10*15*20   40 \r\n\r\n\r\n\r\nInsertion of 8th key (3rd Split)\r\nTo maximize splits, let us insert a value in a node that has\r\nkey in access. Let us insert 12\r\n      8*12*30\r\n   /   /   \\  \\\r\n 5   10 15*20  40 \r\n\r\n\r\nInsertion of 9th key \r\nTo maximize splits, let us insert a value in a node that has\r\nkey in access. Let us insert 17\r\n      8*12*30\r\n   /  /   \\   \\\r\n5  10 15*17*20 40 \r\n\r\nInsertion of 10th key (4th and 5th Splits)\r\nTo maximize splits, let us insert a value in a node that has\r\nkey in access. Let us insert 13\r\n          12\r\n       /      \\\r\n      8       15*30\r\n   /   \\     /  |  \\  \r\n  5    10  13 17*20   40 \r\n</pre>\n</div>",
        "keyword": "B and B+ Trees"
    },
    {
        "question": "The order of a leaf node in a tree B+ ? is the maximum number of (value, data record pointer) pairs it can hold. Given that the block size is 1K bytes, data record pointer is 7 bytes long, the value field is 9 bytes long and a block pointer is 6 bytes long, what is the order of the leaf node? ",
        "answer": [
            "63",
            "64",
            "67",
            "68"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>\r\n  Disk Block size = 1024 bytes\r\n  \r\n  Data Record Pointer size, r = 7 bytes\r\n  Value size, V = 9 bytes\r\n  Disk Block ptr, P = 6 bytes </pre>\r\n\r\nLet order of leaf be m. A leaf node in <a href=\"http://en.wikipedia.org/wiki/B%2B_tree\">B+ tree</a> contains at most m record pointers, at most m values, and one disk block pointer.\r\n</div>",
        "keyword": "B and B+ Trees"
    },
    {
        "question": "The order of an internal node in a B+ tree index is the maximum number of children it can have. Suppose that a child pointer takes 6 bytes, the search field value takes 14 bytes, and the block size is 512 bytes. What is the order of the internal node?",
        "answer": [
            "24",
            "25",
            "26",
            "27"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> <br/>\r\nKey size = 14 bytes (given)\r\n \r\nChild pointer = 6 bytes (given)\r\n<br/>\r\nWe assume the order of B+ tree to be ‘n’. \r\n<br/>\r\nBlock size = (n - 1) * key size + n * child pointer\r\n512 &gt;= (n - 1) * 14 + n * 6\r\n512 &gt;= 14 * n – 14 + 6 * n\r\nn = (512 + 14) / 20\r\nn = 526 / 20\r\nn = 26.3\r\nn = 26\r\n\r\n<br/> <br/>\r\nThus, option (C) is correct.\r\n<br/> <br/>\r\nPlease comment below if you find anything wrong in the above post.\r\n</div>",
        "keyword": "B and B+ Trees"
    },
    {
        "question": "Consider the following 2-3-4 tree (i.e., B-tree with a minimum degree of two) in which each data item is a letter. The usual alphabetical ordering of letters is used in constructing the tree.\r\n\r\nWhat is the result of inserting G in the above tree ?\r\n\r\n\r\nA) \r\n\r\nB) \r\n\r\nC) \r\n\r\nD) None of the above\r\n",
        "answer": [
            "A",
            "B",
            "C",
            "D"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Since the given B tree is 2-3-4 tree, there can be at-most 4 children or 3 keys.\r\n\r\nIn <a href=\"http://www.geeksforgeeks.org/b-tree-set-1-insert-2/\" target=\"_blank\">B Tree insertion</a>, we start from root and traverse till the leaf node where key is to be inserted.  While traversing, if we find a a node which full, we split it.  When we insert G, we find root itself is full, so we split it.  When we come down to leftmost leaf, we find that the leaf is also full, so we split the leaf also. </div>",
        "keyword": "B and B+ Trees"
    },
    {
        "question": "A B+ -tree index is to be built on the Name attribute of the relation STUDENT. Assume that all student names are of length 8 bytes, disk block are size 512 bytes, and index pointers are of size 4 bytes. Given this scenario, what would be the best choice of the degree (i.e. the number of pointers per node) of the B+ -tree?",
        "answer": [
            "16",
            "42",
            "43",
            "44"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>Size of 1 record = 8 + 4 = 12\r\n\r\nLet the order be N.\r\n\r\nNo. of index values per block = N - 1\r\n\r\n(N - 1) 12 + 4 = 512\r\n\r\n12N - 12 + 4 = 512\r\n\r\n16N = 1009\r\n\r\nN = 43.3333</pre>\n</div>",
        "keyword": "B and B+ Trees"
    },
    {
        "question": "With reference to the B+ tree index of order 1 shown below, the minimum number of nodes (including the root node) that must be fetched in order to satisfy the following query: “Get all records with a search key greater than or equal to 7 and less than 15” is ________\r\n\r\n",
        "answer": [
            "4",
            "5",
            "6",
            "7"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>\r\nWe can get all values in range from 7 to 59 by accessing 5 nodes.  \r\n1) First search 7 in a leaf node.\r\n2) Once 7 is found, linearly traverse till 15 is found.\r\n\r\nSee following diagram </pre>\n<a href=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2015/04/Q12-300x101.png\"><img alt=\"Q12-300x101\" class=\"alignnone size-full wp-image-16391\" height=\"101\" src=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2015/04/Q12-300x101.png\" width=\"300\"/></a></div>",
        "keyword": "B and B+ Trees"
    },
    {
        "question": "Consider B+ tree in which the search key is 12 bytes long, block size is 1024 bytes, record pointer is 10 bytes long and block pointer is 8 bytes long. The maximum number of keys that can be accommodated in each non-leaf node of the tree is",
        "answer": [
            "49",
            "50",
            "51",
            "52"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>\r\nLet m be the order of B+ tree\r\n\r\nm(8)+(m-1)12 &lt;= 1024  \r\n[Note that record pointer is not needed in non-leaf nodes]\r\n\r\nm &lt;= 51\r\n\r\nSince maximum order is 51, maximum number of keys is 50. </pre></div>",
        "keyword": "B and B+ Trees"
    },
    {
        "question": "A B-Tree used as an index for a large database table has four levels including the root node. If a new key is inserted in this index, then the maximum number of nodes that could be newly created in the process are:\n\n",
        "answer": [
            "5",
            "4",
            "3",
            "2"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Number of children of a node is equal to the number of keys in it plus 1.\r\n\r\nGiven tree has 4 levels, the tree will be increased with one more level if a new key is inserted.</div>",
        "keyword": "B and B+ Trees"
    },
    {
        "question": "B+ Trees are considered BALANCED because\r\n",
        "answer": [
            "the lengths of the paths from the root to all leaf nodes are all equal.",
            "the lengths of the paths from the root to all leaf nodes differ from each other by at most 1.",
            " the number of children of any two non-leaf sibling nodes differ by at most 1.",
            "the number of records in any two leaf nodes differ by at most 1."
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> In both B Tree and B+ trees, depth (length of root to leaf paths) of all leaf nodes is same. This is made sure by the insertion and deletion operations.\r\n\r\nIn these trees, we do insertions in a way that if we have increase height of tree after insertion, we increase height from root. This is different from BST where height increases from leaf nodes.\r\n\r\nSimilarly, if we have to decrease height after deletion, we move the root one level down. This is also different from BST which shrinks from bottom.\r\n\r\nThe above ways of insertion and deletion make sure that depth of every leaf node is same.\r\n\r\nYou can refer below links for more details.\r\n\r\n<a href=\"https://www.youtube.com/watch?v=VbVroFR4mq4\">IIT Delhi Video Lecture </a>\n<a href=\"http://www.geeksforgeeks.org/b-tree-set-1-introduction-2/\">B Tree Introduction </a>\n<a href=\"http://www.geeksforgeeks.org/b-tree-set-1-insert-2/\">B Tree Insertion</a>\n<a href=\"http://www.geeksforgeeks.org/b-tree-set-3delete/\">B Tree Deletion</a></div>",
        "keyword": "B and B+ Trees"
    },
    {
        "question": "Which of the following is correct?",
        "answer": [
            "B-trees are for storing data on disk and B+ trees are for main memory.",
            "Range queries are faster on B+ trees.",
            "B-trees are for primary indexes and B+ trees are for secondary indexes.",
            "The height of a B+ tree is independent of the number of records."
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Option (A) is False because  both  B-trees  and B+ trees are for storing data on disk\r\n\r\nOption (B) is True because  By searching leaf level linearly in B+ tree, we can say a node is present or not in B+ tree. But for B tree we have to traverse the whole tree and Most of the database system use indexes built on some form of a B+ tree  due to its many advantages, in particular its support for range queries. Leaf nodes are linked together in B+ tree. Hence range queries are faster.\r\n\r\nOption (C) is False because <a href=\"https://www.geeksforgeeks.org/difference-between-b-tree-and-b-tree/\" rel=\"noopener\" target=\"_blank\">B tree and B+ tree</a> uses for dynamic multilevel indexes not for primary or secondary index.\r\n\r\nOption (D) is False because Height depends on number of record as well as max no of keys in each node (i.e. order of tree) .</div>",
        "keyword": "B and B+ Trees"
    },
    {
        "question": "A B-Tree used as an index for a large database table has four levels including the root node. If a new key is inserted in this index, then the maximum number of nodes that could be newly created in the process are",
        "answer": [
            "5",
            "4",
            "1",
            "2"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Refer:<a href=\"https://www.geeksforgeeks.org/gate-gate-it-2005-question-23/\" rel=\"noopener\" target=\"_blank\"> Gate IT 2005 | Question 23</a></div>",
        "keyword": "B and B+ Trees"
    },
    {
        "question": "In a file which contains 1 million records and the order of the tree is 100, then what is the maximum number of nodes to be accessed if B+ tree index is used?\r\n",
        "answer": [
            "5",
            "4",
            "3",
            "10"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> We have to find the maximum no. of nodes to be accessed in B+ tree  so we have to  consider the minimum fill factor.\r\n\r\nHere,\r\n\r\nnumber of record = 1 million = 10^6 (Given )\r\n\r\norder of b+tree= number of pointers per node = p = 100 (Given )\r\n\r\nMinimum pointers per node =⌈ p/ 2⌉ = ⌈ 100/ 2⌉ = 50\r\n\r\nnumber of nodes in last level of tree =10^6 / 50 = 2 * 10^4\r\n\r\nNumber of nodes in Second last level of tree = 2*10^4 / 50  = 400\r\n\r\nNumber of nodes in Third last level of tree = 400/50  =8\r\n\r\nnumber of node in Forth last level of tree = 8/50 =1\r\n\r\nThe maximum no. of nodes to be accessed = number pf B+ tree levels = 4\r\n\r\nHence,  option ( B ) is correct.</div>",
        "keyword": "B and B+ Trees"
    },
    {
        "question": "What is the time complexity of Build Heap operation.  Build Heap is used to build a max(or min) binary heap from a given array.  Build Heap is used in Heap Sort as a first step for sorting.",
        "answer": [
            "O(nLogn)",
            "O(n^2)",
            "O(Logn)",
            "O(n)"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> Following is algorithm for building a Heap of an input array A.\r\n<pre>\r\nBUILD-HEAP(A) \r\n    heapsize := size(A); \r\n    for i := floor(heapsize/2) downto 1 \r\n        do HEAPIFY(A, i); \r\n    end for \r\nEND</pre>\r\nAlthough the worst case complexity looks like O(nLogn), upper bound of time complexity is O(n). See following links for the proof of time complexity.\r\n\r\n<a href=\"https://www.geeksforgeeks.org/time-complexity-of-building-a-heap/\" rel=\"noopener\" target=\"_blank\">Time Complexity of building a heap</a></div>",
        "keyword": "Heap"
    },
    {
        "question": "Suppose we are sorting an array of eight integers using heapsort, and we have just finished some heapify (either maxheapify or minheapify) operations. The array now looks like this:\r\n    16  14  15  10  12  27  28\r\nHow many heapify operations have been performed on root of heap?",
        "answer": [
            "1",
            "2",
            "3 or 4",
            "5 or 6"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> In Heapsort, we first build a heap, then we do following operations till the heap size becomes 1.\r\na) Swap the root with last element\r\nb) Call heapify for root\r\nc) reduce the heap size by 1.  \r\n\r\nIn this question, it is given that heapify has been called few times and we see that last two elements in given array are the 2 maximum elements in array.  So situation is clear, it is maxheapify whic has been called 2 times.</div>",
        "keyword": "Heap"
    },
    {
        "question": " A max-heap is a heap where the value of each parent is greater than or equal to the values of its children. Which of the following is a max-heap? (GATE CS 2011)\r\n\r\n\n",
        "answer": [
            "A",
            "B",
            "C",
            "D"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> See <a href=\"http://www.geeksforgeeks.org/data-structures-and-algorithms-set-26/\">http://www.geeksforgeeks.org/data-structures-and-algorithms-set-26/</a> for explanation.</div>",
        "keyword": "Heap"
    },
    {
        "question": "A 3-ary max heap is like a binary max heap, but instead of 2 children, nodes have 3 children. A 3-ary heap can be represented by an array as follows: The root is stored in the first location, a[0], nodes in the next level, from left to right, is stored from a[1] to a[3]. The nodes from the second level of the tree from left to right are stored from a[4] location onward. An item x can be inserted into a 3-ary heap containing n items by placing x in the location a[n] and pushing it up the tree to satisfy the heap property.\r\n\r\nWhich one of the following is a valid sequence of elements in an array representing 3-ary max heap?",
        "answer": [
            "1, 3, 5, 6, 8, 9",
            "9, 6, 3, 1, 8, 5",
            " 9, 3, 6, 8, 5, 1",
            "9, 5, 6, 8, 3, 1"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> Following 3-ary Max Heap can be constructed from sequence given option (D)\r\n<pre>\r\n                                      9\r\n                                   /  |   \\\r\n                                /     |     \\\r\n                              5       6      8\r\n                           /  |\r\n                         /    |\r\n                       3      1\r\n</pre></div>",
        "keyword": "Heap"
    },
    {
        "question": "Suppose the elements 7, 2, 10 and 4 are inserted, in that order, into the valid 3- ary max heap found in the above question, Which one of the following is the sequence of items in the array representing the resultant heap?\r\n",
        "answer": [
            "10, 7, 9, 8, 3, 1, 5, 2, 6, 4",
            "10, 9, 8, 7, 6, 5, 4, 3, 2, 1",
            "10, 9, 4, 5, 7, 6, 8, 2, 1, 3",
            "10, 8, 6, 9, 7, 2, 3, 4, 1, 5"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> After insertion of 7\r\n<pre>                                          9\r\n                                      /   |   \\\r\n                                    /     |     \\\r\n                                  7       6       8\r\n                               / | \\\r\n                             /   |  \\\r\n                            3    1    5    \r\n</pre>\r\nAfter insertion of 2\r\n\r\n<pre>                                           9\r\n                                      /    |   \\\r\n                                    /      |     \\\r\n                                  7        6       8\r\n                               / | \\       /\r\n                             /   |  \\     /\r\n                            3    1    5  2\r\n</pre>\r\nAfter insertion of 10\r\n<pre>                                 10\r\n                             /    |   \\\r\n                           /      |     \\\r\n                        7         9       8\r\n                    / | \\       / |\r\n                  /   |  \\     /  |\r\n                3    1    5  2    6\r\n</pre>\r\n\r\nAfter insertion of 4\r\n\r\n<pre>                                 10\r\n                             /   |   \\\r\n                           /     |     \\\r\n                         7        9       8\r\n                      / | \\      / | \\\r\n                    /   |  \\    /  |   \\\r\n                  3    1    5  2   6    4\r\n</pre></div>",
        "keyword": "Heap"
    },
    {
        "question": "Consider a binary max-heap implemented using an array. Which one of the following array represents a binary max-heap? (GATE CS 2009)",
        "answer": [
            "25,12,16,13,10,8,14",
            "25,12,16,13,10,8,14",
            "25,14,16,13,10,8,12",
            " 25,14,12,13,10,8,16"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> A tree is max-heap if data at every node in the tree is greater than or equal to it’s children’ s data.\r\n\r\nIn array representation of heap tree,  a node at index i has its left child at index 2i + 1 and right child at index 2i + 2.<pre>\r\n           25\r\n        /      \\\r\n      /          \\\r\n    14            16\r\n   /  \\           /  \\\r\n /      \\       /     \\\r\n13     10      8       12</pre></div>",
        "keyword": "Heap"
    },
    {
        "question": "What is the content of the array after two delete operations on the correct answer to the previous question?",
        "answer": [
            "14,13,12,10,8",
            "14,12,13,8,10",
            "14,13,8,12,10",
            "14,13,12,8,10"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> For Heap trees, deletion of a node includes following two operations.\r\n\r\n1) Replace the root with last element on the last level.\r\n2) Starting from root, heapify the complete tree from top to bottom..\r\n\r\nLet us delete the two nodes one by one:\r\n1) Deletion of 25:\r\nReplace 25 with 12\r\n<pre>\r\n          12\r\n        /    \\\r\n      /       \\\r\n    14        16\r\n   / \\         /\r\n /     \\      /\r\n13     10    8</pre>\r\nSince heap property is violated for root (16 is greater than 12), make 16 as root of the tree.\r\n<pre>\r\n           16\r\n        /     \\\r\n      /        \\\r\n    14         12\r\n   / \\         /\r\n  /   \\       /\r\n13     10    8</pre>\r\n2) Deletion of 16:\r\nReplace 16 with 8\r\n<pre>\r\n           8\r\n        /    \\\r\n       /      \\\r\n    14         12\r\n   / \\\r\n  /   \\\r\n 13     10</pre>\r\nHeapify from root to bottom.\r\n<pre>\r\n           14\r\n         /    \\\r\n       /       \\\r\n     8         12\r\n    / \\\r\n   /   \\\r\n 13     10\r\n            14\r\n         /     \\\r\n        /       \\\r\n     13         12\r\n    / \\\r\n   /   \\\r\n  8    10</pre></div>",
        "keyword": "Heap"
    },
    {
        "question": "We have a binary heap on n elements and wish to insert n more elements (not necessarily one after another) into this heap. The total time required for this is\r\n(A)  (logn)\r\n(B)  (n)\r\n(C) (nlogn)\r\n(D) (n^2)",
        "answer": [
            "A",
            "B",
            "C",
            "D"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> We can reduce the problem to <a href=\"http://www.dgp.toronto.edu/people/JamesStewart/378notes/08buildheap/\">Build Heap</a> for 2n elements. Time taken for <a href=\"http://www.dgp.toronto.edu/people/JamesStewart/378notes/08buildheap/\">build heap </a>is O(n)</div>",
        "keyword": "Heap"
    },
    {
        "question": "In a min-heap with n elements with the smallest element at the root, the 7th smallest element can be found in time \r\na)  (n log n)\r\nb)  (n)\r\nc)  (log n)\r\nd)  (1)\r\n\r\nThe question was not clear in original GATE exam. For clarity, assume that there are no duplicates in Min-Heap and accessing heap elements below root is allowed.",
        "answer": [
            "a",
            "b",
            "c",
            "d"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> The 7th smallest element must be in first 7 levels. Total number of nodes in any Binary Heap in first 7 levels is at most 1 + 2 + 4 + 8 + 16 + 32 + 64 which is a constant. Therefore we can always find 7th smallest element in <img alt=\"\\theta(1)\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"27\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-05cff2451af25a7621070b535af1450f_l3.png\" style=\"vertical-align: -7px;\" title=\"Rendered by QuickLaTeX.com\" width=\"43\"/> time.\r\n\r\nIf Min-Heap is allowed to have duplicates, then time complexity becomes Θ(Log n).\r\n\r\nAlso, if Min-Heap doesn't allow directly accessing elements below root and supports only extract-min() operation, then also time complexity becomes  Θ(Log n).</div>",
        "keyword": "Heap"
    },
    {
        "question": "In a binary max heap containing n numbers, the smallest element can be found in time (GATE CS 2006)",
        "answer": [
            " 0(n)",
            "O(logn)",
            "0(loglogn)",
            "0(1)"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> In a max heap, the smallest element is always present at a leaf node. So we need to check for all leaf nodes for the minimum value. Worst case complexity will be O(n)\r\n<pre>         12\r\n        /  \\\r\n      /      \\\r\n    8         7\r\n   / \\        / \\\r\n /     \\    /     \\\r\n2      3   4       5</pre></div>",
        "keyword": "Heap"
    },
    {
        "question": "The elements 32, 15, 20, 30, 12, 25, 16 are inserted one by one in the given order into a Max Heap. The resultant Max Heap is.\r\n\r\n",
        "answer": [
            "a",
            "b",
            "c",
            "d"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>\r\n32, 15, 20, 30, 12, 25, 16 \r\n\r\nAfter insertion of 32, 15 and 20\r\n          32\r\n        /    \\\r\n      15      20\r\n \r\nAfter insertion of 30\r\n          32\r\n        /    \\\r\n      15      20\r\n     /\r\n    30\r\nMax Heap property is violated, so 30 is swapped with 15\r\n          32\r\n        /    \\\r\n      30      20\r\n     /\r\n    15\r\n\r\nAfter insertion of 12\r\n          32\r\n        /    \\\r\n      30      20\r\n     /  \\\r\n    15  12\r\n\r\nAfter insertion of 25\r\n          32\r\n        /    \\\r\n      30      20\r\n     /  \\     /\r\n    15  12   25\r\nMax Heap property is violated, so 25 is swapped with 20\r\n          32\r\n        /    \\\r\n      30      25\r\n     /  \\     /\r\n    15  12   20\r\n\r\n\r\nAfter insertion of 16\r\n          32\r\n        /    \\\r\n      30      25\r\n     /  \\     /  \\\r\n    15  12   20  16 \r\n</pre></div>",
        "keyword": "Heap"
    },
    {
        "question": "Given two max heaps of size n each, what is the minimum possible time complexity to make a one max-heap of size from elements of two max heaps?",
        "answer": [
            "O(nLogn)",
            "O(nLogLogn)",
            "O(n)",
            "O(nLogn)"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> We can build a heap of 2n elements in O(n) time.  Following are the steps.\r\n\r\nCreate an array of size 2n and copy elements of both heaps  to this array.\r\n\r\nCall build heap for the array of size 2n.  Build heap operation takes O(n) time.</div>",
        "keyword": "Heap"
    },
    {
        "question": "A priority queue is implemented as a Max-Heap. Initially, it has 5 elements. The level-order traversal of the heap is: 10, 8, 5, 3, 2. Two new elements 1 and 7 are inserted into the heap in that order. The level-order traversal of the heap after the insertion of the elements is:\r\n",
        "answer": [
            "10, 8, 7, 3, 2, 1, 5 ",
            "10, 8, 7, 2, 3, 1, 5",
            "10, 8, 7, 1, 2, 3, 5 ",
            " 10, 8, 7, 5, 3, 2, 1"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>\r\nInitially heap has 10, 8, 5, 3, 2\r\n    10\r\n   /  \\ \r\n  8    5\r\n / \\\r\n3   2\r\n\r\nAfter insertion of 1\r\n     10\r\n   /   \\ \r\n  8     5\r\n / \\   /\r\n3   2 1 \r\nNo need to heapify as 5 is greater than 1.\r\n\r\n\r\nAfter insertion of 7\r\n     10\r\n   /   \\ \r\n  8     5\r\n / \\   / \\\r\n3   2 1   7\r\nHeapify 5 as 7 is greater than 5\r\n     10\r\n   /   \\ \r\n  8     7\r\n / \\   / \\\r\n3   2 1   5\r\nNo need to heapify any further as 10 is\r\ngreater than 7 </pre>\n</div>",
        "keyword": "Heap"
    },
    {
        "question": "Which of the following Binary Min Heap operation has the highest time complexity?",
        "answer": [
            "Inserting an item under the assumption that the heap has capacity to accommodate one more item",
            "Merging with another heap under the assumption that the heap has capacity to accommodate items of other heap",
            "Deleting an item from heap",
            "Decreasing value of a key "
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> The merge operation takes O(n) time, all other operations given in question take O(Logn) time.\r\n\r\nThe Binomial and Fibonacci Heaps do merge in better time complexity.</div>",
        "keyword": "Heap"
    },
    {
        "question": "Consider any array representation of an n element binary heap where the elements are stored from index 1 to index n of the array. For the element stored at index i of the array (i <= n), the index of the parent is",
        "answer": [
            "i - 1",
            "floor(i/2)",
            "ceiling(i/2)",
            "(i+1)/2"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> <a href=\"http://quiz.geeksforgeeks.org/binary-heap/\">Binary heaps</a> can be represented using arrays: storing elements in an array and using their relative positions within the array to represent child-parent relationships.\r\n\r\nFor the binary heap element stored at index i of the array, \r\n\r\nParent Node will be at index: floor(i/2)\r\nLeft Child will be at index: 2i \r\nRight child will be at index: 2*i + 1\r\n\r\nThis explanation is contributed by <strong>Saksham Seth.</strong>\n</div>",
        "keyword": "Heap"
    },
    {
        "question": "Consider a max heap, represented by the array: 40, 30, 20, 10, 15, 16, 17, 8, 4.  Now consider that a value 35 is inserted into this heap. After insertion, the new heap is",
        "answer": [
            "40, 30, 20, 10, 15, 16, 17, 8, 4, 35",
            "40, 35, 20, 10, 30, 16, 17, 8, 4, 15",
            "40, 30, 20, 10, 35, 16, 17, 8, 4, 15",
            "40, 35, 20, 10, 15, 16, 17, 8, 4, 30"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> The array 40, 30, 20, 10, 15, 16, 17, 8, 4 represents following heap <pre>\r\n\r\n         40\r\n       /    \\\r\n     30      20\r\n    / \\      / \\\r\n   10  15  16   17\r\n  / \\\r\n 8   4</pre>\r\n\r\nAfter insertion of 35, we get\r\n\r\n<pre>\r\n         40\r\n       /    \\\r\n     30      20\r\n    / \\       / \\\r\n   10  15  16   17\r\n  / \\  /\r\n 8   4 35  </pre>\r\n\r\n\r\nAfter swapping 35 with 15 and swapping 35 again \r\nwith 30, we get\r\n<pre>\r\n         40\r\n       /    \\\r\n     35      20\r\n    / \\       / \\\r\n   10  30  16   17\r\n  / \\  /\r\n 8   4 15  </pre>\n</div>",
        "keyword": "Heap"
    },
    {
        "question": "Consider the following array of elements. 〈89, 19, 50, 17, 12, 15, 2, 5, 7, 11, 6, 9, 100〉. The minimum number of interchanges needed to convert it into a max-heap is",
        "answer": [
            "4",
            "5",
            "2",
            "3"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> 〈89, 19, 50, 17, 12, 15, 2, 5, 7, 11, 6, 9, 100〉 <pre>\r\n\r\n           89\r\n      /         \\\r\n     19          50\r\n    /  \\        /  \\  \r\n  17    12     15    2\r\n /  \\   / \\   /  \\\r\n5   7  11  6  9  100\r\n\r\nMinimum number of swaps required to convert above tree \r\nto Max heap is 3. Below are 3 swap operations.\r\nSwap 100 with 15\r\nSwap 100 with 50\r\nSwap 100 with 89 \r\n\r\n           100\r\n      /         \\\r\n     19          89\r\n    /  \\        /  \\  \r\n  17    12     50    5 \r\n /  \\   / \\   /  \\\r\n7   11  6  9  2   15</pre>\n</div>",
        "keyword": "Heap"
    },
    {
        "question": "An operator delete(i) for a binary heap data structure is to be designed to delete the item in the i-th node. Assume that the heap is implemented in an array and i refers to the i-th index of the array. If the heap tree has depth d (number of edges on the path from the root to the farthest leaf), then what is the time complexity to re-fix the heap efficiently after the removal of the element?",
        "answer": [
            "O(1)",
            "O(d) but not O(1)",
            "O(2d) but not O(d)",
            "O(d2d) but not O(2d)\r\n"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\">  \r\n\r\nFor this question, we have to slightly tweak the delete_min() operation of the heap data structure to implement the delete(<i>i</i>) operation. The idea is to empty the spot in the array at the index i (the position at which element is to be deleted) and replace it with the last leaf in the heap (remember heap is implemented as complete binary tree so you know the location of the last leaf), decrement the heap size and now starting from the current position <i>i </i>(position that held the item we deleted), shift it up in case newly replaced item is greater than the parent of old item  (considering max-heap).  If it’s not greater than the parent, then percolate it down by comparing with the child’s value. The newly added item can percolate up/down a maximum of d times which is the depth of the heap data structure.\r\n\r\nThus we can say that complexity of delete(<i>i</i>) would be O(d) but not O(1).\r\n\r\n<a href=\"http://geeksquiz.com/binary-heap/\">http://geeksquiz.com/binary-heap/</a>\r\n\r\n \r\n\r\nThis solution is contributed by <b class=\"gmail_sendername\">Pranjul Ahuja</b>.</div>",
        "keyword": "Heap"
    },
    {
        "question": "A complete binary min-heap is made by including each integer in [1, 1023] exactly once. The depth of a node in the heap is the length of the path from the root of the heap to that node. Thus, the root is at depth 0. The maximum depth at which integer 9 can appear is _____________\r\n\r\n[This question was originally asked as Fill-in-the-Blanks question]",
        "answer": [
            "6",
            "7",
            "8",
            "9"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> here node with integer 1 has to be at root only. Now for maximum depth of the tree the following arrangement can be taken. Take root as level 1.\r\n\r\nmake node 2 at level 2 as a child node of node 1.\r\nmake node 3 at level 3 as the child node of node 2.\r\n..\r\n.. and so on for nodes 4,5,6,7\r\n..\r\nmake node 8 at level 8 as the child node of node 7.\r\nmake node 9 at level 9 as the child node of node 8.\r\n\r\nPutting other nodes properly, this arrangement of the the complete binary tree will follow the property of min heap.\r\n\r\nSo total levels are 9. node 9 is at level 9 and depth of node 9 is 8 from the root.</div>",
        "keyword": "Heap"
    },
    {
        "question": "Which of the following sequences of array elements forms a heap?",
        "answer": [
            "{23, 17, 14, 6, 13, 10, 1, 12, 7, 5}",
            "{23, 17, 14, 6, 13, 10, 1, 5, 7, 12}",
            "{23, 17, 14, 7, 13, 10, 1, 5, 6, 12}",
            "{23, 17, 14, 7, 13, 10, 1, 12, 5, 7}"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\">  \r\nWhen they are asking for heap, by default it's max heap.\r\n\r\n<strong>Basic Requirement:</strong> Array representation of binary tree\r\n\r\nStarting from basics lets first understand heap trees We have 2 types of heap – Min heap and Max heap\r\n\r\nIn Min heap the parent is always smaller than its children and in Max heap parent is always greater than its children.\r\n\r\n<a href=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/12/heap.png\"><img alt=\"heap\" class=\"aligncenter size-full wp-image-28910\" height=\"207\" src=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/12/heap.png\" width=\"687\"/></a>\r\n\r\nLooking at the options we can tell that which tree is Max heap tree. Now consider each option one by one and draw a tree \r\n\r\n<a href=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/12/max-heap.png\"><img alt=\"max-heap\" class=\"aligncenter size-full wp-image-28911\" height=\"453\" src=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/12/max-heap.png\" width=\"680\"/></a>\r\n\r\nFrom options it is clear that only option C satisfies the Max heap tree property.\r\n\r\nThis explanation has been contributed by <strong>Parul Sharma.</strong></div>",
        "keyword": "Heap"
    },
    {
        "question": "The minimum number of interchanges needed to convert the array 89, 19, 40, 17, 12, 10, 2, 5, 7, 11, 6, 9, 70 into a heap with the maximum element at the root is",
        "answer": [
            "0",
            "1",
            "2",
            "3"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> In these kind of questions we have to make the structure of heap and then try to apply heapify operation in a bottom up fashion and counting number of swaps done in the above question 70 will go up the heap structure 2 times.</div>",
        "keyword": "Heap"
    },
    {
        "question": "A priority queue is implemented as a Max-heap. Initially it has 5 elements. The level order traversal of the heap is 10, 8, 5, 3, 2. Two new elements ‘1’ and ‘7’ are inserted into the heap in that order. The level order traversal of the heap after the insertion of the elements is",
        "answer": [
            "10, 8, 7, 5, 3, 2, 1",
            "10, 8, 7, 2, 3, 1, 5",
            "10, 8, 7, 1, 2, 3, 5",
            "10, 8, 7, 3, 2, 1, 5"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> Refer: <a href=\"https://www.geeksforgeeks.org/gate-gate-cs-2014-set-2-question-22/\" rel=\"noopener\" target=\"_blank\">GATE-CS-2014-(Set-2) | Question 22</a>\r\nOption (D) is correct.</div>",
        "keyword": "Heap"
    },
    {
        "question": "Which languages necessarily need heap allocation in the run time environment?",
        "answer": [
            "Those that support recursion",
            "Those that use dynamic scoping",
            "Those that use global variables",
            "Those that allow dynamic data structures"
        ],
        "correct": "D",
        "explain": "None",
        "keyword": "Heap"
    },
    {
        "question": "Which of the following is a valid heap ? \r\n(A)\r\n(B)\r\n(C)\r\n(D)",
        "answer": [
            "A",
            "B",
            "C",
            "D"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> For a heap to be valid, either it should be max heap or a min heap.\r\n<img alt=\"b2 (1) (1)\" class=\"alignnone size-medium wp-image-189116\" src=\"https://www.geeksforgeeks.org/wp-content/uploads/b2-1-1-1.png\"/>\r\nonly this heap is valid and it is a max haep.\r\nSo, option (B) is correct.</div>",
        "keyword": "Heap"
    },
    {
        "question": "Which one of the following array represents a binary max-heap?",
        "answer": [
            "[26, 13, 17, 14, 11, 9, 15]",
            "[26, 15, 14, 17, 11, 9, 13]",
            "[26, 15, 17, 14, 11, 9, 13]",
            "[26, 15, 13, 14, 11, 9, 17]"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> For max heap we will compare parent node(i) with its left-child(2 * i) and right-child(2 * i + 1):\r\n<ul><li>In first option node(2) &lt; node(5) which is violating the max-heap property.</li>\n<li>In second option node  node(2) &lt; node(5) which is violating the max-heap property.</li>\n<li>In third option there is no violation.</li>\n<li>In fourth option node(3) &lt; node(7) which is violating the max-heap property.</li></ul>\r\nSo, option (C) is correct.\r\n</div>",
        "keyword": "Heap"
    },
    {
        "question": "Given a binary-max heap. The elements are stored in an arrays as 25, 14, 16, 13, 10, 8, 12. What is the content of the array after two delete operations?",
        "answer": [
            " 14,13,8,12,10 ",
            "14,12,13,10,8",
            "14,13,12,8,10     ",
            "14,13,12,10,8"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> <p>After the first deletion:      <strong>12</strong>, 14, 16, 13, 10, 8 -&gt; heapify -&gt; 16, 14, 12, 13, 10, 8 <br/>After the second deletion: <strong>8</strong>, 14, 12, 13, 10 -&gt; heapify-&gt; 14, <strong>8</strong>, 12, 13, 10 -&gt; heapify -&gt; 14, 13, 12, 8,10</p></div>",
        "keyword": "Heap"
    },
    {
        "question": "Consider the array representation of a binary min-heap containing 1023 elements. The minimum number of comparisons required to find the maximum in the heap is _________ .\r\n\r\n\r\nNote - This question was Numerical Type.",
        "answer": [
            "510",
            "511",
            "512",
            "255"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> In a Min-heap having n elements, there are ceil(n/2) leaf nodes. \r\nSo, there will be ceil(1023/2) = ceil(511.5) = 512 elements as external nodes.\r\n\r\nNow, in general, to find maximum of n elements you need (n-1) comparisons. \r\nJust compare first two and then select the larger and compare with next one, select the larger and compare with next one etc.\r\n\r\nTherefore, we need 511 (=512 - 1) minimum number of comparisons required to find the maximum in the given heap.\r\n\r\nOption (B) is correct.</div>",
        "keyword": "Heap"
    },
    {
        "question": "Let H be a binary min-heap consisting of n elements implemented as an array. What is the worst case time complexity of an optimal algorithm to find the maximum element in H?",
        "answer": [
            "Θ(1)",
            "Θ(logn)",
            "Θ(n)",
            "Θ(nlogn)"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> In case of min heap if we need to find out max element than it should be present at leave nodes so in worst case we need to search till leaf nodes we can't perform binary search here because its not BST and heaps need not be in sorted order so in worst case it would be (n/2)+1. On normalizing it would be O(n) which is option 3.\r\n\r\n\r\nRefer - <a href=\"https://www.geeksforgeeks.org/maximum-element-in-min-heap/\" rel=\"noopener\" target=\"_blank\">Maximum element in min heap</a>\n<iframe allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen=\"\" frameborder=\"0\" height=\"315\" src=\"https://www.youtube.com/embed/I43aLH5qEBc?start=1255\" title=\"YouTube video player\" width=\"560\"></iframe></div>",
        "keyword": "Heap"
    },
    {
        "question": "Following function is supposed to calculate the maximum depth or height of a Binary tree -- the number of nodes along the longest path from the root node down to the farthest leaf node.\r\n\r\n\r\nint maxDepth(struct node* node)\r\n{\r\n   if (node==NULL)\r\n       return 0;\r\n   else\r\n   {\r\n       /* compute the depth of each subtree */\r\n       int lDepth = maxDepth(node->left);\r\n       int rDepth = maxDepth(node->right);\r\n \r\n       /* use the larger one */\r\n       if (lDepth > rDepth)\r\n           return X;\r\n       else return Y;\r\n   }\r\n}\r\n\r\n\r\nWhat should be the values of X and Y so that the function works correctly?",
        "answer": [
            "X  = lDepth, Y = rDepth",
            "X  = lDepth + 1, Y = rDepth + 1",
            "X  = lDepth - 1, Y = rDepth -1",
            "None of the above"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> If a tree is not empty, height of tree is \r\nMAX(Height of Left Subtree, Height of Right Subtree) + 1\r\n\r\nSee <a href=\"http://www.geeksforgeeks.org/write-a-c-program-to-find-the-maximum-depth-or-height-of-a-tree/\" target=\"_blank\">program to Find the Maximum Depth or Height of a Tree</a> for more details.\r\n\r\n</div>",
        "keyword": "Tree Traversals"
    },
    {
        "question": "What is common in three different types of traversals (Inorder, Preorder and Postorder)?",
        "answer": [
            "Root is visited before right subtree",
            "Left subtree is always visited before right subtree",
            "Root is visited after left subtree",
            "All of the above",
            "None of the above"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> The order of inorder traversal is \r\nLEFT ROOT RIGHT\r\n\r\nThe order of preorder traversal is\r\nROOT LEFT RIGHT\r\n\r\nThe order of postorder traversal is\r\nLEFT RIGHT ROOT\r\n\r\n\r\nIn all three traversals, LEFT is traversed before RIGHT\r\n\r\n</div>",
        "keyword": "Tree Traversals"
    },
    {
        "question": "The inorder and preorder traversal of a binary tree are d b e a f c g and a b d e c f g, respectively. The postorder traversal of the binary tree is:",
        "answer": [
            "d e b f g c a",
            "e d b g f c a",
            "e d b f g c a",
            "d e f g b c a"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Below is the given tree.<pre>\r\n                              a\r\n                           /    \\\r\n                        /          \\\r\n                      b             c\r\n                   /   \\          /   \\\r\n                 /       \\      /       \\\r\n               d         e    f          g</pre>\n</div>",
        "keyword": "Tree Traversals"
    },
    {
        "question": "What does the following function do for a given binary tree?\r\n\r\n\r\nint fun(struct node *root)\r\n{\r\n   if (root == NULL)\r\n      return 0;\r\n   if (root->left == NULL && root->right == NULL)\r\n      return 0;\r\n   return 1 + fun(root->left) + fun(root->right);\r\n}\r\n",
        "answer": [
            "Counts leaf nodes",
            "Counts internal nodes",
            "Returns height where height is defined as number of edges on the path from root to deepest node",
            "Return diameter where diameter is number of edges on the longest path between any two nodes."
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> The function counts internal nodes.\r\n1) If root is NULL or a leaf node, it returns 0.\r\n2) Otherwise returns, 1 plus count of internal nodes in left subtree, plus count of internal nodes in right subtree.\r\n\r\n<a href=\"http://geeksquiz.com/data-structures-binary-trees-question-10/\">See the following complete program.</a>\r\n[sourcecode language=\"C\"]\r\n#include <stdio.h>\r\n\r\nstruct node\r\n{\r\n  int key;\r\n  struct node *left, *right;\r\n};\r\n\r\nint fun(struct node *root)\r\n{\r\n   if (root == NULL)\r\n      return 0;\r\n   if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)\r\n      return 0;\r\n   return 1 + fun(root-&gt;left) + fun(root-&gt;right);\r\n}\r\n\r\n/* Helper function that allocates a new node with the\r\n   given key and NULL left and right pointers. */\r\nstruct node* newNode(int key)\r\n{\r\n  struct node* node = (struct node*)\r\n                       malloc(sizeof(struct node));\r\n  node-&gt;key = key;\r\n  node-&gt;left = NULL;\r\n  node-&gt;right = NULL;\r\n\r\n  return(node);\r\n}\r\n\r\n/* Driver program to test above functions*/\r\nint main()\r\n{\r\n\r\n  /* Constructed binary tree is\r\n            1\r\n          /   \\\r\n        2      3\r\n      /  \\    /\r\n    4     5  8\r\n  */\r\n  struct node *root = newNode(1);\r\n  root-&gt;left        = newNode(2);\r\n  root-&gt;right       = newNode(3);\r\n  root-&gt;left-&gt;left  = newNode(4);\r\n  root-&gt;left-&gt;right = newNode(5);\r\n  root-&gt;right-&gt;left = newNode(8);\r\n\r\n  printf(\"%d\", fun(root));\r\n\r\n  getchar();\r\n  return 0;\r\n}\r\n[/sourcecode]</stdio.h></div>",
        "keyword": "Tree Traversals"
    },
    {
        "question": "Which of the following pairs of traversals is not sufficient to build a binary tree from the given traversals?",
        "answer": [
            "Preorder and Inorder ",
            "Preorder and Postorder",
            "Inorder and Postorder",
            "None of the Above"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> See <a href=\" http://www.geeksforgeeks.org/if-you-are-given-two-traversal-sequences-can-you-construct-the-binary-tree/\"> http://www.geeksforgeeks.org/if-you-are-given-two-traversal-sequences-can-you-construct-the-binary-tree/</a> for details.</div>",
        "keyword": "Tree Traversals"
    },
    {
        "question": "Consider two binary operators ' ' and '' with the precedence of operator  being lower than that of the  operator. Operator  is right associative while operator  is left associative. Which one of the following represents the parse tree for expression (7  3 ­ 4 ­ 3  2)? (GATE CS 2011)\r\n\r\n",
        "answer": [
            "A",
            "B",
            "C",
            "D"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Let us consider the given expression (<img alt=\"7 \\downarrow 3 \\uparrow 4 \\uparrow 3 \\downarrow 2\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"25\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-95741ae580b319c94e06a0be33b1ed04_l3.png\" style=\"vertical-align: -6px;\" title=\"Rendered by QuickLaTeX.com\" width=\"175\"/>).\r\n\r\nSince the precedence of <img alt=\"\\uparrow\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"25\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-6c5aabd87b462d54f2f88af091331ac7_l3.png\" style=\"vertical-align: -6px;\" title=\"Rendered by QuickLaTeX.com\" width=\"13\"/> is higher, the sub-expression (<img alt=\"3 \\uparrow 4 \\uparrow 3\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"25\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-632a8c54ff929b6a6b91bda6cd4102c4_l3.png\" style=\"vertical-align: -6px;\" title=\"Rendered by QuickLaTeX.com\" width=\"93\"/>) will be evaluated first. In this sub-expression, <img alt=\"4 \\uparrow 3\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"25\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-e6fe4aca146bd2cfb82419fe6a1c3fd6_l3.png\" style=\"vertical-align: -6px;\" title=\"Rendered by QuickLaTeX.com\" width=\"53\"/> would be evaluated first because <img alt=\"\\uparrow\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"25\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-6c5aabd87b462d54f2f88af091331ac7_l3.png\" style=\"vertical-align: -6px;\" title=\"Rendered by QuickLaTeX.com\" width=\"13\"/> is right to left associative. So the expression is evaluated as <img alt=\"((7 \\downarrow (3 \\uparrow (4 \\uparrow 3))) \\downarrow 2)\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"27\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-f5702db4f14de1fd25ba0ac3325593a8_l3.png\" style=\"vertical-align: -7px;\" title=\"Rendered by QuickLaTeX.com\" width=\"255\"/>. Also, note that among the two <img alt=\"\\downarrow \" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"25\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-cb85a77cd7451613c595a06ffb518467_l3.png\" style=\"vertical-align: -6px;\" title=\"Rendered by QuickLaTeX.com\" width=\"13\"/> operators, first one is evaluated before the second one because the associativity of <img alt=\"\\downarrow\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"25\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-75205866931625ecc51fb59e740965bf_l3.png\" style=\"vertical-align: -6px;\" title=\"Rendered by QuickLaTeX.com\" width=\"13\"/> is left to right.</div>",
        "keyword": "Tree Traversals"
    },
    {
        "question": "Which traversal of tree resembles the breadth first search of the graph?",
        "answer": [
            "Preorder",
            "Inorder",
            "Postorder",
            "Level order"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> <a href=\"http://www.geeksforgeeks.org/breadth-first-traversal-for-a-graph/\" target=\"_blank\">Breadth first search</a> visits all the neighbors first and then deepens into each neighbor one by one. The <a href=\"http://www.geeksforgeeks.org/level-order-tree-traversal/\" target=\"_blank\">level order traversal</a> of the tree also visits nodes on the current level and then goes to the next level.</div>",
        "keyword": "Tree Traversals"
    },
    {
        "question": "Which of the following tree traversal uses a queue data structure?",
        "answer": [
            "Preorder",
            "Inorder",
            "Postorder",
            "Level order"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> <a href=\"http://www.geeksforgeeks.org/level-order-tree-traversal/\" target=\"_blank\">Level order traversal</a> uses a queue data structure to visit the nodes level by level.</div>",
        "keyword": "Tree Traversals"
    },
    {
        "question": "Which of the following cannot generate the full binary tree?",
        "answer": [
            "Inorder and Preorder",
            "Inorder and Postorder",
            "Preorder and Postorder",
            "None of the above"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> To generate a binary tree, two traversals are necessary and one of them must be inorder. But, a full binary tree can be generated from preorder and postorder traversals. Read the algorithm <strong><a href=\"http://www.geeksforgeeks.org/full-and-complete-binary-tree-from-given-preorder-and-postorder-traversals/\" target=\"_blank\">here</a></strong>.\r\nRead <a href=\"http://www.geeksforgeeks.org/if-you-are-given-two-traversal-sequences-can-you-construct-the-binary-tree/\" target=\"_blank\">Can tree be constructed from given traversals</a>?</div>",
        "keyword": "Tree Traversals"
    },
    {
        "question": "Consider the following C program segment",
        "answer": "None",
        "correct": "None",
        "explain": "None",
        "keyword": "Tree Traversals"
    },
    {
        "question": "Let LASTPOST, LASTIN and LASTPRE denote the last vertex visited in a postorder, inorder and preorder traversal. Respectively, of a complete binary tree. Which of the following is always true? (GATE CS 2000)",
        "answer": [
            "LASTIN = LASTPOST",
            " LASTIN = LASTPRE",
            "LASTPRE = LASTPOST",
            "None of the above"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> It is given that the given tree is <a href=\"http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees\">complete binary tree</a>. For a complete binary tree, the last visited node will always be same for inorder and preorder traversal.  None of the above is true even for a complete binary tree. \r\n\r\nThe option (a) is incorrect because the last node visited in Inorder traversal is right child and last node visited in Postorder traversal is root.\r\n\r\nThe option (c) is incorrect because the last node visited in Preorder traversal is right child and last node visited in Postorder traversal is root.\r\n\r\nFor option (b), see the following counter example. Thanks to <a href=\"https://www.facebook.com/hunaif.mhd\">Hunaif Muhammed</a> for providing the correct explanation.\r\n<pre>\r\n     1\r\n   /    \\\r\n  2      3\r\n / \\    /\r\n4   5  6  \r\n\r\nInorder traversal is 4 2 5 1 6 3\r\nPreorder traversal is 1 2 4 5 3 6 \r\n</pre>\n</div>",
        "keyword": "Tree Traversals"
    },
    {
        "question": "The array representation of a complete binary tree contains the data in sorted order. Which traversal of the tree will produce the data in sorted form?",
        "answer": [
            "Preorder",
            "Inorder",
            "Postorder",
            "Level order"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> The <a href=\"http://www.geeksforgeeks.org/level-order-tree-traversal/\" target=\"_blank\">level order traversal</a> of a binary tree prints the data in the same order as it is stored in the array representation of a complete binary tree.</div>",
        "keyword": "Tree Traversals"
    },
    {
        "question": "Consider the following rooted tree with the vertex P labeled as root\r\n\r\n\r\n\r\nThe order in which the nodes are visited during in-order traversal is",
        "answer": [
            "SQPTRWUV",
            "SQPTURWV",
            "SQPTWUVR",
            "SQPTRUWV"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>\r\nAlgorithm Inorder(tree) - Use of Recursion\r\nSteps:\r\n1. Traverse the left subtree, \r\n   i.e., call Inorder(left-subtree)\r\n2. Visit the root.\r\n3. Traverse the right subtree, \r\n   i.e., call Inorder(right-subtree)\r\n\r\nUnderstanding this algorithm requires the basic \r\nunderstanding of Recursion\r\n\r\nTherefore, We begin in the above tree with root as\r\nthe starting point, which is P.\r\n\r\n# Step 1( for node P) :\r\nTraverse the left subtree of node or root P.\r\nSo we have node Q on left of P.\r\n\r\n-&gt; Step 1( for node Q)\r\nTraverse the left subtree of node Q.\r\nSo we have node S on left of Q.\r\n\r\n* Step 1 (for node S)\r\nNow again traverse the left subtree of node S which is \r\nNULL here.\r\n\r\n* Step 2(for node S)\r\nVisit the node S, i.e print node S as the 1st element of \r\ninorder traversal.\r\n\r\n* Step 3(for node S)\r\nTraverse the right subtree of node S.\r\nWhich is NULL here.\r\n\r\nNow move up in the tree to Q which is parent\r\nof S.( Recursion, function of Q called for function of S).\r\nHence we go back to Q.\r\n\r\n-&gt; Step 2( for node Q):\r\nVisit the node Q, i.e print node Q as the 2nd\r\nelement of inorder traversal.\r\n\r\n-&gt; Step 3 (for node Q)\r\nTraverse the right subtree of node Q.\r\nWhich is NULL here.\r\n\r\nNow move up in the tree to P which is parent\r\nof Q.( Recursion, function of P called for function of Q).\r\nHence we go back to P.\r\n\r\n# Step 2(for node P)\r\nVisit the node P, i.e print node S as the 3rd\r\nelement of inorder traversal.\r\n\r\n# Step 3 (for node P)\r\nTraverse the right subtree of node P.\r\nNode R is at the right of P.\r\n\r\nTill now we have printed SQP as the inorder of the tree. \r\nSimilarly other elements can be obtained by traversing \r\nthe right subtree of P.\r\n\r\nThe final correct order of Inorder traversal would \r\nbe SQPTRWUV. </pre>\n</div>",
        "keyword": "Tree Traversals"
    },
    {
        "question": "Consider the pseudocode given below. The function DoSomething() takes as argument a pointer to the root of an arbitrary tree represented by the leftMostChild-rightSibling representation.\r\nEach node of the tree is of type treeNode.\r\n\r\n\r\ntypedef struct treeNode* treeptr;\r\nstruct treeNode\r\n{\r\n    treeptr leftMostChild, rightSibling;\r\n};\r\nint DoSomething (treeptr tree)\r\n{\r\n    int value=0;\r\n    if (tree != NULL)\r\n    {\r\n        if (tree->leftMostChild == NULL)\r\n            value = 1;\r\n        else\r\n            value = DoSomething(tree->leftMostChild);\r\n        value = value + DoSomething(tree->rightSibling);\r\n    }\r\n    return(value);\r\n}\r\n\r\n\r\n\r\nWhen the pointer to the root of a tree is passed as the argument to DoSomething, the value returned by the function corresponds to the",
        "answer": [
            " number of internal nodes in the tree.\r\n",
            "height of the tree.",
            "number of nodes without a right sibling in the tree.\r\n",
            "number of leaf nodes in the tree."
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> The function counts leaf nodes for a tree represented using leftMostChild-rightSibling representation.\r\n\r\nBelow is function with comments added to demonstrate how function works.\r\n\r\n[sourcecode language=\"C\"]\r\nint DoSomething (treeptr tree)\r\n{\r\n    // If tree is empty, 0 is returned\r\n    int value = 0;\r\n\r\n    // IF tree is not empty\r\n    if (tree != NULL)\r\n    {\r\n        // IF this is a leaf node, then values is initialized as 1\r\n        if (tree-&gt;leftMostChild == NULL)\r\n            value = 1;\r\n\r\n        // Else value is initialized as the value returned by leftmost\r\n        // child which in turn calls for the other children of this node\r\n        // Using last call \"value = value + DoSomething(tree-&gt;rightSibling);\"\r\n        else\r\n            value = DoSomething(tree-&gt;leftMostChild);\r\n\r\n        // Add value returned by right sibling\r\n        value = value + DoSomething(tree-&gt;rightSibling);\r\n    }\r\n    return(value);\r\n}[/sourcecode]\r\n</div>",
        "keyword": "Tree Traversals"
    },
    {
        "question": "Level order traversal of a rooted tree can be done by starting from the root and performing",
        "answer": [
            "preorder traversal",
            "inorder traversal",
            "depth first search",
            "breadth first search"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> See <a href=\"https://www.geeksforgeeks.org/level-order-tree-traversal/\">this</a> post for details</div>",
        "keyword": "Tree Traversals"
    },
    {
        "question": "Consider the label sequences obtained by the following pairs of traversals on a labeled binary tree. Which of these pairs identify a tree uniquely ? \r\n(i)     preorder and postorder\r\n(ii)    inorder and postorder\r\n(iii)   preorder and inorder\r\n(iv)   level order and postorder",
        "answer": [
            "(i) only",
            "(ii), (iii)",
            "(iii) only",
            "(iv) only"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Here, we consider each and every option to check whether it is true or false.\r\n\r\n1) Preorder and postorder\r\n\r\n<a href=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2017/01/anil_ds_35.png\"><img alt=\"anil_ds_35\" class=\"alignnone size-full wp-image-29837\" height=\"195\" src=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2017/01/anil_ds_35.png\" width=\"465\"/></a>\r\nFor the above trees,\r\n\r\nPreorder is AB\r\n\r\nPostorder is BA\r\n\r\nIt shows that preorder and postorder can’t identify a tree uniquely.\r\n\r\n2) Inorder and postorder define a tree uniquely\r\n\r\n3) Preorder and Inorder also define a tree uniquely\r\n\r\n4) Levelorder and postorder can’t define a tree uniquely. For the above example,\r\n\r\nLevel order is AB\r\n\r\nPostorder is BA\r\n\r\nSee <a href=\"http://www.geeksforgeeks.org/if-you-are-given-two-traversal-sequences-can-you-construct-the-binary-tree/\" target=\"_blank\">http://www.geeksforgeeks.org/if-you-are-given-two-traversal-sequences-can-you-construct-the-binary-tree/</a> for details\r\n\r\n\r\nThis solution is contributed by <strong>Anil Saikrishna Devarasetty</strong></div>",
        "keyword": "Tree Traversals"
    },
    {
        "question": "Let LASTPOST, LASTIN and LASTPRE denote the last vertex visited in a postorder, inorder and preorder traversal, respectively, of a complete binary tree. Which of the following is always true?",
        "answer": [
            "LASTIN = LASTPOST",
            "LASTIN = LASTPRE",
            "LASTPRE = LASTPOST ",
            "None of the above "
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> See question 1 of <a href=\"http://www.geeksforgeeks.org/data-structures-and-algorithms-set-1/\">http://www.geeksforgeeks.org/data-structures-and-algorithms-set-1/</a></div>",
        "keyword": "Tree Traversals"
    },
    {
        "question": "Which one of the following binary trees has its inorder and preorder traversals as BCAD  and ABCD, respectively?\r\n",
        "answer": [
            "A",
            "B",
            "C",
            "D"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> Inorder Traversal: <strong>Left -Root -Right</strong>\r\n\r\nPreOrder Traversal: <strong>Root-Left-Right</strong>\n<pre>\r\n    InOrder  PreOrder\r\n\r\nA.   BADC   ABCD\r\n\r\nB.   BCAD   ACBD\r\n\r\nC.   ACBD   ABCD</pre>\n<strong><span style=\"color: #008000;\">D.    BCAD  ABCD</span></strong>\n<strong>Therefore, D is Correct</strong></div>",
        "keyword": "Tree Traversals"
    },
    {
        "question": "The numbers 1, 2, .... n are inserted in a binary search tree in some order. In the resulting tree, the right subtree of the root contains p nodes. The first number to be inserted in the tree must be",
        "answer": [
            "p",
            "p + 1",
            "n - p",
            "n - p + 1"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> <div class=\"postbody\">\r\n\r\nBinary Search Tree, is a node-based binary tree data structure which has the following properties:<span id=\"more-8837\"></span>\n<ul>\n<li>The left subtree of a node contains only nodes with keys less than the node’s key.</li>\n<li>The right subtree of a node contains only nodes with keys greater than the node’s key.</li>\n<li>The left and right subtree each must also be a binary search tree.\r\nThere must be no duplicate nodes.</li>\n</ul>\n</div>\n<div class=\"postbody\">So let us say n=10, p=4. According to BST property the root must be 10-4=6 (considering all unique elements in BST)</div>\n<div class=\"postbody\">And according to <a href=\"http://geeksquiz.com/binary-search-tree-set-1-search-and-insertion/\">BST insertion</a>, root is the first element to be inserted in a BST.</div>\n<div class=\"postbody\">\r\nTherefore, the answer is (n-p).</div>\r\n </div>",
        "keyword": "Tree Traversals"
    },
    {
        "question": "A binary search tree contains the numbers 1, 2, 3, 4, 5, 6, 7, 8. When the tree is traversed in pre-order and the values in each node printed out, the sequence of values obtained is 5, 3, 1, 2, 4, 6, 8, 7. If the tree is traversed in post-order, the sequence obtained would be\r\n\r\n ",
        "answer": [
            "8, 7, 6, 5, 4, 3, 2, 1",
            "1, 2, 3, 4, 8, 7, 6, 5",
            "2, 1, 4, 3, 6, 7, 8, 5",
            "2, 1, 4, 3, 7, 8, 6, 5"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> Please see this link for more details\r\n\r\n<a href=\"http://www.geeksforgeeks.org/construct-tree-from-given-inorder-and-preorder-traversal/\">http://www.geeksforgeeks.org/construct-tree-from-given-inorder-and-preorder-traversal/</a></div>",
        "keyword": "Tree Traversals"
    },
    {
        "question": "If all the edge weights of an undirected graph are positive, then any subset of edges that connects all the vertices and has minimum total weight is a\r\n\r\n ",
        "answer": [
            "Hamiltonian cycle",
            "grid",
            "hypercube",
            "tree"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\">  \r\n\r\n<span style=\"font-size: small;\">As here we want subset of edges that connects all the vertices and has minimum total weight i.e. Minimum Spanning Tree\r\nOption A - includes cycle, so may or may not connect all edges.\r\nOption B - has no relevance to this question.\r\nOption C - includes cycle, so may or may not connect all edges.</span>\r\n\r\nRelated:\r\n<a href=\"http://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/\">http://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/</a>\n<a href=\"http://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-minimum-spanning-tree-mst-2/\">http://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-minimum-spanning-tree-mst-2/</a>\r\n\r\nThis solution is contributed by <strong>Mohit Gupta.</strong>\r\n\r\n </div>",
        "keyword": "Tree Traversals"
    },
    {
        "question": "When searching for the key value 60 in a binary search tree, nodes containing the key values 10, 20, 40, 50, 70 80, 90 are traversed, not necessarily in the order given. How many different orders are possible in which these key values can occur on the search path from the root to the node containing the value 60?",
        "answer": [
            "35",
            "64",
            "128",
            "5040"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> There are two set of values, smaller than 60 and greater than 60. Smaller values 10, 20, 40 and 50 are visited, means they are visited in order. Similarly, 90, 80 and 70 are visited in order. <br/>\r\n= 7!/(4!3!)<br/>\r\n= 35</div>",
        "keyword": "Tree Traversals"
    },
    {
        "question": "The following three are known to be the preorder, inorder and postorder sequences of a binary tree. But it is not known which is which.\r\nMBCAFHPYK\r\nKAMCBYPFH\r\nMABCKYFPH\r\nPick the true statement from the following.\r\n\r\n",
        "answer": [
            "I and II are preorder and inorder sequences, respectively",
            "I and III are preorder and postorder sequences, respectively",
            "II is the inorder sequence, but nothing more can be said about the other two sequences",
            "II and III are the preorder and inorder sequences, respectively"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> \r\n\r\nThe approach to solve this question is to first find 2 sequences whose first and last element is same. The reason being first element in the Pre-order of any binary tree is the root and last element in the Post-order of any binary tree is the root.\r\nLooking at the sequences given, \r\nPre-order   =   KAMCBYPFH\r\nPost-order  =  MBCAFHPYK\r\nLeft-over sequence  MABCKYFPH will be in order.\r\nSince we have all the traversals identified, let's try to draw the binary tree if possible.\r\n\r\n<a href=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/12/pranjul.png\"><img alt=\"pranjul\" class=\"alignnone size-full wp-image-29232\" height=\"372\" src=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/12/pranjul.png\" width=\"561\"/></a>\r\n\r\nI. Post order<br/>\r\nII. Pre order<br/>\r\nIII. Inorder\r\n\r\n\r\nThis solution is contributed by <strong>Pranjul Ahuja.</strong></div>",
        "keyword": "Tree Traversals"
    },
    {
        "question": "Consider the following sequence of nodes for the undirected graph given below.\r\n\r\na b e f d g c\r\na b e f c g d\r\na d g e b c f\r\na d b c g e f\r\nA Depth First Search (DFS) is started at node a. The nodes are listed in the order they are first visited. Which all of the above is (are) possible output(s)?\n",
        "answer": [
            "1 and 3 only",
            "2 and 3 only",
            "2, 3 and 4 only",
            "1, 2, and 3"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> 1: abef-&gt;c or g should be covered<br/>\r\n4: adbc-&gt;e or f should be covered <br/>\r\n2: abefcgd  correct<br/>\r\n3: adgebcf correct<br/></div>",
        "keyword": "Tree Traversals"
    },
    {
        "question": "Which of the following statement is false?",
        "answer": [
            "A tree with n nodes has (n-1) edges.",
            "A labeled rooted binary tree can be uniquely constructed given its postorder and preorder traversal results. ",
            "A complete binary tree with n internal nodes has (n+1) leaves.",
            "The maximum number of nodes in a binary tree of height h is (2^(h+1)  -1)."
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Both option (A) and (D) are correct. But option (B) is false because \"a labeled rooted binary tree <b>can not be uniquely</b> constructed given using its postorder and preorder traversal results\". It need inorder and preorder/postorder for uniquely constructed binary tree.\r\n\r\nOption (C) is also false, take counter example in given tree :\r\n<img alt=\"ALDS1_9_A_1\" class=\"aligncenter size-full wp-image-173257\" height=\"336\" src=\"https://contribute.geeksforgeeks.org/wp-content/uploads/gate-24.png\" width=\"386\"/>\r\n\r\nTherefore, both option (B) and (C) are false.</div>",
        "keyword": "Tree Traversals"
    },
    {
        "question": "A complete n-ary tree is one in which every node has 0 or n sons. If x is the number of internal nodes of a complete n-ary tree, the number of leaves in it is given by",
        "answer": [
            "x(n-1)+1",
            "xn-1",
            "xn+1",
            "x(n+1)"
        ],
        "correct": "A",
        "explain": "None",
        "keyword": "Tree Traversals"
    },
    {
        "question": "[5 Marks question]\r\nAnswer the following:\r\n\r\na. Derive a recurrence relation of the size of the smallest AVL tree with height h. \r\nb. What is the size of the smallest AVL tree with height 8.",
        "answer": "None",
        "correct": "None",
        "explain": "None",
        "keyword": "Tree Traversals"
    },
    {
        "question": "Which of the following sequences denotes the post order traversal sequence of the given tree?\r\n         a\r\n       /   \r\n      b     e\r\n     /    /\r\n    c  d  f\r\n   /\r\n  g\r\n\n",
        "answer": [
            " f e g c d b a",
            " g c b d a f e",
            " g c d b f e a ",
            " f e d g c b a"
        ],
        "correct": "C",
        "explain": "None",
        "keyword": "Tree Traversals"
    },
    {
        "question": "Which of following option is not correct regarding depth first searching?\r\n\r\n\r\n\r\n\r\n",
        "answer": [
            "In a depth-first traversal of a graph G with V vertices, E edges are marked as tree edges. The number of connected components in G is (E - V).",
            "Depth-first search requires O(V^2) time if implemented with an adjacency matrix.",
            "Depth-first search requires O(V + E) time if implemented with adjacency lists",
            "None of these"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> In a depth-first traversal of a graph G with V vertices, E edges are marked as tree edges. The number of connected components in G is (V - E).\r\nOnly option (A) is false.</div>",
        "keyword": "Tree Traversals"
    },
    {
        "question": "The post-order traversal of a binary search tree is given by 2, 7, 6, 10, 9, 8, 15, 17, 20, 19, 16, 12.\r\nThen the pre-order traversal of this tree is:\r\n\r\n",
        "answer": [
            "2, 6, 7, 8, 9, 10, 12, 15, 16, 17, 19, 20",
            "7, 6, 2, 10, 9, 8, 15, 16, 17, 20, 19, 12 ",
            "7, 2, 6, 8, 9, 10, 20, 17, 19, 15, 16, 12 ",
            "12, 8, 6, 2, 7, 9, 10, 16, 15, 19, 17, 20"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> Since given tree is binary tree, so inorder traversal will be always sorted order, i.e., 2, 6, 7, 8, 9, 10, 12, 15, 16, 17, 19, 20. \r\nNow we can draw that binary search tree using given postorder and inorder traversal. Final tree will be:\r\n\r\n<img alt=\"88\" class=\"aligncenter size-full wp-image-175541\" height=\"339\" src=\"https://www.geeksforgeeks.org/wp-content/uploads/88-1.png\" width=\"583\"/>\r\n\r\nTherefore, preorder traversal will be : 12, 8, 6, 2, 7, 9, 10, 16, 15, 19, 17, 20. \r\n\r\nOption (D) is correct.\r\n</div>",
        "keyword": "Tree Traversals"
    },
    {
        "question": "Let G be a simple undirected graph. Let TD be a depth first search tree of G. Let TB be a breadth first search tree of G. Consider the following statements.\r\n\r\n(I) No edge of G is a cross edge with respect to TD. (A cross edge in G is between two nodes neither of which is an ancestor of the other in TD).\r\n\r\n(II) For every edge (u, v) of G, if u is at depth i and v is at depth j in TB, then ∣i − j∣ = 1.\r\n\r\nWhich of the statements above must necessarily be true?\r\n\r\n\r\n\r\n",
        "answer": [
            "I only",
            "II only",
            "Both I and II",
            "Neither I nor II"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> There are four types of edges can yield in DFS. These are tree, forward, back, and cross edges. In undirected connected graph, forward and back egdes are the same thing. A cross edge in a graph is an edge that goes from a vertex v to another vertex u such that u is neither an ancestor nor descendant of v. Therefore, cross edge is not possible in undirected graph.\r\nSo, statement (I) is correct.\r\n \r\nFor statement (II) take counterexample of complete graph of three vertices, i.e., K3 with XYZ, where X is source and Y and Z are in same level. Also,there is an edge between vertices Y and Z, i.e., |i-j| = 0 ≠ 1 in BFS. So, statement became false.\r\n\r\nOption (A) is correct.\r\n</div>",
        "keyword": "Tree Traversals"
    },
    {
        "question": "Suppose the numbers 7, 5, 1, 8, 3, 6, 0, 9, 4, 2 are inserted in that order into an initially empty binary search tree. The binary search tree uses the reversal ordering on natural numbers i.e. 9 is assumed to be smallest and 0 is assumed to be largest. The in-order traversal of the resultant binary search tree is",
        "answer": [
            "9, 8, 6, 4, 2, 3, 0, 1, 5, 7",
            "0, 1, 2, 3, 4, 5, 6, 7, 8, 9",
            "0, 2, 4, 3, 1, 6, 5, 9, 8, 7",
            "9, 8, 7, 6, 5, 4, 3, 2, 1, 0"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> Inorder traversal of a binary search tree always produces the keys in increasing order. In this question Reverse ordering of natural numbers are used i.e. 9 is assumed to be the smallest and 0 to be the largest. So the sequence in increasing order will be 9, 8, 7, 6, 5, 4, 3, 2, 1, 0.\r\nSo, option (D) is correct.</div>",
        "keyword": "Tree Traversals"
    },
    {
        "question": "The in-order and pre-order traversal of a binary tree are d b e a f c g and a b d e c f g respectively. The post order traversal of a binary tree is",
        "answer": [
            "e d b g f c a",
            "e d b f g c a",
            "d e b f g c a",
            "d e f g b c a"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Refer: <a href=\"https://www.geeksforgeeks.org/gate-gate-cs-2007-question-39/\" rel=\"noopener\" target=\"_blank\"> GATE-CS-2007 | Question 39</a> \r\n\r\nOption (C) is correct.</div>",
        "keyword": "Tree Traversals"
    },
    {
        "question": "Consider the following tree\r\n\r\n\r\n\r\nIf the post order traversal gives ab-cd*+ then the label of the nodes 1,2,3,… will be",
        "answer": [
            "+,-,*,a,b,c,d",
            "a,-,b,+,c,*,d",
            "a,b,c,d,-,*,+",
            "-,a,b,+,*,c,d"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Postorder traversal of the given binary tree will give the following sequence: 4 5 2 6 7 3 1.\r\nNow comparing the sequence with a b - c d * + we get 1 = +, 2 = -, 3 = *, 4 = a, 5 = b, 6 = c and 7 = d.\r\nSo, option (A) is correct.</div>",
        "keyword": "Tree Traversals"
    },
    {
        "question": "Choose the equivalent prefix form of the following expression\r\n(a + (b − c))* ((d − e)/(f + g − h))",
        "answer": [
            "* +a − bc /− de − +fgh",
            "* +a −bc − /de − +fgh",
            "* +a − bc /− ed + −fgh",
            "* +ab − c /− ed + −fgh"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> We can write the prefix form of the expression as:\r\n(a + (b − c))* ((d − e) / (f + g − h))\r\n= (a + (- b c)) * ((- d e) / ( + f g - h))\r\n= (+ a - b c) * ((- d e) / (- + f g h)\r\n= (+ a - b c) * (/ - d e - + f g h)\r\n= * + a - b c / - d e - + f g h\r\n</div>",
        "keyword": "Tree Traversals"
    },
    {
        "question": "The number of rotations required to insert a sequence of elements 9,6,5,8,7,10 into an empty AVL tree is? ",
        "answer": [
            "0",
            "1",
            "2",
            "3"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> The <a href=\"https://www.geeksforgeeks.org/avl-tree-set-1-insertion/\" rel=\"noopener\" target=\"_blank\">insertion</a> and rotation of the various elements are shown in the following figure:\r\n\r\n <img src=\"https://www.geeksforgeeks.org/wp-content/uploads/aggggg.jpg\"/>\r\n\r\nSo, the total number of rotations are 3.</div>",
        "keyword": "Tree Traversals"
    },
    {
        "question": "Consider the following statements: \r\n(a) Depth - first search is used to traverse a rooted tree. \r\n(b) Pre - order, Post-order and Inorder are used to list the vertices of an ordered rooted tree. \r\n(c) Huffman’s algorithm is used to find an optimal binary tree with given weights. \r\n(d) Topological sorting provides a labelling such that the parents have larger labels than their children. \r\nWhich of the above statements are true?\r\n",
        "answer": [
            "(a) and (b)",
            "(c) and (d)",
            "(a), (b) and (c)",
            "(a), (b), (c) and (d)"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> <ul><li> Depth - first search is used to traverse a rooted tree. <b>Correct</b></li><li> Pre - order, Post-order and Inorder are used to list the vertices of an ordered rooted tree. <b>Correct</b></li><li>Huffman’s algorithm is used to find an optimal binary tree with given weights. <li><b>Correct</b></li><li>Topological sorting provides a labelling such that the parents have larger labels than their children.<b>Correct</b></li></li></ul>\r\nSo, option (D) is correct.</div>",
        "keyword": "Tree Traversals"
    },
    {
        "question": "The inorder and preorder Traversal of binary Tree are dbeafcg and abdecfg respectively. The post-order Traversal is __________.",
        "answer": [
            "dbefacg",
            " debfagc",
            "dbefcga",
            "debfgca"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> Inorder and preorder Traversal of binary Tree are dbeafcg and abdecfg respectively. \r\nFrom preorder(Parent left right) and inorder ( left parent right) we can easily find post order. \r\nFrom preorder(a(bdecfg)), it is clear that a is parent node(root node), Now we will look for left subttree in inorder traversal i.e. dbe and fcg.\r\nTo find root node and left subtree and right subtree of these subtree we will do the same process as above:\r\nNow see this scenario in graph:\r\n<img alt=\"22 (8)\" class=\"alignnone size-medium wp-image-198509\" src=\"https://www.geeksforgeeks.org/wp-content/uploads/22-8.png\">\r\nNow from above tree we can easily find out the post order(left right parent):\r\ni.e. debfgca.\r\nSo, option (D) is correct.</img></div>",
        "keyword": "Tree Traversals"
    },
    {
        "question": "Level order Traversal of a rooted Tree can be done by starting from root and performing:",
        "answer": [
            "Breadth First Search",
            "Depth First Search",
            "Root Search",
            "Deep Search"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Level order Traversal of a rooted Tree can be done by starting from root and performing <b>Breadth First Search</b>.\r\nFor more information on Level order Traversal Refer:<a href=\"https://www.geeksforgeeks.org/level-order-tree-traversal/\" rel=\"noopener\" target=\"_blank\">Level Order Tree Traversal</a>\r\nOption (A) is correct.\r\n\r\n</div>",
        "keyword": "Tree Traversals"
    },
    {
        "question": "The in-order traversal of a tree resulted in FBGADCE. Then the pre-order traversal of that tree would result in",
        "answer": [
            "FGBDECA",
            "ABFGCDE",
            "BFGCDEA",
            "AFGBDEC"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> The Inorder traversal of the tree can be seen as:\r\n\r\n<img src=\"https://www.geeksforgeeks.org/wp-content/uploads/Untitled-Diagram-1.png\"/>\r\n\r\nSo, the preorder traversal of the following tree is ABFGCDE.\r\n\r\nOption (B) is correct.</div>",
        "keyword": "Tree Traversals"
    },
    {
        "question": "Suppose the numbers 7, 5, 1, 8, 3, 6, 0, 9, 4, 2 are inserted in that order into an initially empty binary search tree. The binary search tree uses the usual ordering on natural numbers. What is the inorder traversal sequence of the resultant tree?\r\n",
        "answer": [
            "7 5 1 0 3 2 4 6 8 9",
            "0 2 4 3 1 6 5 9 8 7",
            "0 1 2 3 4 5 6 7 8 9",
            "9 8 6 4 2 3 0 1 5 7"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> The numbers 7, 5, 1, 8, 3, 6, 0, 9, 4, 2 are inserted in that order into an initially empty binary search tree with the usual ordering on natural numbers. The inorder sequence of such a binary search tree always yields to the numbers arranged in <strong>ascending order</strong>. \r\nSo, option (C) is correct.</div>",
        "keyword": "Tree Traversals"
    },
    {
        "question": "Assume that the operators +, −, × are left associative and ^ is right associative. The order of precedence (from highest to lowest) is ^, ×, +, −. The postfix expression corresponding to the infix expression is\r\na + b × c − d ^ e ^ f\n",
        "answer": [
            "abc x  + def ^ ^ −",
            "abc x + de ^ f ^ −",
            "ab + c × d − e^f^",
            "− + a × b c^^ def"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> The postfix expression:\r\n<pre>\r\na + b × c − ( d ^( e ^ f))\r\na + b × c − ( d ^( e f ^ ))\r\na + b × c − ( d e f ^ ^)\r\n(a + (b × c)) − d  e f ^ ^\r\n(a + (b c x)) − d  e f ^ ^\r\n(a (b c x) +) − d  e f ^ ^\r\n(a b c x +) - (d e f ^ ^)\r\n(a b c x +) - (d e f ^ ^)\r\na b c x + d e f ^ ^ -\r\n</pre>\r\n\r\nSo, option (A) is correct.</div>",
        "keyword": "Tree Traversals"
    },
    {
        "question": "\r\nIf Tree-1 and Tree-2 are the trees indicated below :\r\n\r\n\r\n\r\nWhich traversals of Tree-1 and Tree-2, respectively, will produce the same sequence?\r\n\r\n",
        "answer": [
            "Preorder, postorder",
            "Postorder, inorder",
            " Postorder, preorder",
            "Inorder, preorder"
        ],
        "correct": "B",
        "explain": "None",
        "keyword": "Tree Traversals"
    },
    {
        "question": "What is recurrence for worst case of QuickSort and what is the time complexity in Worst case?",
        "answer": [
            "Recurrence is T(n) = T(n-2) + O(n) and time complexity is O(n^2)",
            "Recurrence is T(n) = T(n-1) + O(n) and time complexity is O(n^2)",
            "Recurrence is T(n) = 2T(n/2) + O(n) and time complexity is O(nLogn)",
            "Recurrence is T(n) = T(n/10) + T(9n/10) + O(n) and time complexity is O(nLogn)"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> The worst case of QuickSort occurs when the picked pivot is always one of the corner elements in sorted array.  In worst case, QuickSort recursively calls one subproblem with size 0 and other subproblem with size (n-1).  So recurrence is\r\n\r\nT(n) = T(n-1) + T(0) + O(n)\r\n\r\nThe above expression can be rewritten as \r\n\r\nT(n) = T(n-1) + O(n)\r\n\r\n[sourcecode language=\"C\"]\r\nvoid exchange(int *a, int *b)\r\n{\r\n  int temp;\r\n  temp = *a;\r\n  *a   = *b;\r\n  *b   = temp;\r\n}\r\n \r\nint partition(int arr[], int si, int ei)\r\n{\r\n  int x = arr[ei];\r\n  int i = (si - 1);\r\n  int j;\r\n \r\n  for (j = si; j &lt;= ei - 1; j++)\r\n  {\r\n    if(arr[j] &lt;= x)\r\n    {\r\n      i++;\r\n      exchange(&amp;arr[i], &amp;arr[j]);\r\n    }\r\n  }\r\n \r\n  exchange (&amp;arr[i + 1], &amp;arr[ei]);\r\n  return (i + 1);\r\n}\r\n \r\n/* Implementation of Quick Sort\r\narr[] --&gt; Array to be sorted\r\nsi  --&gt; Starting index\r\nei  --&gt; Ending index\r\n*/\r\nvoid quickSort(int arr[], int si, int ei)\r\n{\r\n  int pi;    /* Partitioning index */\r\n  if(si &lt; ei)\r\n  {\r\n    pi = partition(arr, si, ei);\r\n    quickSort(arr, si, pi - 1);\r\n    quickSort(arr, pi + 1, ei);\r\n  }\r\n}\r\n[/sourcecode]\r\n</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Suppose we have a O(n) time algorithm that finds median of an unsorted array.  \r\n\r\nNow consider a QuickSort implementation where we first find median using the above algorithm, then use median as pivot.  What will be the worst case time complexity of this modified QuickSort.",
        "answer": [
            "O(n^2 Logn)",
            "O(n^2)",
            "O(n Logn Logn)",
            "O(nLogn)"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> If we use median as a pivot element, then the recurrence for all cases becomes\r\n\r\nT(n) = 2T(n/2) + O(n)\r\n\r\nThe above recurrence can be solved using <a href=\"http://en.wikipedia.org/wiki/Master_theorem\" target=\"_blank\">Master Method</a>.  It falls in case 2 of master method.</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Given an unsorted array. The array has this property that every element in array is at most k distance from its position in sorted array where k is a positive integer smaller than size of array.  Which sorting algorithm can be easily modified for sorting this array and what is the obtainable time complexity?",
        "answer": [
            "Insertion Sort with time complexity O(kn)",
            "Heap Sort with time complexity O(nLogk)",
            "Quick Sort with time complexity O(kLogk)",
            "Merge Sort with time complexity O(kLogk)"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> 1) to sort the array firstly create a min-heap with first k+1 elements and a separate array as resultant array.\r\n2) because elements are at most k distance apart from original position so, it is guranteed that the smallest element will be in this K+1 elements.\r\n3) remove the smallest element from the min-heap(extract min) and put it in the result array.\r\n4) Now,insert another element from the unsorted array into the mean-heap, now,the second smallest element will be in this, perform extract min and continue this process until no more elements are in the unsorted array.finally, use simple heap sort for the remaining elements\r\n\r\nTime Complexity\r\n\r\n------------------------\r\n\r\n1) O(k) to build the initial min-heap\r\n\r\n2) O((n-k)logk) for remaining elements...\r\n\r\n3) 0(1) for extract min\r\n\r\nso overall O(k) + O((n-k)logk) + 0(1) = O(nlogk)</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Which of the following is not true about comparison based sorting algorithms?",
        "answer": [
            "The minimum possible time complexity of a comparison based sorting algorithm is O(nLogn) for a random input array",
            "Any comparison based sorting algorithm can be made stable by using position as a criteria when two elements are compared",
            "Counting Sort is not a comparison based sorting algorithm",
            "Heap Sort is not a comparison based sorting algorithm."
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> See <a href=\"http://www.geeksforgeeks.org/lower-bound-on-comparison-based-sorting-algorithms/\">http://www.geeksforgeeks.org/lower-bound-on-comparison-based-sorting-algorithms/</a> for point A.  See <a href=\"http://www.geeksforgeeks.org/stability-in-sorting-algorithms/\">http://www.geeksforgeeks.org/stability-in-sorting-algorithms/</a> for B.  C is true, count sort is an Integer Sorting algorithm.</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "What is time complexity of fun()?  \r\n\r\n\r\nint fun(int n)\r\n{\r\n  int count = 0;\r\n  for (int i = n; i > 0; i /= 2)\r\n     for (int j = 0; j < i; j++)\r\n        count += 1;\r\n  return count;\r\n}\r\n",
        "answer": [
            "O(n^2) ",
            "O(nLogn)",
            "O(n)",
            "O(nLognLogn)"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> For a input integer n, the innermost statement of fun() is executed following times.  \r\n\r\nn + n/2 + n/4 + ... 1\r\n\r\nSo time complexity T(n) can be written as\r\n\r\nT(n) = O(n + n/2 + n/4 + ... 1) = O(n)\r\n\r\nThe value of count is also n + n/2 + n/4 + .. + 1\r\n\r\n\r\n</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "What is the time complexity of fun()?\r\n\r\n\r\nint fun(int n)\r\n{\r\n  int count = 0;\r\n  for (int i = 0; i < n; i++)\r\n     for (int j = i; j > 0; j--)\r\n        count = count + 1;\r\n  return count;\r\n} \r\n",
        "answer": [
            "Theta (n)",
            "Theta (n^2)",
            "Theta (n*Logn)",
            "Theta (nLognLogn)"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> The time complexity can be calculated by counting number of times the expression \"count = count + 1;\" is executed.  The expression is executed 0 + 1 + 2 + 3 + 4 + .... + (n-1)  times. \r\n\r\nTime complexity  = Theta(0 + 1 + 2 + 3 + .. + n-1) = Theta (n*(n-1)/2) = Theta(n<sup>2</sup>)</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "The recurrence relation capturing the optimal time of the Tower of Hanoi problem with n discs is. (GATE CS 2012)",
        "answer": [
            "T(n) = 2T(n – 2) + 2",
            "T(n) = 2T(n – 1) + n\r\n",
            "T(n) = 2T(n/2) + 1",
            "T(n) = 2T(n – 1) + 1"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> Following are the steps to follow to solve <a href=\"http://en.wikipedia.org/wiki/Tower_of_Hanoi\">Tower of Hanoi</a> problem recursively.\r\n<pre>Let the three pegs be A, B and C. The goal is to move n pegs from A to C.\r\nTo move n discs from peg A to peg C:\r\n    move n-1 discs from A to B. This leaves disc n alone on peg A\r\n    move disc n from A to C\r\n    move n?1 discs from B to C so they sit on disc n</pre>\r\nThe recurrence function T(n) for time complexity of the above recursive solution can be written as following.\r\n\r\nT(n) = 2T(n-1) + 1</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Let w(n) and A(n) denote respectively, the worst case and average case running time of an algorithm executed on an input of size n. which of the following is ALWAYS TRUE? (GATE CS 2012)\r\n(A) \r\n(B) \r\n(C)  \r\n(D) ",
        "answer": [
            "A",
            "B",
            "C",
            "D"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> The worst case time complexity is always greater than or same as the average case time complexity.</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Which of the following is not O(n^2)?",
        "answer": [
            "(15^10) * n + 12099",
            "n^1.98",
            "n^3 / (sqrt(n))",
            "(2^20) * n "
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> The order of growth of option c is n<sup>2.5</sup> which is higher than n<sup>2</sup>.</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Which of the given options provides the increasing order of asymptotic complexity of functions f1, f2, f3 and f4?\r\n\r\n  f1(n) = 2^n\r\n  f2(n) = n^(3/2)\r\n  f3(n) = nLogn\r\n  f4(n) = n^(Logn)",
        "answer": [
            "f3, f2, f4, f1",
            "f3, f2, f1, f4",
            "f2, f3, f1, f4",
            "f2, f3, f4, f1"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>\r\n  f1(n) = 2^n\r\n  f2(n) = n^(3/2)\r\n  f3(n) = nLogn\r\n  f4(n) = n^(Logn)</pre>\r\n\r\nExcept f3, all other are exponential.  So f3 is definitely first in output.  Among remaining, n^(3/2) is next.   \r\n\r\nOne way to compare f1 and f4 is to take Log of both functions.  Order of growth of Log(f1(n)) is Θ(n) and order of growth of Log(f4(n)) is Θ(Logn * Logn).  Since Θ(n) has higher growth than Θ(Logn * Logn), f1(n) grows faster than f4(n).\r\n\r\n\r\n<strong>Following is another way to compare f1 and f4.</strong>\r\n\r\nLet us compare f4 and f1.  Let us take few values to compare<pre>\r\nn = 32, f1 = 2^32, f4 = 32^5 = 2^25\r\nn = 64, f1 = 2^64, f4 = 64^6 = 2^36\r\n...............\r\n............... </pre>\r\n\r\nAlso see <a href=\"http://www.wolframalpha.com/input/?i=2^n+vs+n^%28log+n%29\">http://www.wolframalpha.com/input/?i=2^n+vs+n^%28log+n%29</a>\r\n\r\nThanks to fella26 for suggesting the above explanation.\r\n\r\n\r\n\r\n</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "What is the best time complexity of bubble sort?\r\n",
        "answer": [
            "N^2",
            "NlogN",
            "N",
            "N(logN)^2"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> The bubble sort is at its best if the input data is sorted. i.e. If the input data is sorted in the same order as expected output. This can be achieved by using one boolean variable. The boolean variable is used to check whether the values are swapped at least once in the inner loop.\r\nConsider the following code snippet:\r\n[sourcecode language=\"C\"]\r\nint main()\r\n{   \r\n    int arr[] = {10, 20, 30, 40, 50}, i, j, isSwapped;\r\n    int n = sizeof(arr) / sizeof(*arr);\r\n    isSwapped = 1;\r\n    for(i = 0; i &lt; n - 1 &amp;&amp; isSwapped; ++i)\r\n    {\r\n        isSwapped = 0;\r\n        for(j = 0; j &lt; n - i - 1; ++j)\r\n            if (arr[j] &gt; arr[j + 1])\r\n            {\r\n                swap(&amp;arr[j], &amp;arr[j + 1]);\r\n                isSwapped = 1;\r\n            }\r\n    }\r\n    for(i = 0; i &lt; n; ++i)\r\n        printf(\"%d \", arr[i]);\r\n    return 0;\r\n}\r\n[/sourcecode]\r\nPlease observe that in the above code, the outer loop runs only once.</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "What is the worst case time complexity of insertion sort where position of the data to be inserted is calculated using binary search? \r\n",
        "answer": [
            "N",
            "NlogN",
            "N^2",
            "N(logN)^2"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Applying binary search to calculate the position of the data to be inserted doesn't reduce the time complexity of insertion sort. This is because insertion of a data at an appropriate position involves two steps:\r\n1. Calculate the position.\r\n2. Shift the data from the position calculated in step #1 one step right to create a gap where the data will be inserted.\r\n\r\nUsing binary search reduces the time complexity in step #1 from O(N) to O(logN). But, the time complexity in step #2 still remains O(N). So, overall complexity remains O(N^2).</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": " The tightest lower bound on the number of comparisons, in the worst case, for comparison-based sorting is of the order of",
        "answer": [
            "N",
            "N^2",
            "NlogN",
            "N(logN)^2"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> The number of comparisons that a comparison sort algorithm requires increases in proportion to Nlog(N), where N is the number of elements to sort. This bound is asymptotically tight:\r\n\r\nGiven a list of distinct numbers (we can assume this because this is a worst-case analysis), there are N factorial permutations exactly one of which is the list in sorted order. The sort algorithm must gain enough information from the comparisons to identify the correct permutations. If the algorithm always completes after at most f(N) steps, it cannot distinguish more than 2^f(N) cases because the keys are distinct and each comparison has only two possible outcomes. Therefore,\r\n\r\n2^f(N) &gt;= N! or equivalently f(N) &gt;= log(N!).\r\nSince log(N!) is Omega(NlogN), the answer is NlogN.\r\nFor more details, <a href=\"http://en.wikipedia.org/wiki/Comparison_sort\" target=\"_blank\">read here</a>\n</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "In a modified merge sort, the input array is splitted at a position one-third of the length(N) of the array. Which of the following is the tightest upper bound on time complexity of this modified Merge Sort.",
        "answer": [
            "N(logN base 3)",
            "N(logN base 2/3)",
            "N(logN base 1/3)",
            "N(logN base 3/2)"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> The time complexity is given by:\r\nT(N) = T(N/3) + T(2N/3) + N\r\nSolving the above recurrence relation gives, T(N) = N(logN base 3/2)</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "What is the time complexity of the below function?\r\n\r\nvoid fun(int n, int arr[])\r\n{\r\n    int i = 0, j = 0;\r\n    for(; i < n; ++i)\r\n        while(j < n && arr[i] < arr[j])\r\n            j++;\r\n}\r\n",
        "answer": [
            "O(n)",
            "O(n^2)",
            "O(nlogn)",
            "O(n(logn)^2)"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> In the first look, the time complexity seems to be O(n^2) due to two loops. But, please note that the variable <strong>j</strong> is not initialized for each value of variable <strong>i</strong>. So, the inner loop runs at most <strong>n</strong> times. Please observe the difference between the function given in question and the below function:\r\n[sourcecode language=\"C\"]\r\nvoid fun(int n, int arr[])\r\n{\r\n    int i = 0, j = 0;\r\n    for(; i &lt; n; ++i)\r\n    {\r\n        j = 0;\r\n        while(j &lt; n &amp;&amp; arr[i] &lt; arr[j])\r\n            j++;\r\n    }\r\n}\r\n[/sourcecode]</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "In a competition, four different functions are observed. All the functions use a single for loop and within the for loop, same set of statements are executed. Consider the following for loops:\r\n\r\nA) for(i = 0; i < n; i++)\r\n\r\nB) for(i = 0; i < n; i += 2)\r\n\r\nC) for(i = 1; i < n; i *= 2)\r\n\r\nD) for(i = n; i > -1; i /= 2)\r\n\r\nIf n is the size of input(positive), which function is most efficient(if the task to be performed is not an issue)?",
        "answer": [
            "A",
            "B",
            "C",
            "D"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> The time complexity of first for loop is O(n).\r\nThe time complexity of second for loop is O(n/2), equivalent to O(n) in asymptotic analysis.\r\nThe time complexity of third for loop is O(logn).\r\nThe fourth for loop doesn't terminate.</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "The following statement is valid.\r\n\r\nlog(n!) = (n log n).",
        "answer": [
            "True",
            "False"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Order of growth of <img alt=\"\\log n!\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"24\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-9f193254e20e633a980b664bce76256c_l3.png\" style=\"vertical-align: -5px;\" title=\"Rendered by QuickLaTeX.com\" width=\"60\"/> and <img alt=\"n\\log n\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"24\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-a18197d6213454fa349251bca29bc1b6_l3.png\" style=\"vertical-align: -5px;\" title=\"Rendered by QuickLaTeX.com\" width=\"74\"/> is same for large values of <img alt=\"n\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"12\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-ad7ed49d64e4f28446c48c53a0e2718a_l3.png\" style=\"vertical-align: 0px;\" title=\"Rendered by QuickLaTeX.com\" width=\"15\"/>, i.e., <!--more--> <img alt=\"\\theta (\\log n!) = \\theta (n\\log n)\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"27\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-694bff873262e07993e28d06ed350ea9_l3.png\" style=\"vertical-align: -7px;\" title=\"Rendered by QuickLaTeX.com\" width=\"235\"/>.  So time complexity of fun() is <img alt=\" \\theta (n\\log n)\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"27\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-6bc73f16b737f68baf73189386575164_l3.png\" style=\"vertical-align: -7px;\" title=\"Rendered by QuickLaTeX.com\" width=\"105\"/>.\r\n\r\n\r\nThe expression  <img alt=\"\\theta (\\log n!) = \\theta (n\\log n)\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"27\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-694bff873262e07993e28d06ed350ea9_l3.png\" style=\"vertical-align: -7px;\" title=\"Rendered by QuickLaTeX.com\" width=\"235\"/> can be easily derived from following <a href=\"http://en.wikipedia.org/wiki/Stirling%27s_approximation\">Stirling's approximation (or Stirling's formula)</a>.  \r\n\r\n   <img alt=\" \\log n! = n\\log n - n +O(\\log(n))\\ \" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"27\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-47bbf749c44c1f6e576c93d33e542a2e_l3.png\" style=\"vertical-align: -7px;\" title=\"Rendered by QuickLaTeX.com\" width=\"361\"/></div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "What does it mean when we say that an algorithm X is asymptotically more efficient than Y?",
        "answer": [
            "X will be a better choice for all inputs",
            "X will be a better choice for all inputs except possibly small inputs",
            "X will be a better choice for all inputs except possibly large inputs",
            "Y will be a better choice for small inputs"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> In <a href=\"http://www.geeksforgeeks.org/analysis-of-algorithms-set-1-asymptotic-analysis/\" target=\"_blank\">asymptotic analysis</a> we consider growth of algorithm in terms of input size.  An algorithm X is said to be asymptotically better than Y if X takes smaller  time than y for all input sizes n larger than a value n0 where n0 &gt; 0.</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "What is the time complexity of Floyd–Warshall algorithm to calculate all pair shortest path in a graph with n vertices?",
        "answer": [
            "O(n^2logn)",
            "Theta(n^2logn)",
            "Theta(n^4)",
            "Theta(n^3)"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> Floyd–Warshall algorithm uses three nested loops to calculate all pair shortest path. So, time complexity is Thete(n^3). Read <a href=\"http://www.geeksforgeeks.org/dynamic-programming-set-16-floyd-warshall-algorithm/\" target=\"_blank\">here</a> for more details.</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "A list of n string, each of length n, is sorted into lexicographic order using the merge-sort algorithm. The worst case running time of this computation is ",
        "answer": [
            "O (n log n)",
            "O (n2 log n)",
            "O (n2 + log n)",
            "O (n2)"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> The recurrence tree for merge sort will have height Log(n).  And O(n^2) work will be done at each level of the recurrence tree (Each level involves n comparisons and a comparison takes O(n) time in worst case).  So time complexity of this Merge Sort will be <img alt=\"O (n^2 log n) \" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"31\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-3350e1fc1bc92af3f1dab7972d05f817_l3.png\" style=\"vertical-align: -7px;\" title=\"Rendered by QuickLaTeX.com\" width=\"116\"/>.</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "In quick sort, for sorting n elements, the (n/4)th smallest element is selected as pivot using an O(n) time algorithm. What is the worst case time complexity of the quick sort?\r\n",
        "answer": "None",
        "correct": "None",
        "explain": "None",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Consider the Quicksort algorithm. Suppose there is a procedure for finding a pivot element which splits the list into two sub-lists each of which contains at least one-fifth of the elements. Let T(n) be the number of comparisons required to sort n elements. Then ",
        "answer": [
            " T(n) <= 2T(n/5) + n ",
            "T(n) <= T(n/5) + T(4n/5) + n",
            "T(n) <= 2T(4n/5) + n",
            " T(n) <= 2T(n/2) + n"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> For the case where n/5 elements are in one subset, T(n/5) comparisons are needed for the first subset with n/5 elements, T(4n/5) is for the rest 4n/5 elements, and n is for finding the pivot.  \r\n\r\nIf there are more than n/5 elements in one set then other set will have less than 4n/5 elements and time complexity will be less than  T(n/5) + T(4n/5) + n because recursion tree will be more balanced.</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Consider the following functions: \r\n  f(n)   = 2^n\r\n  g(n)   = n!\r\n  h(n)   = n^logn  \r\n\r\nWhich of the following statements about the asymptotic behavior of f(n), g(n), and h(n) is true?\r\n(A) f(n) = O(g(n)); g(n) = O(h(n))\r\n(B) f(n) = (g(n)); g(n) = O(h(n))\r\n(C) g(n) = O(f(n)); h(n) = O(f(n))\r\n(D) h(n) = O(f(n)); g(n) = (f(n))",
        "answer": [
            "A",
            "B",
            "C",
            "D"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> According to order of growth:  h(n) &lt; f(n) &lt; g(n)  (g(n) is asymptotically greater than f(n) and f(n) is asymptotically greater than h(n) )  \r\nWe can easily see above order by taking logs of the given 3 functions<pre>\r\n   lognlogn &lt; n &lt; log(n!)  (logs of the given f(n), g(n) and h(n)).</pre>\r\n\r\nNote that log(n!) =  <img alt=\"\\theta\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"19\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-a372b7ef1ffaec3b4ad80e0141550990_l3.png\" style=\"vertical-align: 0px;\" title=\"Rendered by QuickLaTeX.com\" width=\"11\"/>(nlogn)</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "In the following C function, let n >= m.\r\n\r\nint gcd(n,m)\r\n{\r\n  if (n%m ==0) return m;  \r\n  n = n%m;\r\n  return gcd(m, n);\r\n}\r\n\r\n\r\nHow many recursive calls are made by this function?\r\n(A)\t(logn)\r\n(B)\t(n)\r\n(C)\t(loglogn)\r\n(D)\t(sqrt(n))",
        "answer": [
            "A",
            "B",
            "C",
            "D"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Above code is implementation of the <a href=\"http://en.wikipedia.org/wiki/Euclidean_algorithm\">Euclidean algorithm</a> for finding Greatest Common Divisor (GCD).\r\nPlease see <a href=\"http://mathworld.wolfram.com/EuclideanAlgorithm.html\">http://mathworld.wolfram.com/EuclideanAlgorithm.html</a> for time complexity.</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Which of the following sorting algorithms has the lowest worst-case complexity?",
        "answer": [
            "Merge Sort",
            "Bubble Sort",
            "Quick  Sort",
            "Selection Sort"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Worst case complexities for the above sorting algorithms are as follows:\r\nMerge Sort — nLogn\r\nBubble Sort — n^2\r\nQuick Sort — n^2\r\nSelection Sort — n^2</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Consider the following functions\r\n\r\nWhich of the following is true? (GATE CS 2000)\r\n(a) h(n) is 0(f(n))\r\n(b) h(n) is 0(g(n))\r\n(c) g(n) is not 0(f(n))\r\n(d) f(n) is 0(g(n))",
        "answer": [
            "a",
            "b",
            "c",
            "d"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> g(n) = 2^<img alt=\"(\\sqrt{n} \\log{n} )\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"28\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-3a1352b3cd789f9759b99e37a5e22590_l3.png\" style=\"vertical-align: -7px;\" title=\"Rendered by QuickLaTeX.com\" width=\"113\"/> = n^<img alt=\"(\\sqrt{n})\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"28\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-3c5eeab49060a80cb9f60f01a3e46435_l3.png\" style=\"vertical-align: -7px;\" title=\"Rendered by QuickLaTeX.com\" width=\"54\"/>  \r\n\r\nf(n) and g(n) are of same asymptotic order and following statements are true.\r\n f(n) = O(g(n)) \r\n g(n) = O(f(n)).\r\n\r\n(a) and (b) are false because n! is of asymptotically higher order than n^<img alt=\"(\\sqrt{n})\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"28\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-3c5eeab49060a80cb9f60f01a3e46435_l3.png\" style=\"vertical-align: -7px;\" title=\"Rendered by QuickLaTeX.com\" width=\"54\"/>.</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": " Consider the following three claims \r\nI\t(n + k)^m = (n^m), where k and m are constants \r\nII\t2^(n + 1) = 0(2^n) \r\nIII\t2^(2n + 1) = 0(2^n) \r\nWhich of these claims are correct? (GATE CS 2003)\r\n\r\n",
        "answer": [
            "I and II ",
            "I and III",
            "II and III ",
            "I, II and III "
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>\r\n(I)  (n+m)^k = n^k + c1*n^(k-1) + ... k^m = <img alt=\"\\theta\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"19\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-a372b7ef1ffaec3b4ad80e0141550990_l3.png\" style=\"vertical-align: 0px;\" title=\"Rendered by QuickLaTeX.com\" width=\"11\"/>(n^k)\r\n(II)  2^(n+1) = 2*2^n = O(2^n)\r\n</pre></div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Let s be a sorted array of n integers. Let t(n) denote the time taken for the most efficient algorithm to determined if there are two elements with sum less than 1000 in s. which of the following statements is true? (GATE CS 2000)\r\na)\tt (n) is 0 (1)\r\nb)\tn < t (n) < n\r\nc)\tn log 2 n < t (n) <  \r\nd)\tt (n) = \n",
        "answer": [
            "a",
            "b",
            "c",
            "d"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Let array be sorted in ascending order, if sum of first two elements is less than 1000 then there are  two elements with sum less than 1000 otherwise not.  For array sorted in descending order we need to check last two elements.  For an array data structure, number of operations are fixed in both the cases and not dependent on n, complexity is O(1)</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Consider the following function\r\n int unknown(int n) {\r\n    int i, j, k = 0;\r\n    for (i  = n/2; i <= n; i++)\r\n        for (j = 2; j <= n; j = j * 2)\r\n            k = k + n/2;\r\n    return k;\r\n }\r\nWhat is the return value of the function? (GATE CS 2013)\r\n(A) \r\n(B) \r\n(C) \r\n(D)  ",
        "answer": [
            "A",
            "B",
            "C",
            "D"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> In the below explanation, '^' is used to represent exponent:\r\nThe outer loop runs n/2 or Theta(n) times.\r\nThe inner loop runs (Logn) times (Note that j is multiplied by 2 in every iteration). \r\nSo the statement \"k = k + n/2;\" runs Theta(nLogn) times. \r\nThe statement increases value of k by n/2. \r\nSo the value of k becomes n/2*Theta(nLogn) which is Theta((n^2) * Logn). \r\n</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "The number of elements that can be sorted in  time using heap sort is ",
        "answer": "None",
        "correct": "None",
        "explain": "None",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Consider the following two functions. What are time complexities of the functions?\r\n\r\n\r\nint fun1(int n)\r\n{\r\n    if (n <= 1) return n;\r\n    return 2*fun1(n-1);\r\n}\r\n\n\r\nint fun2(int n)\r\n{\r\n    if (n <= 1) return n;\r\n    return fun2(n-1) + fun2(n-1);\r\n}\r\n\n",
        "answer": [
            "O(2^n) for both fun1() and fun2()",
            "O(n) for fun1() and O(2^n) for fun2()",
            "O(2^n) for fun1() and O(n) for fun2()",
            "O(n) for both fun1() and fun2()"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Time complexity of fun1() can be written as \r\nT(n) = T(n-1) + C which is O(n)\r\n\r\nTime complexity of fun2() can be written as \r\nT(n) = 2T(n-1) + C which is O(2^n)\r\n\r\n</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "In quick sort, for sorting n elements, the (n/4)th smallest element is selected as pivot using an O(n) time algorithm. What is the worst case time complexity of the quick sort?\n<pre>\r\n(A) (n)\r\n(B) (nLogn)\r\n(C) (n^2)\r\n(D) (n^2 log n) </pre>\r\n\r\n ",
        "answer": [
            "A",
            "B",
            "C",
            "D"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Answer(B)\r\nThe recursion expression becomes:\r\n\r\nT(n) = T(n/4) + T(3n/4) + cn\r\n\r\nAfter solving the above recursion, we get \\theta(nLogn).</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Consider the Quicksort algorithm. Suppose there is a procedure for finding a pivot element which splits the list into two sub-lists each of which contains at least one-fifth of the elements. Let T(n) be the number of comparisons required to sort n elements. Then \r\n",
        "answer": [
            "T(n) <= 2T(n/5) + n ",
            "T(n) <= T(n/5) + T(4n/5) + n",
            "T(n) <= 2T(4n/5) + n",
            " T(n) <= 2T(n/2) + n"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> For the case where n/5 elements are in one subset, T(n/5) comparisons are needed for the first subset with n/5 elements, T(4n/5) is for the rest 4n/5 elements, and n is for finding the pivot.  \r\n\r\nIf there are more than n/5 elements in one set then other set will have less than 4n/5 elements and time complexity will be less than  T(n/5) + T(4n/5) + n because recursion tree will be more balanced.</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Consider the following segment of C-code:\r\n\r\n  int j, n;\r\n  j = 1;\r\n  while (j <= n)\r\n        j = j*2;  \r\n\r\nThe number of comparisons made in the execution of the loop for any n > 0 is:  \r\n\r\nBase of Log is 2 in all options.",
        "answer": [
            "CEIL(logn) + 2",
            "n",
            "CEIL(logn)",
            "FLOOR(logn) + 2"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>\r\nWe can see it by taking few examples like n = 1, n = 3, etc.\r\n\r\nFor example, for n=5 we have the following (4) comparisons:\r\n------------------------\r\n1 &lt;= 5 (T)\r\n2 &lt;= 5 (T)\r\n4 &lt;= 5 (T)\r\n8 &lt;= 5 (F)\r\n\r\n------------------------\r\nFLOOR(log_2 n)+2 = FLOOR(log_2 5) + 2 = FLOOR(2.3) + 2 = 2 + 2 = 4</pre></div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Consider the following C-program fragment in which i, j and n are integer variables.",
        "answer": "None",
        "correct": "None",
        "explain": "None",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "The minimum number of comparisons required to find the minimum and the maximum of 100 numbers is ______________.",
        "answer": [
            "148",
            "147",
            "146",
            "140"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Steps to find minimum and maximum element out of n numbers:\r\n<pre>\r\n1. Pick 2 elements(a, b), compare them. (say a &gt; b)\r\n2. Update min by comparing (min, b)\r\n3. Update max by comparing (max, a)</pre>\r\n\r\nTherefore, we need 3 comparisons for each 2 elements, so total number of required comparisons will be (3n)/2 - 2, because we do not need to update min or max in the very first step.\r\n\r\nRecurrence relation will be:\r\n<pre>T(n) = T(⌈n/2⌉)+T(⌊n/2⌋)+2 = 2T(n/2)+2 = ⌈3n/2⌉-2</pre>\r\n\r\nBy putting the value n=100, (3*100/2)-2 = <b>148</b> which is answer.\r\n\r\n </div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Consider the following pseudo code. What is the total number of multiplications to be performed?\r\nD = 2\r\nfor i = 1 to n do\r\n   for j = i to n do\r\n      for k = j + 1 to n do\r\n           D = D * 3",
        "answer": [
            " Half of the product of the 3 consecutive integers.",
            "One-third of the product of the 3 consecutive integers.",
            "One-sixth of the product of the 3 consecutive integers.",
            " None of the above."
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> The statement “D = D * 3” is executed n*(n+1)*(n-1)/6 times. Let us see how. <br/>For i = 1, the multiplication statement is executed (n-1) + (n-2) + .. 2 + 1 times. <br/>For i = 2, the statement is executed (n-2) + (n-3) + .. 2 + 1 times <br/>……………………….. <br/>………………………. <br/>For i = n-1, the statement is executed once. <br/>For i = n, the statement is not executed at all <br/><br/>So overall the statement is executed following times <br/>[(n-1) + (n-2) + .. 2 + 1] + [(n-2) + (n-3) + .. 2 + 1] + … + 1 + 0 <br/><br/>The above series can be written as <br/>S = [n*(n-1)/2 + (n-1)*(n-2)/2 + ….. + 1] <br/><br/>The sum of above series can be obtained by trick of subtraction the series from standard Series S1 = n2 + (n-1)2 + .. 12. The sum of this standard series is n*(n+1)*(2n+1)/6 <br/><br/>S1 – 2S = n + (n-1) + … 1 = n*(n+1)/2 <br/>2S = n*(n+1)*(2n+1)/6 – n*(n+1)/2 <br/>S = n*(n+1)*(n-1)/6</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "You have an array of n elements. Suppose you implement quicksort by always choosing the central element of the array as the pivot. Then the tightest upper bound for the worst case performance is",
        "answer": [
            "O(n2)",
            "O(nLogn)",
            "Theta(nLogn)",
            "O(n3)"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> For any input, there are some permutations for which worst case will be <em>O(n<sup>2</sup>)</em>.  In some case, choosing the middle element minimizes the chances of encountering <em>O(n<sup>2</sup>), </em>but in worst case it can go to <em>O(n<sup>2</sup>).</em> Whichever element we take as Pivot, either first or middle, worst case will be <em>O(n<sup>2</sup>) </em>since Pivot is fixed in position. While choosing a random pivot minimizes the chances of encountering worst case i.e. <em>O(n<sup>2</sup>).</em>\r\n\r\nRefer <a href=\"http://www.geeksforgeeks.org/quick-sort/\" rel=\"noopener\" target=\"_blank\">this</a> article on Quick Sort.</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Consider the following C-function:\r\n\r\n\r\ndouble foo (int n)\r\n{\r\n    int i;\r\n    double sum;\r\n    if (n = = 0) return 1.0;\r\n    else\r\n    {\r\n        sum = 0.0;\r\n        for (i = 0; i < n; i++)\r\n            sum += foo (i);\r\n        return sum;\r\n    }\r\n}\r\n\r\n\r\nThe space complexity of the above function is:",
        "answer": [
            "O(1)",
            "O(n)",
            "O(n!)",
            "O(nn)"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Note that the function foo() is recursive. <a href=\"http://www.geeksforgeeks.org/g-fact-86/\" target=\"_blank\">Space complexity</a> is O(n) as there can be at most O(n) active functions (function call frames) at a time.  </div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Consider the following C-function:\r\n\r\n\r\ndouble foo (int n)\r\n{\r\n    int i;\r\n    double sum;\r\n    if (n = = 0) return 1.0;\r\n    else\r\n    {\r\n        sum = 0.0;\r\n        for (i = 0; i < n; i++)\r\n            sum += foo (i);\r\n        return sum;\r\n    }\r\n}\r\n\r\n\r\nSuppose we modify the above function foo() and store the values of foo (i), 0 < = i < n, as and when they are computed. With this modification, the time complexity for function foo() is significantly reduced. The space complexity of the modified function would be:",
        "answer": [
            "O(1)",
            "O(n)",
            "O(n!)",
            "O(nn)"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> <a href=\"http://www.geeksforgeeks.org/g-fact-86/\" target=\"_blank\">Space complexity</a> now is also O(n).\r\n\r\nWe would need an array of size O(n). The space required for recursive calls would be O(1) as the values would be taken from stored array rather than making function calls again and again.</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Two matrices M1 and M2 are to be stored in arrays A and B respectively. Each array can be stored either in row-major or column-major order in contiguous memory locations. The time complexity of an algorithm to compute M1 × M2 will be ",
        "answer": [
            "best if A is in row-major, and B is in column- major order",
            "best if both are in row-major order",
            "best if both are in column-major order",
            "independent of the storage scheme"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> This is a trick question.  Note that the questions asks about time complexity, not time taken by the program. for time complexity, it doesn't matter how we store array elements, we always need to access same number of elements of M1 and M2 to multiply the matrices. It is always constant or O(1) time to do element access in arrays, the constants may differ for different schemes, but not the time complexity.</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Let A[1, ..., n] be an array storing a bit (1 or 0) at each location, and f(m) is a function whose time complexity is θ(m). Consider the following program fragment written in a C like language:\r\n\r\ncounter = 0;\r\nfor (i = 1; i < = n; i++)\r\n{ \r\n      if (A[i] == 1) \r\n         counter++;\r\n      else {\r\n         f(counter); \r\n         counter = 0;\r\n      }\r\n}\r\nThe complexity of this program fragment is",
        "answer": [
            "Ω(n2)",
            "Ω(nlog n) and O(n2)",
            "θ(n)",
            "O(n)"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Please note that inside the else condition, f() is called first, then counter is set to 0.  \r\n\r\nConsider the following cases: <pre>\r\na) All 1s in A[]: Time taken is Θ(n) as\r\n                  only counter++ is executed n times.\r\n\r\nb) All 0s in A[]: Time taken is Θ(n) as\r\n                  only f(0) is called n times\r\n\r\nc) Half 1s, then half 0s: Time taken is  Θ(n) as\r\n                  only f(n/2) is called once.</pre>\n</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "The recurrence equation \r\nT(1) = 1\r\nT(n) = 2T(n - 1) + n, n ≥ 2 \r\nevaluates to\r\n\r\n\r\na. 2n + 1- n - 2\r\nb. 2n - n\r\nc. 2n + 1 - 2n - 2\r\nd. 2n + n",
        "answer": [
            "a",
            "b",
            "c",
            "d"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> If draw recursion tree, we can notice that total work done is,\r\nT(n) = n + 2(n-1) + 4(n-2) + 8(n-3) + 2<sup>n-1</sup> * (n - n + 1)\r\nT(n) = n + 2(n-1) + 4(n-2) + 8(n-3) + 2<sup>n-1</sup> * 1\r\n\r\nTo solve this series, let us use our school trick, we multiply T(n) with 2 and subtract after shifting terms. <pre>\r\n2*T(n) =     2n + 4(n-1) + 8(n-2) + 16(n-3) + 2<sup>n</sup> \r\n  T(n) = n + 2(n-1) + 4(n-2) + 8(n-3) + 2<sup>n-1</sup> * 1</pre>\r\n\r\nWe get <pre>\r\n2T(n) - T(n) =  -n + 2 + 4 + 8 + ..... 2<sup>n</sup>\r\nT(n) = -n + 2<sup>n+1</sup> - 2 [Applying GP sum formula for 2, 4, ...]\r\n     = 2<sup>n+1</sup> - 2 - n</pre>\n<pre>\r\n<strong>Alternate Way</strong> to solve is to use hit and try method.\r\nGiven T(n) = 2T(n-1) + n and T(1) = 1\r\n\r\nFor n = 2, T(2) = 2T(2-1) + 2 \r\n                = 2T(1) + 2 \r\n                = 2.1 + 2 = 4\r\n\r\nNow when you will put n = 2 in all options, \r\nonly 1st option 2^(n+1) - n - 2 satisfies it. </pre></div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Consider the following three claims \r\n1. (n + k)m = Θ(nm), where k and m are constants\r\n2. 2n + 1 = O(2n)\r\n3. 22n + 1 = O(2n) \r\nWhich of these claims are correct ?\t\t \r\n",
        "answer": [
            "1 and 2",
            "1 and 3",
            "2 and 3",
            "1, 2, and 3"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\">  (n + k)<sup>m</sup> and Θ(n<sup>m</sup>) are asymptotically same as theta notation can always be written by taking the leading order term in a polynomial expression. \r\n\r\n2<sup>n + 1</sup> and O(2<sup>n</sup>) are also asymptotically same as 2<sup>n + 1</sup> can be written as 2 * 2<sup>n</sup> and constant multiplication/addition doesn't matter in theta notation. \r\n\r\n2<sup>2n + 1</sup> and O(2<sup>n</sup>) are not same as constant is in power. \r\n\r\nSee <a href=\"http://www.geeksforgeeks.org/analysis-of-algorithms-set-3asymptotic-notations/\" target=\"_blank\">Asymptotic Notations</a> for more details. \r\n\r\n\r\n</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "In a permutation a1.....an of n distinct integers, an inversion is a pair (ai, aj) such that i < j and ai > aj. What would be the worst case time complexity of the Insertion Sort algorithm, if the inputs are restricted to permutations of 1.....n with at most n inversions?",
        "answer": [
            "Θ (n2)",
            "Θ (n log n)",
            "Θ (n1.5)",
            "Θ (n)"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> Insertion sort runs in Θ(n + f(n)) time, where f(n) denotes the number of inversion initially present in the array being sorted.\r\n\r\nSource: <a href=\"http://cs.xidian.edu.cn/jpkc/Algorithm/down/Solution%20to%202-4%20Inversions.pdf\" target=\"_blank\">http://cs.xidian.edu.cn/jpkc/Algorithm/down/Solution%20to%202-4%20Inversions.pdf</a></div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Randomized quicksort is an extension of quicksort where the pivot is chosen randomly. What is the worst case complexity of sorting n numbers using randomized quicksort?",
        "answer": [
            " O(n)",
            " O(n Log n)",
            " O(n2)",
            "O(n!)"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> If all elements of the given array are same then that is the worst case for the randomised quicksort. And time complexity of worst case of quicksort is O(n²) that is proven already.\r\n\r\nSo, option (C) is correct.</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "The increasing order of following functions in terms of asymptotic complexity is:\r\n\r\n\n",
        "answer": [
            "f1(n); f4(n); f2(n); f3(n)",
            "f1(n); f2(n); f3(n); f4(n); ",
            "f2(n); f1(n); f4(n); f3(n)",
            "f1(n); f2(n); f4(n); f3(n)"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> Source: <a href=\"http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/assignments/MIT6_006F11_ps1.pdf\">http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/assignments/MIT6_006F11_ps1.pdf</a></div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Which one of the following is the recurrence equation for the worst case time complexity of the Quicksort algorithm for sorting n(≥ 2) numbers? In the recurrence equations given in the options below, c is a constant.\r\n",
        "answer": [
            "T(n) = 2T (n/2) + cn ",
            "T(n) = T(n – 1) + T(0) + cn",
            "T(n) = 2T (n – 2) + cn ",
            "T(n) = T(n/2) + cn"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> In worst case, the chosen pivot is always placed at a corner position and recursive call is made for following.\r\n\r\na) for subarray on left of pivot which is of size n-1 in worst case.\r\nb) for subarray on right of pivot which is of size 0 in worst case.</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "\nConsider the following C function. \n\nC\n\n\nint fun1 (int n)\n{\n   int i, j, k, p, q = 0;\n   for (i = 1; i < n; ++i)\n   {\n      p = 0;\n      for (j = n; j > 1; j = j/2)\n         ++p;\n      for (k = 1; k < p; k = k*2)\n         ++q;\n   }\n   return q;\n}\n\nWhich one of the following most closely approximates the return value of the function fun1? \n",
        "answer": [
            "\nn3 \n",
            "\nn (logn)2 \n",
            "\nnlogn  \n",
            "\nnlog(logn) \n"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>int fun1 (int n)\n{\n   int i, j, k, p, q = 0;\n\n   // This loop runs Θ(n) time\n   for (i = 1; i &lt; n; ++i)\n   {\n      p = 0;\n\n      // This loop runs Θ(Log n) times. Refer <a href='\"http://www.geeksforgeeks.org/analysis-of-algorithms-set-4-analysis-of-loops/\"'>this</a> \n      for (j=n; j &gt; 1; j=j/2)\n         ++p;\n     \n      // Since above loop runs Θ(Log n) times, p = Θ(Log n)\n      // This loop runs Θ(Log p) times which loglogn\n      for (k=1; k &lt; p; k=k*2)\n         ++q;\n   \n   }\n   return q;\n}</pre>\n<p>T(n) = n(logn + loglogn) <br/>T(n) = n(logn) dominant <br/><br/>But please note here we are return q which lies in loglogn so ans should be T(n) = nloglogn <br/><br/>Refer <a href='\"http://www.geeksforgeeks.org/analysis-of-algorithms-set-4-analysis-of-loops/\"'>this</a> for details.<br/> </p>\n</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "An unordered list contains n distinct elements. The number of comparisons to find an element in this list that is neither maximum nor minimum is",
        "answer": [
            "Θ(nlogn) ",
            "Θ(n)",
            "Θ(logn)",
            " Θ(1)"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> We only need to consider any 3 elements and compare them.  So the number of comparisons is constants, that makes time complexity as  Θ(1)\r\n\r\n\r\n\r\nThe catch here is, we need to return any element that is neither maximum not minimum.\r\n\r\nLet us take an array {10, 20, 15, 7, 90}. Output can be 10 or 15 or 20\r\n\r\nPick any three elements from given liar. Let the three elements be 10, 20 and 7.\r\n\r\nUsing 3 comparisons, we can find that the middle element is 10.\r\n</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "\r\nThe equality above remains correct if X is replace by",
        "answer": [
            "Only I ",
            "Only II",
            "I or III or IV but not II",
            "II or III or IV but not I"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> X = Sum of the cubes of {1, 2, 3, .. n|  \r\nX = n<sup>2</sup> (n+1)<sup>2</sup> / 4\r\n \r\n\r\n</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "In the following table, the left column contains the names of standard graph algorithms and the right column contains the time complexities of the algorithms. Match each algorithm with its time complexity.\r\n\n\n\n 1. Bellman-Ford algorithm\r\n2. Kruskal’s algorithm\r\n3. Floyd-Warshall algorithm\r\n4. Topological sorting\n A : O ( m log n)\r\nB : O (n3)\r\nC : O (nm)\r\nD : O (n + m)\n\n\n\r\n ",
        "answer": [
            "1→ C, 2 → A, 3 → B, 4 → D",
            "1→ B, 2 → D, 3 → C, 4 → A",
            "1→ C, 2 → D, 3 → A, 4 → B",
            "1→ B, 2 → A, 3 → C, 4 → D"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> <ul>\n<li><strong><a href=\"http://www.geeksforgeeks.org/dynamic-programming-set-23-bellman-ford-algorithm/\">Bellman-Ford algorithm</a>: Time complexity: O(VE)</strong></li>\n<li><strong><a href=\"http://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/\">Kruskal’s algorithm</a></strong>:<strong>Time Complexity:</strong> O(ElogE) or O(ElogV). Sorting of edges takes O(ELogE) time. After sorting, we iterate through all edges and apply find-union algorithm. The find and union operations can take atmost O(LogV) time. So overall complexity is O(ELogE + ELogV) time. The value of E can be atmost V^2, so O(LogV) are O(LogE) same. Therefore, overall time complexity is O(ElogE) or O(ElogV)</li>\n<li> <strong><a href=\"http://www.geeksforgeeks.org/dynamic-programming-set-16-floyd-warshall-algorithm/\">Floyd-Warshall algorithm</a></strong>: <strong>Time Complexity</strong>: O(V^3)</li>\n<li> <a href=\"http://www.geeksforgeeks.org/topological-sorting/\"><strong>Topological sorting</strong>:</a> <strong>Time Complexity: </strong>The above algorithm is simply DFS with an extra stack. So time complexity is same as DFS which is O(V+E).</li>\n</ul></div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Let T(n) be a function defined by the recurrence\r\n\r\nT(n) = 2T(n/2) + √n for n ≥ 2 and\r\nT(1) = 1\r\n\r\nWhich of the following statements is TRUE?\r\n\r\n ",
        "answer": [
            "T(n) = θ(log n)",
            "T(n) = θ(√n)",
            "T(n) = θ(n)",
            "T(n) = θ(n log n)"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> n<sup>(log<sub>b</sub>a)</sup> = n which is = n^(1-.5) = O(sqrt n)\r\nthen by applying case 1 of master method we get T(n) = Θ(n)\r\n\r\nPlease  refer <a href=\"http://www.geeksforgeeks.org/analysis-algorithm-set-4-master-method-solving-recurrences/\">http://www.geeksforgeeks.org/analysis-algorithm-set-4-master-method-solving-recurrences/</a> for more details.</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "The worst case running times of Insertion sort, Merge sort and Quick sort, respectively, are:\r\n\r\n",
        "answer": [
            " Θ(n log n),  Θ(n log n) and  Θ(n2)\r\n ",
            "Θ(n2),   Θ(n2) and  Θ(n Log n)\r\n",
            " Θ(n2),  Θ(n log n) and Θ(n log n) \r\n ",
            "Θ(n2),  Θ(n log n) and  Θ(n2)"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> <ul>\n<li><a href=\"http://geeksquiz.com/insertion-sort/\" target=\"_blank\">Insertion Sort</a> takes Θ(n<sup>2</sup>) in worst case as we need to run two loops. The outer loop is needed to one by one pick an element to be inserted at right position. Inner loop is used for two things, to find position of the element to be inserted and moving all sorted greater elements one position ahead. Therefore the worst case recursive formula is T(n) = T(n-1) + Θ(n).</li>\n<li><a href=\"http://geeksquiz.com/merge-sort/\" target=\"_blank\">Merge Sort</a> takes Θ(n Log n)  time in all cases. We always divide array in two halves, sort the two halves and merge them. The recursive formula is T(n) = 2T(n/2) + Θ(n).</li>\n<li><a href=\"http://geeksquiz.com/quick-sort/\" target=\"_blank\">QuickSort</a> takes Θ(n<sup>2</sup>) in worst case. In QuickSort, we take an element as pivot and partition the array around it. In worst case, the picked element is always a corner element and recursive formula becomes T(n) = T(n-1) + Θ(n).  An example scenario when worst case happens is, arrays is sorted and our code always picks a corner element as pivot.</li>\n</ul>\r\n \r\n\r\n </div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Assume that the algorithms considered here sort the input sequences in ascending order. If the input is already in ascending order, which of the following are TRUE ? \r\nI.   Quicksort runs in Θ(n2) time\r\nII.  Bubblesort runs in Θ(n2) time\r\nIII. Mergesort runs in  Θ(n) time\r\nIV.  Insertion sort runs in  Θ(n) time \n",
        "answer": [
            "  I and II only",
            "  I and III only",
            "  II and IV only",
            " I and IV only"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> <strong>I.</strong>  Given an array in ascending order, Recurrence relation for total number of comparisons for quicksort will be\r\nT(n) = T(n-1)+O(n)    //partition algo will take O(n) comparisons in any case.\r\n     = O(n^2)\r\n\r\n<strong>II.</strong>  Bubble Sort runs in Θ(n^2) time\r\n\r\nIf an array is in ascending order, we could make a small modification in Bubble Sort Inner for loop which is responsible for bubbling the kth largest element to the end in kth iteration. Whenever there is no swap after the completion of inner for loop of bubble sort in any iteration, we can declare that array is sorted in case of Bubble Sort taking O(n) time in Best Case.\r\n\r\n<strong>III.</strong> Merge Sort runs in  Θ(n) time\r\nMerge Sort relies on Divide and Conquer paradigm to sort an array and there is no such worst or best case input for merge sort. For any sequence, Time complexity will be given by following recurrence relation,\r\n\r\nT(n) = 2T(n/2) + Θ(n)        // In-Place Merge algorithm will take Θ(n) due to copying an entire array.\r\n= Θ(nlogn)\r\n\r\n<strong>IV.</strong>  Insertion sort runs in  Θ(n) time\r\n\r\nWhenever a new element which will be greater than all the elements of the intermediate sorted sub-array ( because given array is sorted) is added, there won't be any swap but a single comparison. In n-1 passes we will be having 0 swaps and n-1 comparisons.\r\nTotal time complexity = O(n)             // N-1 Comparisons\r\n\r\n\r\n\r\nThis solution is contributed by <strong>Pranjul Ahuja</strong>\n<br/>\r\n////\r\nFor an array already sorted in ascending order,\r\nQuicksort has a complexity Θ(n<sup>2</sup>) [Worst Case]\r\nBubblesort has a complexity Θ(n) [Best Case]\r\nMergesort has a complexity Θ(n  log n) [Any Case]\r\nInsertsort has a complexity Θ(n) [Best Case]\r\n</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "A problem in NP is NP-complete if\r\n\r\n ",
        "answer": [
            "It can be reduced to the 3-SAT problem in polynomial time",
            "The 3-SAT problem can be reduced to it in polynomial time",
            "It can be reduced to any other problem in NP in polynomial time",
            "some problem in NP can be reduced to it in polynomial time"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> A problem in NP becomes NPC if all NP problems can be reduced to it in polynomial time. This is same as reducing any of the NPC problem to it. 3-SAT being an NPC problem, reducing it to a NP problem would mean that NP problem is NPC.\r\n\r\n \r\n\r\nPlease refer: http://www.geeksforgeeks.org/np-completeness-set-1/</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "The characters a to h have the set of frequencies based on the first 8 Fibonacci numbers as follows\r\n\r\na : 1, b : 1, c : 2, d : 3, e : 5, f : 8, g : 13, h : 21/\r\nA Huffman code is used to represent the characters. What is the sequence of characters corresponding to the following code?\r\n110111100111010",
        "answer": [
            "fdheg",
            "ecgdf",
            "dchfg",
            "fehdg"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\">  \r\n\r\n<span style=\"color: #000000;\"><span style=\"font-family: Arial;\"><span style=\"font-size: small;\">Background Required -  Generating Prefix codes using Huffman Coding.</span></span></span>\n<span style=\"color: #000000;\"><span style=\"font-family: Arial;\"><span style=\"font-size: small;\">First we apply greedy algorithm on the frequencies of the characters to generate the binary tree as shown in the Figure given below. Assigning 0 to the left edge and 1 to the right edge, prefix codes for the characters are as\r\nbelow.</span></span></span>\n<span style=\"color: #000000;\"><span style=\"font-family: Arial;\"><span style=\"font-size: small;\"><a href=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/12/pranjal_3.png\"><img alt=\"pranjal_3\" class=\"alignnone size-full wp-image-28873\" height=\"468\" src=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/12/pranjal_3.png\" width=\"373\"/></a></span></span></span>\r\n\r\na - 1111110\r\nb - 1111111\r\nc - 111110\r\nd - 11110\r\ne - 1110\r\nf - 110\r\ng - 10\r\nh - 0\r\n\r\nGiven String can be decomposed as\r\n\r\n110 11110 0 1110 10\r\n\r\nf        d     h    e     g\r\n\r\nThis solution is contributed by <span class=\"im\"><b class=\"gmail_sendername\">Pranjul Ahuja</b> </span>.</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "What is the size of the smallest MIS(Maximal Independent Set) of a chain of nine nodes?",
        "answer": [
            "5",
            "4",
            "3",
            "2"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> A set of vertices is called independent set such that no two vertices in the set are adjacent.  A <a href=\"https://en.wikipedia.org/wiki/Maximal_independent_set\">maximal independent set (MIS) </a>is an independent set which is not subset of any other independent set.\r\n\r\nThe question is about smallest MIS.  We can see in below diagram, the three highlighted vertices (2nd, 5th and 8th) form a maximal independent set (not subset of any other MIS) and smallest MIS.\r\n\r\n<pre>\r\n0----<strong>0</strong>----0----0----<strong>0</strong>----0----0----<strong>0</strong>----0\r\n</pre></div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Arrange the following functions in increasing asymptotic order:\r\nA.   n1/3\r\nB.   en \r\nC.   n7/4                                                                              \r\nD.   n log9n\r\nE.   1.0000001n",
        "answer": [
            "A, D, C, E, B",
            "D, A, C, E, B",
            "A, C, D, E, B",
            "A, C, D, B, E"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> B and E belong to <b>exponential functions.</b> So {B,E} <img alt=\"&gt;\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"17\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-99a7a8a3b27b867f014a717bb43a1cb1_l3.png\" style=\"vertical-align: -1px;\" title=\"Rendered by QuickLaTeX.com\" width=\"17\"/> {A, C, D}.\r\nB<img alt=\"&gt;\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"17\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-99a7a8a3b27b867f014a717bb43a1cb1_l3.png\" style=\"vertical-align: -1px;\" title=\"Rendered by QuickLaTeX.com\" width=\"17\"/> E.\r\nA <img alt=\"&lt;\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"17\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-46284737a9c5dc728239ee67d3962855_l3.png\" style=\"vertical-align: -1px;\" title=\"Rendered by QuickLaTeX.com\" width=\"17\"/> {C, D}.\r\nD <img alt=\"&lt;\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"17\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-46284737a9c5dc728239ee67d3962855_l3.png\" style=\"vertical-align: -1px;\" title=\"Rendered by QuickLaTeX.com\" width=\"17\"/> C\r\nHence the correct sequence is A<img alt=\"&lt;\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"17\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-46284737a9c5dc728239ee67d3962855_l3.png\" style=\"vertical-align: -1px;\" title=\"Rendered by QuickLaTeX.com\" width=\"17\"/>D<img alt=\"&lt;\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"17\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-46284737a9c5dc728239ee67d3962855_l3.png\" style=\"vertical-align: -1px;\" title=\"Rendered by QuickLaTeX.com\" width=\"17\"/>C<img alt=\"&lt;\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"17\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-46284737a9c5dc728239ee67d3962855_l3.png\" style=\"vertical-align: -1px;\" title=\"Rendered by QuickLaTeX.com\" width=\"17\"/>E<img alt=\"&lt;\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"17\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-46284737a9c5dc728239ee67d3962855_l3.png\" style=\"vertical-align: -1px;\" title=\"Rendered by QuickLaTeX.com\" width=\"17\"/>B.</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Which of the following is TRUE?\r\n\r\n ",
        "answer": [
            "The cost of searching an AVL tree is θ (log n) but that of a binary search tree is O(n)",
            "The cost of searching an AVL tree is θ (log n) but that of a complete binary tree is θ (n log n)",
            "The cost of searching a binary search tree is O (log n ) but that of an AVL tree is θ(n)",
            "The cost of searching an AVL tree is θ (n log n) but that of a binary search tree is O(n)"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> AVL tree is a balanced tree.<br/>\r\nAVL tree's time complexity of searching = θ(logn)\r\n<br/>But a binary search tree, may be skewed tree, so in worst case BST searching time = θ(n)</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "The two numbers given below are multiplied using the Booth's algorithm.\r\n\r\nMultiplicand : 0101 1010 1110 1110\r\nMultiplier: 0111 0111 1011 1101\r\n\r\nHow many additions/Subtractions are required for the multiplication of the above two numbers?",
        "answer": [
            "6",
            "8",
            "10",
            "12"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Booth’s algorithm: first take 2’s complement of given number if number is negative, then append 0 into LSB.\r\n\r\n<pre>Then, for each pair from LSB to MSB (add 1 bit at a time):\r\n00 = 0, 01 = +1, 10 = -1, 11 = 0</pre>\r\n\r\nBooth's algorithm is based on <b>Multiplier</b> which is <i>already</i> given in binary representation: 0111 0111 1011 1101\r\n\r\n<pre>= Now, append 0 into LSB of (0111 0111 1011 1101) = 0111 0111 1011 1101 0\r\nNow Booth's code (add 1 bit at a time, from LSB to MSB):\r\n= 01, 11, 11, 10, 01, 11, 11, 11, 10, 01, 11, 11, 11, 10, 01, 10\r\n= +1 0 0 -1 +1 0 0 0 -1 +1 0 0 0 -1 +1 -1</pre>\r\n\r\nTherefore, 4 subtractions and 4 additions, total 8 additions/Subtractions are required.\r\n\r\nSo, option (B) is correct.</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "If we use Radix Sort to sort n integers in the range (nk/2,nk], for some k>0 which is independent of n, the time taken would be?",
        "answer": [
            "Θ(n)",
            "Θ(kn)",
            "Θ(nlogn)",
            "Θ(n2)"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Radix sort time complexity = O(wn)<br/>\r\nfor n keys of word size= w\r\n<br/>=&gt;w = log(n<sup>k</sup>)\r\n<br/>O(wn)=O(klogn.n)\r\n<br/> =&gt; kO(nlogn)</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "The auxiliary space of insertion sort is O(1), what does O(1) mean ?",
        "answer": [
            "The memory (space) required to process the data is not constant.",
            "It means the amount of extra memory Insertion Sort consumes doesn't depend on the input. The algorithm should use the same amount of memory for all inputs.",
            "It takes only 1 kb of memory .",
            "It is the speed at which the elements are traversed."
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> The term O(1) states that the space required by the insertion sort is constant i.e., space required doesn't depend on input.</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "A sorting technique is called stable if:",
        "answer": [
            "It takes O(nlog n)time",
            "It maintains the relative order of occurrence of non-distinct elements ",
            "It uses divide and conquer paradigm",
            "It takes O(n) space"
        ],
        "correct": "B",
        "explain": "None",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Suppose we want to arrange the ii numbers stored in an array such that all negative values occur before all positive ones. Minimum number of exchanges required in the worst case is:",
        "answer": [
            "n-1",
            "n",
            "n+1",
            "None of the above"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> When we have 'i' numbers stored in an array, we have to swap all positive numbers with negative and in worst case positive numbers will be i/2. </div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "If one uses straight two-way merge sort algorithm to sort the following elements in ascending order 20, 47, 15, 8, 9, 4, 40, 30, 12, 17\r\nthen the order of these elements after the second pass of the algorithm is:",
        "answer": [
            "8, 9, 15, 20, 47, 4, 12, 17, 30, 40",
            "8, 15, 20, 47, 4, 9, 30, 40, 12, 17",
            "15, 20, 47, 4, 8, 9, 12, 30, 40, 17",
            "4, 8, 9, 15, 20, 47, 12, 17, 30, 40"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> In first pass the elements are sorted in n/4 (first 2 elements in each group) sub arrays but in second pass the elements are sorted in n/2 (first 4 elements in each group) sub arrays.</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "The minimum number of record movements required to merge five files A (with 10 records), B (with 20 records), C (with 15 records), D (with 5 records) and E (with 25 records) is:",
        "answer": [
            "165",
            "90",
            "75",
            "65"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Using optimal merge pattern algorithm arrange files in increasing order of records:\r\n\r\n<pre>D  A   C   B   E\r\n\r\n5  10  15  20  25 </pre>\n<img alt=\"\" class=\"aligncenter size-full wp-image-224242\" height=\"341\" src=\"https://www.geeksforgeeks.org/wp-content/uploads/3333-2.png\" width=\"337\"/>\r\n\r\nNow, minimum number of record movements required = sum of internal node's value = 15 + 30 + 45 + 75 = 165\r\n\r\nSo, option (A) is correct.\r\n</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Consider the following C function definition.\r\n\r\n\r\n\r\nint Trial (int a, int b, int c)\r\n{\r\n    if ((a >= b) && (c < b) return b;\r\n    else if (a>=b) return Trial(a, c, b);\r\n    else return Trial(b, a, c);\r\n}\r\n\r\n\r\nThe function Trial:",
        "answer": [
            "finds the maximum of a, b and c",
            "finds the minimum of a, b and c",
            "finds the middle number of a, b and c",
            "None of the above"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> Trial (a,b,c) return the median element of the a, b and c,but not middle element of a , b and c. But if a = b = c, then infinite loop.\r\nSo, Option (D) is correct.</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Which of the following algorithm design technique is used in finding all pairs of shortest distances in a graph?",
        "answer": [
            "Dynamic programming",
            "Backtracking",
            "Greedy",
            "Divide and Conquer"
        ],
        "correct": "A",
        "explain": "None",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Give the correct matching for the following pairs:\r\nA. O(log n)     1. Selection sort\r\nB. O(n)         2. Insertion sort\r\nC. O(nlog n)    3. Binary search\r\nD. O(n^2)       4. Merge sort\r\n\r\ncodes: \r\n     A   B   C   D\r\na.   3   1   2   4\r\nb.   3   1   4   2\r\nc.   1   3   4   2\r\nd.   1   4   3   2\r\n",
        "answer": [
            "a",
            "b",
            "c",
            "d"
        ],
        "correct": "B",
        "explain": "None",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "What value would the following function return for the input x=95 ?\r\nfunction fun (x:integer):integer;\r\nBegin\r\n  If x >100 then fun = x-10\r\n  Else fun = fun(fun( x+11))\r\nEnd;\r\n",
        "answer": [
            "89",
            "90",
            "91",
            "92"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> for solution refer<a href=\"https://www.geeksforgeeks.org/isro-isro-cs-2017-question-73/\" rel=\"noopener\" target=\"_blank\"> ISRO CS 2017</a>\r\nSo option C is correct</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Solve the following recurrence relation:\r\nxn = 2xn-1 -1, n>1\r\nx1 = 2",
        "answer": "None",
        "correct": "None",
        "explain": "None",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "The correct matching for the following pairs is\r\n(A) All pairs shortest path          (1) Greedy\r\n(B) Quick Sort                       (2) Depth-First search\r\n(C) Minimum weight spanning tree     (3) Dynamic Programming\r\n(D) Connected Components             (4) Divide and and Conquer\r\n\nCodes:\r\n     A    B    C    D \r\na    2    4    1    3\r\nb    3    4    1    2\r\nc    3    4    2    1\r\nd    4    1    2    3\r\n",
        "answer": [
            "a",
            "b",
            "c",
            "d"
        ],
        "correct": "B",
        "explain": "None",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "[5-Marks question]\r\n\r\nConsider a graph whose vertices are points in the plane with integer co-ordinates (x,y) such that 1≤x≤n and 1≤y≤n, where n≥2 is an integer. Two vertices (x1,y1) and (x2,y2) are adjacent iff ∣ x1−x2 ∣ ≤ 1 and ∣ y1–y2 ∣ ≤1. The weight of an edge {(x1,y1),(x2,y2)} is √(x1–x2)2+(y1–y2)2 \r\na.  What is the weight of a minimum weight-spanning tree in this graph? Write only the answer without any explanations.\r\nb.  What is the weight of a maximum weight-spanning tree in this graph? Write only the answer without any explanations.",
        "answer": "None",
        "correct": "None",
        "explain": "None",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Which of the following is false?\r\n\r\n\r\n\r\n \r\n\r\n \r\n\r\n \r\n\r\n \r\n\r\n \r\n\r\n \r\n\r\n ",
        "answer": [
            "a",
            "b",
            "c",
            "d"
        ],
        "correct": "B",
        "explain": "None",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Quicksort is run on two inputs shown below to sort in ascending order taking first element as pivot,\r\n(i) 1, 2, 3,......., n\r\n(ii) n, n-1, n-2,......, 2, 1 \r\nLet C1 and C2 be the number of comparisons made for the inputs (i) and (ii) respectively. Then,",
        "answer": [
            "C1 < C2 ",
            "C1 > C2",
            "C1 = C2",
            "We cannot say anything for arbitrary n"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> <a href=\"https://www.geeksforgeeks.org/quick-sort/\" rel=\"noopener\" target=\"_blank\">Quick Sort</a> performs in worst case when input is sorted in either ascending order or descending order. So, quick sort will return equal number of comparisons for both given inputs.\r\n\r\nOption (C) is correct.</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "A two dimensional array A[1...n][1...n] of integers is partially sorted if\r\n∀i, j ∈ [1...n−1], A[i][j] < A[i][j+1] and A[i][j] < A[i+1][j]\r\nFill in the blanks:\r\n\r\na) The smallest item in the array is at A[i][j] where i=..................and j=......................\r\nb) The smallest item is deleted. Complete the following O(n) procedure to insert item x (which is guaranteed to be smaller than any item in the last row or column) still keeping A partially sorted.\r\nprocedure insert (x: integer);\r\nvar i,j: integer;\r\nbegin\r\n    i:=1; j:=1, A[i][j]:=x;\r\n    while (x > ...... or x > ......) do\r\n        if A[i+1][j] < A[i][j] ......... then begin\r\n            A[i][j]:=A[i+1][j]; i:=i+1;\r\n        end\r\n        else begin\r\n            ............\r\n        end\r\n    A[i][j]:= .............\r\nend\r\n.\r\n",
        "answer": "None",
        "correct": "None",
        "explain": "None",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "A complete, undirected, weighted graph G is given on the vertex {0, 1,...., n−1} for any fixed ‘n’. Draw the minimum spanning tree of G if\r\n\r\na) the weight of the edge (u,v) is ∣ u−v ∣\r\nb) the weight of the edge (u,v) is u + v",
        "answer": "None",
        "correct": "None",
        "explain": "None",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Consider the following program that attempts to locate an element x in a sorted array a[ ] using binary search. Assume N>1. The program is erroneous. Under what conditions does the program fail?\r\nvar i,j,k: integer;  x: integer;\r\n    a: array; [1....N] of integer;\r\nbegin\ti:= 1; j:= N;\r\nrepeat\t\r\n    k:(i+j) div 2;\r\n    if a[k] < x then i:= k \r\n    else j:= k \r\nuntil (a[k] = x) or (i >= j);\r\n    \r\nif (a[k] = x) then\r\n    writeln ('x is in the array')\r\nelse\r\n    writeln ('x is not in the array')\r\nend;\r\n",
        "answer": [
            "x is the last element of the array a[]",
            "x is greater than all elements of the array a[]",
            "Both of the Above",
            "x is less than the last element of the array a[]"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> The above program doesn’t work for the cases where element to be searched is the last element of a[] or greater than the last element (or maximum element) in a[]. For such cases, program goes in an infinite loop because i is assigned value as k in all iterations, and i never becomes equal to or greater than j. So while condition never becomes false. </div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "What is the time complexity of following function fun()? Assume that log(x) returns log value in base 2.\r\nvoid fun()\r\n{\r\n   int i, j;\r\n   for (i=1; i<=n; i++)\r\n      for (j=1; j<=log(i); j++)\r\n         printf(\"GeeksforGeeks\");\r\n}\n",
        "answer": [
            "Θ(n)",
            "Θ(nLogn)",
            "Θ(n^2)",
            "Θ(n^2(Logn))"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> The time complexity of above function can be written as: Θ(log 1) + Θ(log 2) + Θ(log 3) + . . . . + Θ(log n) which is Θ (log n!)\r\nOrder of growth of ‘log n!’ and ‘n log n’ is same for large values of n, i.e., Θ (log n!) = Θ(n log n). So time complexity of fun() is Θ(n log n).\r\n\r\nThe expression Θ(log n!) = Θ(n log n) can be easily derived from following <a href=\"https://en.wikipedia.org/wiki/Stirling%27s_approximation\" rel=\"noopener\" target=\"_blank\">Stirling’s approximation (or Stirling’s formula)</a>\n<pre>log n! = n log n - n + O(log(n))</pre>\r\n\r\nOption (B) is correct.</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Given A, an array of size n, comprised of an increasing sequence of numbers followed immediately by a decreasing one. What is worst case time complexity of optimal algorithm to determine if a given number x is in the array?",
        "answer": [
            "Θ(log n)",
            "Θ(n)",
            "Θ(n^2)",
            "Θ(log n)^2"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> This is an application of Binary search, which has time complexity Θ(log n) in worst case.\r\nOption (A) is correct.</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Match the following:\r\n\r\n\r\n\r\nWhich of the following option is correct?\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
        "answer": [
            "A – 3, B – 2, C – 4, D – 1 ",
            "A – 3, B – 1, C – 4, D – 2 ",
            "A – 3, B – 4, C – 2, D – 1 ",
            "A – 1, B – 2, C – 4, D – 3 "
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Correct matching is A – 3, B – 2, C – 4, D – 1. Option (A) is correct.</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Consider the recurrence equation\r\nT(n) = 2T(n-1), if n>0\r\n     = 1, otherwise\r\nThen T(n) is (in big O order)",
        "answer": [
            "O(n)",
            "O(2n)",
            "O(1)",
            "O(log n)"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Using Substitution Method:\r\n<img alt=\"T(n) = 2T(n-1)\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"27\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-3bf86743a8cc22ca34ade014ec2f768b_l3.png\" style=\"vertical-align: -7px;\" title=\"Rendered by QuickLaTeX.com\" width=\"202\"/>\n<img alt=\"= 2(2T(n-2)) = 2^2T(n-2)\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"31\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-57ddb1122afec915a8005ece9b35fdf9_l3.png\" style=\"vertical-align: -7px;\" title=\"Rendered by QuickLaTeX.com\" width=\"333\"/>\n<img alt=\"= 2(2^2T(n-2)) = 2^3T(n-3)\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"31\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-9ba94c5fc2f8ee15bdd9bab093846399_l3.png\" style=\"vertical-align: -7px;\" title=\"Rendered by QuickLaTeX.com\" width=\"344\"/>\n<img alt=\"....\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"3\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-4054b1e6be3fccf9a27ca1db069a911e_l3.png\" style=\"vertical-align: 0px;\" title=\"Rendered by QuickLaTeX.com\" width=\"25\"/>\n<img alt=\"= 2(2^{n-3}T(n-(n-2))) = 2^{n-2}T(n-(n-2))\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"31\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-a3fc8ef5739863401dbd8b47b3b6ecbe_l3.png\" style=\"vertical-align: -7px;\" title=\"Rendered by QuickLaTeX.com\" width=\"538\"/>\n<img alt=\"= 2(2^{n-2}T(n-(n-1))) = 2^{n-1}T(n-(n-1)) = 2^{n-1}T(1) \" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"31\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-9b312f9ee6dcc418b638d84546515981_l3.png\" style=\"vertical-align: -7px;\" title=\"Rendered by QuickLaTeX.com\" width=\"678\"/>\n<img alt=\"= 2(2^{n-1}T(n-(n))) = 2^{n}T(n-(n)) = 2^{n}T(0) \" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"31\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-8a61058497d107c42772372df136a0c2_l3.png\" style=\"vertical-align: -7px;\" title=\"Rendered by QuickLaTeX.com\" width=\"535\"/>\n<img alt=\"T(n) = O(2^n)\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"27\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-cef080604fdf62f34861018cc3293bb4_l3.png\" style=\"vertical-align: -7px;\" title=\"Rendered by QuickLaTeX.com\" width=\"156\"/>\r\n\r\nSo, option (B) is correct.</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Consider the program\r\nvoid function(int n) {\r\nint i, j, count=0;\r\nfor (i=n/2; i <= n; i++)\r\nfor (j = 1; j <= n; j = j*2)\r\ncount++;}\r\nThe complexity of the program is",
        "answer": [
            " O(log n) ",
            "O(n2)",
            "O(n2 log n)",
            "O(n log n)"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> The outer loop runs n/2 times\r\nThe inner loop runs logn times\r\nTherefore the total time complexity of the  program is  O(nlogn) which is option (D)</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Consider the recurrence relation:\r\n\r\n\r\n\r\nWhere b and c are constants.\r\nThe order of the algorithm corrosponding to above recurrence relation is:",
        "answer": [
            "n",
            "n2",
            "n log n",
            "n3"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> We can use Master theorem to solve this recurrance relation:\r\n<pre>T(n) = aT(n/2) + Θ(n<sup>k</sup>log<sup>p</sup>n)\r\nIn given question:\r\nT(n) = 8T(n/2) + Cn\r\nhere a = 8 and b = 2 and k = 1.\r\n clearly a &gt; b<sup>k</sup> \r\nSo T(n) = Θ(n<sup>log<sub>b</sub>a </sup>)\r\nT(n) = Θ(n<sup>log<sub>2</sub> 8</sup>)\r\nie T(n) = Θ(n<sup>3</sup>)\r\n</pre>\r\nSo, option (D) is correct.</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "If b is the branching factor and m is the maximum depth of the search tree, what is the space complexity of greedy search?",
        "answer": [
            "O(b+m)",
            "O(bm)",
            "O(bm)",
            "O(mm)"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> <ol><li>In binary tree branching factor is 2 and space complexity for height n is O(2<sup>n</sup>).</li>\n<li>In ternary tree branching factor is 3 and space complexity for height n is O(3<sup>n</sup>).</li>\n<b>Similarly</b>\n<li>If branching factor is b and height is m for search tree then space complexity of greedy search is O(b<sup>m</sup>).</li></ol>\r\nSo, option (C) is correct.\r\n</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "The time complexity of computing the transitive closure of a binary relation on a set of n elements is known to be",
        "answer": [
            "O(nlogn)",
            "O(n3/2)",
            "O(n3)",
            "O(n)"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Transitive closure generally uses Floyd-Warshall Algorithm which gives a time complexity of O(n<sup>3</sup>)\r\nRefer:<a href=\"https://www.geeksforgeeks.org/transitive-closure-of-a-graph/\" rel=\"noopener\" target=\"_blank\"> Transitive closure of a graph</a></div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "A recursive function h, is defined as follows :\r\nh(m) = k, if m = 0\r\n     = 1, if m = 1\r\n     = 2 h(m – 1) + 4h(m – 2), if m ≥ 2\r\nIf the value of h(4) is 88 then the value of k is :",
        "answer": [
            "0",
            "1",
            "2",
            "-1"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> According to given question:\r\n<pre>\r\n     h(4) = 88\r\n       88 = 2 h(3) + 4 h(2)\r\n          = 2 [2 h(2) + 4 h(1)] + 4 h(2)\r\n          = 8 h(2) + 8 h(1)\r\n          = 8 (2 + 4 k) + 8\r\n          = 24 + 32 k\r\n i.e.   k = 2</pre>\r\nSo, option (C) is correct.\r\n  </div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "The asymptotic upper bound solution of the recurrence relation given by\r\n",
        "answer": [
            " O(n2)",
            "O(n lg n)",
            "O(n lg lg n)",
            "O(lg lg n)"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> \r\nWe will apply master theorem in this question:\r\na = 2, b = 2 and k =1 and p = -1. \r\nwe will comapare a and  b<sup>k</sup>\r\nie <pre>2 = 2<sup>1</sup> and we have p = -1\r\nThen T(n) = Θ(n<sup>log<sub>2</sub>2</sup>log log n)\r\n     T(n) = Θ(nlog log n)   \r\nand Θ(n log log n) &gt;= O(n log log n)</pre>\r\nSo, option (C) is correct.</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Any decision tree that sorts n elements has height ________.",
        "answer": [
            "Ω(lg n)",
            "Ω(n)",
            "Ω(n lg n)",
            "Ω(n2)"
        ],
        "correct": "C",
        "explain": "None",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Dijkstra’s algorithm is based on",
        "answer": [
            "Divide and conquer paradigm",
            "Dynamic programming",
            "Greedy Approach",
            "Backtracking paradigm"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> \r\nDijkstra’s algorithm is based on Greedy Approach.\r\nFor more information Refer:<a href=\"https://www.geeksforgeeks.org/greedy-algorithms-set-6-dijkstras-shortest-path-algorithm/\" rel=\"noopener\" target=\"_blank\">Greedy Algorithms | Set 7 (Dijkstra’s shortest path algorithm)</a>\r\nOption (C) is correct.</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Match the following with respect to algorithm paradigms :\r\n",
        "answer": [
            "(1)",
            "(2)",
            "(3)",
            "(4)"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> <ol><li>Merge sort is a Divide and conquer algorithm</li><li>Huffman coding is a Greedy approach</li><li>Optimal polygon triangulation is Dynamic programming algorithm</li><li>Subset sum problem is a Back tracking algorithm</li>\r\nSo, option (D) is correct.\r\n\r\n\r\n</ol></div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "What is the best method to go for the game playing problem?",
        "answer": [
            "Optimal Search",
            "Random Search",
            "Heuristic Search",
            "Stratified Search"
        ],
        "correct": "C",
        "explain": "None",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "The time complexity of the following C function is (assume n > 0)\r\nint recursive (int n) {\r\nif(n == 1)\r\nreturn (1);\r\nelse\r\nreturn (recursive (n-1) + recursive (n-1));\r\n}",
        "answer": [
            "O(n)",
            "O(n log n)",
            "O(n2)",
            "O(2n)"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> Recurrence relation for the code = T(n) = 2T(n-1) + k.\r\nWe can solve the recurrence using substitution method:\r\n<pre>T(n) = 2T(n-1) + k\r\n     = 2(2T(n-2) + k) + k\r\n     = 2(2(2T(n-3) + k) + k) + k.....\r\n     = 2<sup>x</sup>T(n-x) + 2(1 + 2 +....+ 2<sup>x-1</sup>)k\r\nWhen base condition is met, i.e. n=1, x=n-1\r\n     = 2<sup>n-1</sup> T(1) + k(2<sup>n</sup>)\r\n     = O(2<sup>n</sup>)</pre>\r\n\r\nSo, option (D) is correct.</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Consider a weighted complete graph G on the vertex set {ν1, ν2, .... νn} such that the weight of the edge (νi, νj) is 4 | i – j|. The weight of minimum cost spanning tree of G is :",
        "answer": [
            "4n2\n",
            "n",
            "4n – 4",
            "2n – 2"
        ],
        "correct": "C",
        "explain": "None",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Match the following:\r\n",
        "answer": [
            "(1)",
            "(2)",
            "(3)",
            "(4)"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> <ul><li>Prim’s algorithm takes O(E lgV) time.</li><li>Bellman-Ford algorithm  takes O(V<sup>2</sup>E) time.</li><li>Floyd-Warshall algorithm takes O(V<sup>3</sup>) time.</li><li>Johnson’s algorithm takes O(VE lgV) time.</li>\r\nSo, option (C) is correct.</ul></div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Match the following:\r\n",
        "answer": [
            "(1)",
            "(2)",
            "(3)",
            "(4)"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> <ul><li>Huffman codes takes O(nlgn) time.</li><li>Optimal polygon triangulation takes θ(n<sup>3</sup>) time</li>Activity selection problem takes θ(n) time<li></li><li>Quicksort takes O(n<sup>2</sup>) time</li></ul>\r\nSo, option (C) is correct.\r\n</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Given two sequences X and Y : \r\nX = < a, b, c, b, d, a, b >\r\nY = < b, d, c, a, b, a > .\r\nThe longest common subsequence of X and Y is :\r\n",
        "answer": [
            "< b, c, a>",
            "< c, a, b>",
            "< b, c, a, a>",
            "< b, c, b, a>"
        ],
        "correct": "D",
        "explain": "None",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Floyd-Warshall algorithm utilizes __________ to solve the all-pairs shortest paths problem on a directed graph in __________ time. ",
        "answer": [
            " Greedy algorithm, θ (V3)",
            "Greedy algorithm, θ (V2 lgn)",
            " Dynamic programming, θ (V3)",
            "Dynamic programming, θ (V2 lgn)"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Floyd-Warshall algorithm utilizes dynamic programming to solve the all-pairs shortest paths problem on a directed graph in θ (V<sup>3</sup>) time. \r\nFor more information on Floyd-Warshall algorithm Refer<a href=\"https://www.geeksforgeeks.org/dynamic-programming-set-16-floyd-warshall-algorithm/\">Dynamic Programming | Set 16 (Floyd Warshall Algorithm)</a>\r\nOption (C) is correct.</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "To determine the efficiency of an algorithm the time factor is measured by: ",
        "answer": [
            "Counting micro seconds",
            "Counting number of key operations",
            "Counting number of statements",
            "Counting kilobytes of algorithm"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> To determine the efficiency of an algorithm the time factor is measured by counting number of key operations. It is not measured by counting of statements because less no of statement does not mean that program is more efficient. Many times  we have to write large code for better efficieny. We measure space complexity in kilobytes.\r\nSo, option (B) is correct.</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Let T(n) be defined by T(1) = 10 and T(n + 1) = 2n + T(n) and for all integers n ≥ 1 . Which of the following represents the order of growth of T(n) as a function of                                                                                                                                                                                                                                                              ",
        "answer": [
            "O(n)",
            "O(n log n)",
            "O(n2)",
            "O(n3)"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>T(n + 1) = 2n + T(n) \r\nBy substitution method:\r\nT(n + 1) = 2n + (2(n-1) + T(n-1))\r\nT(n + 1) = 2n + (2(n-1) + (2(n-2) + T(n-2)))\r\nT(n + 1) = 2n + (2(n-1) + (2(n-2) + (2(n-3) + T(n-3))))\r\nT(n + 1) = 2n + 2(n-1) + 2(n-2) + 2(n-3)......2(n-(n-1) + T(1))\r\nT(n + 1) = 2n + 2n - 2 + 2n - 4 + 2n - 6 +.... + 10\r\nT(n + 1) = 2[n + n + n + ...] - 2[1 + 2 + 3 +...]\r\nT(n + 1) = 2[n*n] - 2[n(n+1)/2]\r\nT(n + 1) = 2[n*n] - [n*n + n]\r\nT(n + 1) = n*n - n\r\nT(n + 1) = O(n<sup>2</sup>)</pre>\n</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "An all-pairs shortest-paths problem is efficiently solved using:",
        "answer": [
            "Dijkstra' algorithm",
            "Bellman-Ford algorithm",
            "Kruskal algorithm",
            "Floyd-Warshall algorithm"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> An all-pairs shortest-paths problem is efficiently solved using Floyd-Warshall algorithm.\r\nFor more information on all-pairs shortest-paths problem and its solution using Floyd-Warshall algorithm Refer:<a href=\"https://www.geeksforgeeks.org/dynamic-programming-set-16-floyd-warshall-algorithm/\" rel=\"noopener\" target=\"_blank\">Dynamic Programming | Set 16 (Floyd Warshall Algorithm)</a>\r\nSo, option (D) is correct.</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "The travelling salesman problem can be solved in:",
        "answer": [
            "Polynomial time using dynamic programming algorithm",
            "Polynomial time using branch-and-bound algorithm",
            "Exponential time using dynamic programming algorithm or branch-and-bound algorithm",
            "Polynomial time using backtracking algorithm"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> The travelling salesman problem can be solved in exponential time using dynamic programming algorithm or branch-and-bound algorithm.\r\nFor more information on travelling salesman problem and its solution Refer:<a href=\"https://www.geeksforgeeks.org/travelling-salesman-problem-set-2-approximate-using-mst/\" rel=\"noopener\" target=\"_blank\">Travelling Salesman Problem</a>\r\nSo, option (C) is correct.</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Which of the following is asymptotically smaller?",
        "answer": [
            "lg(lg*n)",
            "lg*(lgn)",
            "lg(n!)",
            "lg*(n!)"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Options are in following order:\r\nlg(lg*n) &lt; lg*(lgn) &lt; lg(n!) &lt; lg*(n!).<br/>\r\nSo, option (A) is correct.\r\n</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Let f(n) and g(n) be asymptotically non-negative functions. Which of the following is correct?",
        "answer": [
            "θ ( f (n)*g(n)) = min (f (n), g(n))",
            "θ ( f (n)*g(n)) = max (f (n), g(n))",
            "θ( f (n) + g(n)) = min (f (n), g(n))",
            "θ ( f (n) + g(n)) = max (f (n), g(n))"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> <ul>\n<li><b>Case-1:</b> \r\nWhen none of the f(n) and g(n) are constant functions - In this case max(f(n) , g(n)) &lt;= f(n) * g(n) so max(f(n), g(n)) can not provide a upper bound for f(n) * g(n).\r\n\r\n</li>\n<li><b>Case-2:</b> \r\nWhen both of the f(n) &amp; g(n) are constant functions or when any one of the f(n) and g(n) is a non zero constant function, In this case f(n) * g(n) = theta(max(f(n), g(n))).\r\n\r\n</li>\n<li><b>Case-3:</b> \r\nWhen at least any one of the f(n) and g(n) is 0, In this case f(n) * g(n) != theta(max(f(n), g(n))). Since max(f(n), g(n)) COULD BE unable to give a lower bound.\r\n</li>\n</ul>\r\n\r\nOption (D) is correct.</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Which design matric is used to measure the compactness of the program in terms of lines of code?",
        "answer": [
            "Consistency",
            "Conciseness",
            "Efficiency",
            "Accuracy"
        ],
        "correct": "B",
        "explain": "None",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "\n\n\nMatch the following:\n\n\nList - I",
        "answer": "None",
        "correct": "None",
        "explain": "None",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "Dijkstra algorithm, which solves the single-source shortest--paths problem, is a _________, and the Floyd-Warshall algorithm, which finds shortest paths between all pairs of vertices, is a _________",
        "answer": [
            "Greedy algorithm, Divide-conquer algorithm",
            "Divide-conquer algorithm, Greedy algorithm",
            "Greedy algorithm, Dynamic programming algorithm",
            "Dynamic programming algorithm, Greedy algorithm"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Dijkstra algorithm, which solves the single-source shortest–paths problem, is a Greedy algorithm, and the Floyd-Warshall algorithm, which finds shortest paths between all pairs of vertices, is a Dynamic programming algorithm.\r\nFor more information on Floyd-Warshall and  Dijkstra algorithm Refer:<a href=\"https://www.geeksforgeeks.org/dynamic-programming-set-16-floyd-warshall-algorithm/\" rel=\"noopener\" target=\"_blank\">Dynamic Programming | Set 16 (Floyd Warshall Algorithm)</a> <a href=\"https://www.geeksforgeeks.org/greedy-algorithms-set-6-dijkstras-shortest-path-algorithm/\" rel=\"noopener\" target=\"_blank\">Greedy Algorithms | Set 7 (Dijkstra’s shortest path algorithm)</a>\r\nOption (C) is correct.</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": " Assume A and B are non-zero positive integers. The following code segment\r\n while ( A != B) {\r\n If ( A > B )\r\n    A - = B ;\r\n else\r\n    B - = A ;\r\n }\r\n cout << A; // printing the value of A",
        "answer": [
            "Computes the LCM of two numbers",
            "Divides the larger number by the smaller number",
            "Computes the GCD of two numbers",
            "Finds the smaller of two numbers"
        ],
        "correct": "C",
        "explain": "None",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "\nConsider the following C code segment  \nint f (int x)\n{\n      if (x < 1)  return 1;\n      else return (f(x-1) + g(x))\n}\n\nint g (int x)\n{\n      if (x < 2) return 2;\n      else return (f(x-1) + g(x/2));\n}\nOf the following, which best describes the growth of f(x) as a function of x?  \n",
        "answer": [
            "\nCubic \n",
            "\nQuadratic \n",
            "\nExponential \n",
            "\nLinear \n"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\">\n<p><span style=\"background-color:rgb(248,248,248);color:rgb(29,28,29);\">f(n) = f(n-1) + g(n) ---- 1</span><br/><span style=\"background-color:rgb(248,248,248);color:rgb(29,28,29);\">g(n) = f(n-1) + g(n/2) ---- 2</span><br/><span style=\"background-color:rgb(248,248,248);color:rgb(29,28,29);\">Putting the value of g(n) in equation 1,</span><br/><span style=\"background-color:rgb(248,248,248);color:rgb(29,28,29);\">f(n) = 2*f(n-1) + g(n) + g(n/2)</span><br/><span style=\"background-color:rgb(248,248,248);color:rgb(29,28,29);\">So, we can derive the below equation,</span><br/><span style=\"background-color:rgb(248,248,248);color:rgb(29,28,29);\">f(n) &gt; 2f(n-1)</span><br/><span style=\"background-color:rgb(248,248,248);color:rgb(29,28,29);\">=&gt; f(n) &gt; 2*2*f(n-2) ---- because f(n) &gt; 2*f(n-1), so, f(n-1) &gt; 2*f(n-2)....</span><br/><span style=\"background-color:rgb(248,248,248);color:rgb(29,28,29);\">So we can write f(n)&gt;2*2*f(n-2).</span><br/><span style=\"background-color:rgb(248,248,248);color:rgb(29,28,29);\">so on....</span><br/><span style=\"background-color:rgb(248,248,248);color:rgb(29,28,29);\">=&gt; f(n) &gt; (2^n)f(1) --- here '^' denotes the exponent.</span><br/><span style=\"background-color:rgb(248,248,248);color:rgb(29,28,29);\">So, f(n) &gt; Theta(2^n)</span><br/><span style=\"background-color:rgb(248,248,248);color:rgb(29,28,29);\">So, option B is true, exponential growth for f(x).</span></p>\n</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "The time complexity of computing the transitive closure of binary relation on a set of n elements is known to be",
        "answer": [
            "O(n)",
            "O(n log n)",
            "O(n 3/2)",
            "O(n 3)"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> Refer: <a href=\"https://www.geeksforgeeks.org/gate-gate-cs-2005-question-7/\" rel=\"noopener\" target=\"_blank\">GATE-CS-2005 | Question 7</a>\r\n\r\nOption (D) is correct.</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "\n\n\nMatch the following:\n\n\nList - I",
        "answer": "None",
        "correct": "None",
        "explain": "None",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "In a balanced binary search tree with n elements, what is the worst case time complexity of reporting all elements in range [a,b] ? Assume that the number of reported elements is k.",
        "answer": [
            "Θ(log n)",
            "Θ(log(n)+k)",
            "Θ(k log n)",
            "Θ(n log k)"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> <ol>\n<li>Time complexity to check if element 'a' in given balanced binary search tree = O(log n)\r\n</li>\n<li>Time complexity to check if element 'a' in given balanced binary search tree = O(log n)\r\n</li>\n<li>Now, time complexity to traverse all element in range [a, b], those elements will be inorder sorted = θ(k)\r\n</li>\n</ol></div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "\n External entities in DFD are shown by:-\n",
        "answer": [
            "Circle",
            "Rectangle",
            "Ellipse",
            "Hexagon"
        ],
        "correct": "B",
        "explain": "None",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "\nWhich one of the following statements is TRUE for all positive functions f (n) ?\n",
        "answer": [
            "\n[Tex]f(n^{2}) = theta (f(n^{2})) [/Tex], when f (n) is a polynomial\n",
            "\n[Tex]f(n^{2}) = o (f(n^{2}))[/Tex]\n",
            "\n[Tex]f(n^{2}) = O(f(n^{2})) [/Tex], when f (n) is an exponential function\n",
            "\n[Tex]f(n^{2}) = Ω(f(n^{2}))[/Tex]\n"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\">\n<p><strong>Option A:</strong> It always holds because if we square the input variable, then the highest order in the polynomial will also get squared.</p>\n<p><strong>Option B:</strong> It is not true in cases when f(n) is a polynomial function.</p>\n<p><strong>Option C: </strong>An exponential function may be increasing or decreasing, so this condition may not always be true.</p>\n<p><strong>Option D: </strong>It need not be true for a function that is decreasing.</p>\n</div>",
        "keyword": "Analysis of Algorithms"
    },
    {
        "question": "What is recurrence for worst case of QuickSort and what is the time complexity in Worst case?",
        "answer": [
            "Recurrence is T(n) = T(n-2) + O(n) and time complexity is O(n^2)",
            "Recurrence is T(n) = T(n-1) + O(n) and time complexity is O(n^2)",
            "Recurrence is T(n) = 2T(n/2) + O(n) and time complexity is O(nLogn)",
            "Recurrence is T(n) = T(n/10) + T(9n/10) + O(n) and time complexity is O(nLogn)"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> The worst case of QuickSort occurs when the picked pivot is always one of the corner elements in sorted array.  In worst case, QuickSort recursively calls one subproblem with size 0 and other subproblem with size (n-1).  So recurrence is\r\n\r\nT(n) = T(n-1) + T(0) + O(n)\r\n\r\nThe above expression can be rewritten as \r\n\r\nT(n) = T(n-1) + O(n)\r\n\r\n[sourcecode language=\"C\"]\r\nvoid exchange(int *a, int *b)\r\n{\r\n  int temp;\r\n  temp = *a;\r\n  *a   = *b;\r\n  *b   = temp;\r\n}\r\n \r\nint partition(int arr[], int si, int ei)\r\n{\r\n  int x = arr[ei];\r\n  int i = (si - 1);\r\n  int j;\r\n \r\n  for (j = si; j &lt;= ei - 1; j++)\r\n  {\r\n    if(arr[j] &lt;= x)\r\n    {\r\n      i++;\r\n      exchange(&amp;arr[i], &amp;arr[j]);\r\n    }\r\n  }\r\n \r\n  exchange (&amp;arr[i + 1], &amp;arr[ei]);\r\n  return (i + 1);\r\n}\r\n \r\n/* Implementation of Quick Sort\r\narr[] --&gt; Array to be sorted\r\nsi  --&gt; Starting index\r\nei  --&gt; Ending index\r\n*/\r\nvoid quickSort(int arr[], int si, int ei)\r\n{\r\n  int pi;    /* Partitioning index */\r\n  if(si &lt; ei)\r\n  {\r\n    pi = partition(arr, si, ei);\r\n    quickSort(arr, si, pi - 1);\r\n    quickSort(arr, pi + 1, ei);\r\n  }\r\n}\r\n[/sourcecode]\r\n</div>",
        "keyword": "Sorting"
    },
    {
        "question": "Suppose we have a O(n) time algorithm that finds median of an unsorted array.  \r\n\r\nNow consider a QuickSort implementation where we first find median using the above algorithm, then use median as pivot.  What will be the worst case time complexity of this modified QuickSort.",
        "answer": [
            "O(n^2 Logn)",
            "O(n^2)",
            "O(n Logn Logn)",
            "O(nLogn)"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> If we use median as a pivot element, then the recurrence for all cases becomes\r\n\r\nT(n) = 2T(n/2) + O(n)\r\n\r\nThe above recurrence can be solved using <a href=\"http://en.wikipedia.org/wiki/Master_theorem\" target=\"_blank\">Master Method</a>.  It falls in case 2 of master method.</div>",
        "keyword": "Sorting"
    },
    {
        "question": "Which of the following is not a stable sorting algorithm in its typical implementation.",
        "answer": [
            "Insertion Sort",
            "Merge Sort",
            "Quick Sort",
            "Bubble Sort"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> See following for details.\r\n\r\n<a href=\"http://www.geeksforgeeks.org/stability-in-sorting-algorithms/\">http://www.geeksforgeeks.org/stability-in-sorting-algorithms/</a></div>",
        "keyword": "Sorting"
    },
    {
        "question": "Which of the following sorting algorithms in its typical implementation gives best performance when applied on an array which is sorted or almost sorted (maximum 1 or two elements are misplaced).",
        "answer": [
            "Quick Sort",
            "Heap Sort",
            "Merge Sort",
            "Insertion Sort"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> Insertion sort takes linear time when input array is sorted or almost sorted  (maximum 1 or 2 elements are misplaced).\r\n\r\nAll other sorting algorithms mentioned above will take more than lienear time in their typical implementation.</div>",
        "keyword": "Sorting"
    },
    {
        "question": "Given an unsorted array. The array has this property that every element in array is at most k distance from its position in sorted array where k is a positive integer smaller than size of array.  Which sorting algorithm can be easily modified for sorting this array and what is the obtainable time complexity?",
        "answer": [
            "Insertion Sort with time complexity O(kn)",
            "Heap Sort with time complexity O(nLogk)",
            "Quick Sort with time complexity O(kLogk)",
            "Merge Sort with time complexity O(kLogk)"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> 1) to sort the array firstly create a min-heap with first k+1 elements and a separate array as resultant array.\r\n2) because elements are at most k distance apart from original position so, it is guranteed that the smallest element will be in this K+1 elements.\r\n3) remove the smallest element from the min-heap(extract min) and put it in the result array.\r\n4) Now,insert another element from the unsorted array into the mean-heap, now,the second smallest element will be in this, perform extract min and continue this process until no more elements are in the unsorted array.finally, use simple heap sort for the remaining elements\r\n\r\nTime Complexity\r\n\r\n------------------------\r\n\r\n1) O(k) to build the initial min-heap\r\n\r\n2) O((n-k)logk) for remaining elements...\r\n\r\n3) 0(1) for extract min\r\n\r\nso overall O(k) + O((n-k)logk) + 0(1) = O(nlogk)</div>",
        "keyword": "Sorting"
    },
    {
        "question": "Consider a situation where swap operation is very costly.   Which of the following sorting algorithms should be preferred so that the number of swap operations are minimized in general?",
        "answer": [
            "Heap Sort",
            "Selection Sort",
            "Insertion Sort",
            "Merge Sort"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> <p>Selection sort makes O(n) swaps which is minimum among all sorting algorithms mentioned above.</p></div>",
        "keyword": "Sorting"
    },
    {
        "question": "Which of the following is not true about comparison based sorting algorithms?",
        "answer": [
            "The minimum possible time complexity of a comparison based sorting algorithm is O(nLogn) for a random input array",
            "Any comparison based sorting algorithm can be made stable by using position as a criteria when two elements are compared",
            "Counting Sort is not a comparison based sorting algorithm",
            "Heap Sort is not a comparison based sorting algorithm."
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> See <a href=\"http://www.geeksforgeeks.org/lower-bound-on-comparison-based-sorting-algorithms/\">http://www.geeksforgeeks.org/lower-bound-on-comparison-based-sorting-algorithms/</a> for point A.  See <a href=\"http://www.geeksforgeeks.org/stability-in-sorting-algorithms/\">http://www.geeksforgeeks.org/stability-in-sorting-algorithms/</a> for B.  C is true, count sort is an Integer Sorting algorithm.</div>",
        "keyword": "Sorting"
    },
    {
        "question": "Suppose we are sorting an array of eight integers using quicksort, and we have just finished the first partitioning with the array looking like this:\r\n\n2  5  1  7  9  12  11  10 \n\r\nWhich statement is correct?",
        "answer": [
            "The pivot could be either the 7 or the 9.",
            "The pivot could be the 7, but it is not the 9",
            "The pivot is not the 7, but it could be the 9",
            "Neither the 7 nor the 9 is the pivot."
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> 7 and 9 both are at their correct positions (as in a sorted array).  Also, all elements on left of 7 and 9 are smaller than 7 and 9 respectively and on right are greater than 7 and 9 respectively.  </div>",
        "keyword": "Sorting"
    },
    {
        "question": "Suppose we are sorting an array of eight integers using heapsort, and we have just finished some heapify (either maxheapify or minheapify) operations. The array now looks like this:\r\n    16  14  15  10  12  27  28\r\nHow many heapify operations have been performed on root of heap?",
        "answer": [
            "1",
            "2",
            "3 or 4",
            "5 or 6"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> In Heapsort, we first build a heap, then we do following operations till the heap size becomes 1.\r\na) Swap the root with last element\r\nb) Call heapify for root\r\nc) reduce the heap size by 1.  \r\n\r\nIn this question, it is given that heapify has been called few times and we see that last two elements in given array are the 2 maximum elements in array.  So situation is clear, it is maxheapify whic has been called 2 times.</div>",
        "keyword": "Sorting"
    },
    {
        "question": "What is the best time complexity of bubble sort?\r\n",
        "answer": [
            "N^2",
            "NlogN",
            "N",
            "N(logN)^2"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> The bubble sort is at its best if the input data is sorted. i.e. If the input data is sorted in the same order as expected output. This can be achieved by using one boolean variable. The boolean variable is used to check whether the values are swapped at least once in the inner loop.\r\nConsider the following code snippet:\r\n[sourcecode language=\"C\"]\r\nint main()\r\n{   \r\n    int arr[] = {10, 20, 30, 40, 50}, i, j, isSwapped;\r\n    int n = sizeof(arr) / sizeof(*arr);\r\n    isSwapped = 1;\r\n    for(i = 0; i &lt; n - 1 &amp;&amp; isSwapped; ++i)\r\n    {\r\n        isSwapped = 0;\r\n        for(j = 0; j &lt; n - i - 1; ++j)\r\n            if (arr[j] &gt; arr[j + 1])\r\n            {\r\n                swap(&amp;arr[j], &amp;arr[j + 1]);\r\n                isSwapped = 1;\r\n            }\r\n    }\r\n    for(i = 0; i &lt; n; ++i)\r\n        printf(\"%d \", arr[i]);\r\n    return 0;\r\n}\r\n[/sourcecode]\r\nPlease observe that in the above code, the outer loop runs only once.</div>",
        "keyword": "Sorting"
    },
    {
        "question": "You have to sort 1 GB of data with only 100 MB of available main memory. Which sorting technique will be most appropriate?\r\n",
        "answer": [
            "Heap sort",
            "Merge sort",
            "Quick sort",
            "Insertion sort"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> The data can be sorted using external sorting which uses merging technique. This can be done as follows:\r\n1. Divide the data into 10 groups each of size 100.\r\n2. Sort each group and write them to disk.\r\n3. Load 10 items from each group into main memory.\r\n4. Output the smallest item from the main memory to disk. Load the next item from the group whose item was chosen.\r\n5. Loop step #4 until all items are not outputted.\r\n\r\nThe step 3-5 is called as merging technique.</div>",
        "keyword": "Sorting"
    },
    {
        "question": "What is the worst case time complexity of insertion sort where position of the data to be inserted is calculated using binary search? \r\n",
        "answer": [
            "N",
            "NlogN",
            "N^2",
            "N(logN)^2"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Applying binary search to calculate the position of the data to be inserted doesn't reduce the time complexity of insertion sort. This is because insertion of a data at an appropriate position involves two steps:\r\n1. Calculate the position.\r\n2. Shift the data from the position calculated in step #1 one step right to create a gap where the data will be inserted.\r\n\r\nUsing binary search reduces the time complexity in step #1 from O(N) to O(logN). But, the time complexity in step #2 still remains O(N). So, overall complexity remains O(N^2).</div>",
        "keyword": "Sorting"
    },
    {
        "question": " The tightest lower bound on the number of comparisons, in the worst case, for comparison-based sorting is of the order of",
        "answer": [
            "N",
            "N^2",
            "NlogN",
            "N(logN)^2"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> The number of comparisons that a comparison sort algorithm requires increases in proportion to Nlog(N), where N is the number of elements to sort. This bound is asymptotically tight:\r\n\r\nGiven a list of distinct numbers (we can assume this because this is a worst-case analysis), there are N factorial permutations exactly one of which is the list in sorted order. The sort algorithm must gain enough information from the comparisons to identify the correct permutations. If the algorithm always completes after at most f(N) steps, it cannot distinguish more than 2^f(N) cases because the keys are distinct and each comparison has only two possible outcomes. Therefore,\r\n\r\n2^f(N) &gt;= N! or equivalently f(N) &gt;= log(N!).\r\nSince log(N!) is Omega(NlogN), the answer is NlogN.\r\nFor more details, <a href=\"http://en.wikipedia.org/wiki/Comparison_sort\" target=\"_blank\">read here</a>\n</div>",
        "keyword": "Sorting"
    },
    {
        "question": "In a modified merge sort, the input array is splitted at a position one-third of the length(N) of the array. Which of the following is the tightest upper bound on time complexity of this modified Merge Sort.",
        "answer": [
            "N(logN base 3)",
            "N(logN base 2/3)",
            "N(logN base 1/3)",
            "N(logN base 3/2)"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> The time complexity is given by:\r\nT(N) = T(N/3) + T(2N/3) + N\r\nSolving the above recurrence relation gives, T(N) = N(logN base 3/2)</div>",
        "keyword": "Sorting"
    },
    {
        "question": "Which sorting algorithm will take least time when all elements of input array are identical?  Consider typical implementations of sorting algorithms.",
        "answer": [
            "Insertion Sort",
            "Heap Sort",
            "Merge Sort",
            "Selection Sort"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> The insertion sort will take <img alt=\"\\theta\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"19\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-a372b7ef1ffaec3b4ad80e0141550990_l3.png\" style=\"vertical-align: 0px;\" title=\"Rendered by QuickLaTeX.com\" width=\"11\"/>(n) time when input array is already sorted. </div>",
        "keyword": "Sorting"
    },
    {
        "question": "In quick sort, for sorting n elements, the (n/4)th smallest element is selected as pivot using an O(n) time algorithm. What is the worst case time complexity of the quick sort?\r\n",
        "answer": "None",
        "correct": "None",
        "explain": "None",
        "keyword": "Sorting"
    },
    {
        "question": "Consider the Quicksort algorithm. Suppose there is a procedure for finding a pivot element which splits the list into two sub-lists each of which contains at least one-fifth of the elements. Let T(n) be the number of comparisons required to sort n elements. Then ",
        "answer": [
            " T(n) <= 2T(n/5) + n ",
            "T(n) <= T(n/5) + T(4n/5) + n",
            "T(n) <= 2T(4n/5) + n",
            " T(n) <= 2T(n/2) + n"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> For the case where n/5 elements are in one subset, T(n/5) comparisons are needed for the first subset with n/5 elements, T(4n/5) is for the rest 4n/5 elements, and n is for finding the pivot.  \r\n\r\nIf there are more than n/5 elements in one set then other set will have less than 4n/5 elements and time complexity will be less than  T(n/5) + T(4n/5) + n because recursion tree will be more balanced.</div>",
        "keyword": "Sorting"
    },
    {
        "question": "Which of the following sorting algorithms has the lowest worst-case complexity?",
        "answer": [
            "Merge Sort",
            "Bubble Sort",
            "Quick  Sort",
            "Selection Sort"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Worst case complexities for the above sorting algorithms are as follows:\r\nMerge Sort — nLogn\r\nBubble Sort — n^2\r\nQuick Sort — n^2\r\nSelection Sort — n^2</div>",
        "keyword": "Sorting"
    },
    {
        "question": "Which sorting algorithms is most efficient to sort string consisting of ASCII characters?",
        "answer": [
            "Quick sort",
            "Heap sort",
            "Merge sort",
            "Counting sort"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> <a href=\"http://en.wikipedia.org/wiki/Counting_sort\" target=\"_blank\">Counting sort</a> algorithm is efficient when range of data to be sorted is fixed. In the above question, the range is from 0 to 255(ASCII range). Counting sort uses an extra constant space proportional to range of data.</div>",
        "keyword": "Sorting"
    },
    {
        "question": "The number of elements that can be sorted in  time using heap sort is ",
        "answer": "None",
        "correct": "None",
        "explain": "None",
        "keyword": "Sorting"
    },
    {
        "question": "Which of the following is true about merge sort?",
        "answer": [
            "Merge Sort works better than quick sort if data is accessed from slow sequential memory.",
            "Merge Sort is stable sort by nature",
            "Merge sort outperforms heap sort in most of the practical situations.",
            "All of the above."
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> See <a href=\"http://geeksquiz.com/merge-sort/\">Merge Sort</a> and <a href=\"http://en.wikipedia.org/wiki/Heapsort#Comparison_with_other_sorts\">this</a>.\r\n</div>",
        "keyword": "Sorting"
    },
    {
        "question": "Given an array where numbers are in range from 1 to n6,  which sorting algorithm can be used to sort these number in linear time?",
        "answer": [
            "Not possible to sort in linear time",
            "Radix Sort",
            "Counting Sort",
            "Quick Sort"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> See <a href=\"http://www.geeksforgeeks.org/radix-sort/\" target=\"_blank\">Radix Sort</a> for explanation.</div>",
        "keyword": "Sorting"
    },
    {
        "question": "In quick sort, for sorting n elements, the (n/4)th smallest element is selected as pivot using an O(n) time algorithm. What is the worst case time complexity of the quick sort?\n<pre>\r\n(A) (n)\r\n(B) (nLogn)\r\n(C) (n^2)\r\n(D) (n^2 log n) </pre>\r\n\r\n ",
        "answer": [
            "A",
            "B",
            "C",
            "D"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Answer(B)\r\nThe recursion expression becomes:\r\n\r\nT(n) = T(n/4) + T(3n/4) + cn\r\n\r\nAfter solving the above recursion, we get \\theta(nLogn).</div>",
        "keyword": "Sorting"
    },
    {
        "question": "Consider the Quicksort algorithm. Suppose there is a procedure for finding a pivot element which splits the list into two sub-lists each of which contains at least one-fifth of the elements. Let T(n) be the number of comparisons required to sort n elements. Then \r\n",
        "answer": [
            "T(n) <= 2T(n/5) + n ",
            "T(n) <= T(n/5) + T(4n/5) + n",
            "T(n) <= 2T(4n/5) + n",
            " T(n) <= 2T(n/2) + n"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> For the case where n/5 elements are in one subset, T(n/5) comparisons are needed for the first subset with n/5 elements, T(4n/5) is for the rest 4n/5 elements, and n is for finding the pivot.  \r\n\r\nIf there are more than n/5 elements in one set then other set will have less than 4n/5 elements and time complexity will be less than  T(n/5) + T(4n/5) + n because recursion tree will be more balanced.</div>",
        "keyword": "Sorting"
    },
    {
        "question": "Let P be a QuickSort Program to sort numbers in ascending order using the first element as pivot. Let t1 and t2 be the number of comparisons made by P for the inputs {1, 2, 3, 4, 5} and {4, 1, 5, 3, 2} respectively. Which one of the following holds?",
        "answer": [
            "t1 = 5",
            "t1 < t2",
            "t1 > t2",
            "t1 =  t2"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> When first element or last element is chosen as pivot, <a href=\"http://geeksquiz.com/quick-sort/\" target=\"_blank\">Quick Sort</a>'s worst case occurs for the sorted arrays.\r\n\r\nIn every step of quick sort, numbers are divided as per the following recurrence.\r\n\r\nT(n) = T(n-1) + O(n)\r\n\r\n</div>",
        "keyword": "Sorting"
    },
    {
        "question": "You have an array of n elements. Suppose you implement quicksort by always choosing the central element of the array as the pivot. Then the tightest upper bound for the worst case performance is",
        "answer": [
            "O(n2)",
            "O(nLogn)",
            "Theta(nLogn)",
            "O(n3)"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> For any input, there are some permutations for which worst case will be <em>O(n<sup>2</sup>)</em>.  In some case, choosing the middle element minimizes the chances of encountering <em>O(n<sup>2</sup>), </em>but in worst case it can go to <em>O(n<sup>2</sup>).</em> Whichever element we take as Pivot, either first or middle, worst case will be <em>O(n<sup>2</sup>) </em>since Pivot is fixed in position. While choosing a random pivot minimizes the chances of encountering worst case i.e. <em>O(n<sup>2</sup>).</em>\r\n\r\nRefer <a href=\"http://www.geeksforgeeks.org/quick-sort/\" rel=\"noopener\" target=\"_blank\">this</a> article on Quick Sort.</div>",
        "keyword": "Sorting"
    },
    {
        "question": "In a permutation a1.....an of n distinct integers, an inversion is a pair (ai, aj) such that i < j and ai > aj. What would be the worst case time complexity of the Insertion Sort algorithm, if the inputs are restricted to permutations of 1.....n with at most n inversions?",
        "answer": [
            "Θ (n2)",
            "Θ (n log n)",
            "Θ (n1.5)",
            "Θ (n)"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> Insertion sort runs in Θ(n + f(n)) time, where f(n) denotes the number of inversion initially present in the array being sorted.\r\n\r\nSource: <a href=\"http://cs.xidian.edu.cn/jpkc/Algorithm/down/Solution%20to%202-4%20Inversions.pdf\" target=\"_blank\">http://cs.xidian.edu.cn/jpkc/Algorithm/down/Solution%20to%202-4%20Inversions.pdf</a></div>",
        "keyword": "Sorting"
    },
    {
        "question": "Randomized quicksort is an extension of quicksort where the pivot is chosen randomly. What is the worst case complexity of sorting n numbers using randomized quicksort?",
        "answer": [
            " O(n)",
            " O(n Log n)",
            " O(n2)",
            "O(n!)"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> If all elements of the given array are same then that is the worst case for the randomised quicksort. And time complexity of worst case of quicksort is O(n²) that is proven already.\r\n\r\nSo, option (C) is correct.</div>",
        "keyword": "Sorting"
    },
    {
        "question": "Which of the following changes to typical QuickSort improves its performance on average and are generally done in practice.\r\n\r\n1) Randomly picking up to make worst case less \r\n   likely to occur.\r\n2) Calling insertion sort for small sized arrays \r\n   to reduce recursive calls.\r\n3) QuickSort is tail recursive, so tail call \r\n   optimizations can be done.\r\n4) A linear time median searching algorithm is used \r\n   to pick the median, so that the worst case time \r\n   reduces to O(nLogn)\r\n\n",
        "answer": [
            "1 and 2",
            "2, 3, and 4",
            "1, 2 and 3",
            "2, 3 and 4"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> The 4th optimization is generally not used, it reduces the worst case time complexity to O(nLogn), but the hidden constants are very high.</div>",
        "keyword": "Sorting"
    },
    {
        "question": "Which one of the following is the recurrence equation for the worst case time complexity of the Quicksort algorithm for sorting n(≥ 2) numbers? In the recurrence equations given in the options below, c is a constant.\r\n",
        "answer": [
            "T(n) = 2T (n/2) + cn ",
            "T(n) = T(n – 1) + T(0) + cn",
            "T(n) = 2T (n – 2) + cn ",
            "T(n) = T(n/2) + cn"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> In worst case, the chosen pivot is always placed at a corner position and recursive call is made for following.\r\n\r\na) for subarray on left of pivot which is of size n-1 in worst case.\r\nb) for subarray on right of pivot which is of size 0 in worst case.</div>",
        "keyword": "Sorting"
    },
    {
        "question": "Assume that a mergesort algorithm in the worst case takes 30 seconds for an input of size 64. Which of the following most closely approximates the maximum input size of a problem that can be solved in 6 minutes?",
        "answer": [
            "256",
            "512",
            "1024",
            "2048"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>\r\nTime complexity of merge sort is Θ(nLogn)\r\n\r\nc*64Log64 is 30\r\nc*64*6 is 30\r\nc is 5/64\r\n\r\nFor time 6 minutes\r\n\r\n5/64*nLogn = 6*60\r\n\r\nnLogn = 72*64 = 512 * 9\r\n\r\nn = 512. </pre>\n</div>",
        "keyword": "Sorting"
    },
    {
        "question": "The worst case running times of Insertion sort, Merge sort and Quick sort, respectively, are:\r\n\r\n",
        "answer": [
            " Θ(n log n),  Θ(n log n) and  Θ(n2)\r\n ",
            "Θ(n2),   Θ(n2) and  Θ(n Log n)\r\n",
            " Θ(n2),  Θ(n log n) and Θ(n log n) \r\n ",
            "Θ(n2),  Θ(n log n) and  Θ(n2)"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> <ul>\n<li><a href=\"http://geeksquiz.com/insertion-sort/\" target=\"_blank\">Insertion Sort</a> takes Θ(n<sup>2</sup>) in worst case as we need to run two loops. The outer loop is needed to one by one pick an element to be inserted at right position. Inner loop is used for two things, to find position of the element to be inserted and moving all sorted greater elements one position ahead. Therefore the worst case recursive formula is T(n) = T(n-1) + Θ(n).</li>\n<li><a href=\"http://geeksquiz.com/merge-sort/\" target=\"_blank\">Merge Sort</a> takes Θ(n Log n)  time in all cases. We always divide array in two halves, sort the two halves and merge them. The recursive formula is T(n) = 2T(n/2) + Θ(n).</li>\n<li><a href=\"http://geeksquiz.com/quick-sort/\" target=\"_blank\">QuickSort</a> takes Θ(n<sup>2</sup>) in worst case. In QuickSort, we take an element as pivot and partition the array around it. In worst case, the picked element is always a corner element and recursive formula becomes T(n) = T(n-1) + Θ(n).  An example scenario when worst case happens is, arrays is sorted and our code always picks a corner element as pivot.</li>\n</ul>\r\n \r\n\r\n </div>",
        "keyword": "Sorting"
    },
    {
        "question": "Assume that the algorithms considered here sort the input sequences in ascending order. If the input is already in ascending order, which of the following are TRUE ? \r\nI.   Quicksort runs in Θ(n2) time\r\nII.  Bubblesort runs in Θ(n2) time\r\nIII. Mergesort runs in  Θ(n) time\r\nIV.  Insertion sort runs in  Θ(n) time \n",
        "answer": [
            "  I and II only",
            "  I and III only",
            "  II and IV only",
            " I and IV only"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> <strong>I.</strong>  Given an array in ascending order, Recurrence relation for total number of comparisons for quicksort will be\r\nT(n) = T(n-1)+O(n)    //partition algo will take O(n) comparisons in any case.\r\n     = O(n^2)\r\n\r\n<strong>II.</strong>  Bubble Sort runs in Θ(n^2) time\r\n\r\nIf an array is in ascending order, we could make a small modification in Bubble Sort Inner for loop which is responsible for bubbling the kth largest element to the end in kth iteration. Whenever there is no swap after the completion of inner for loop of bubble sort in any iteration, we can declare that array is sorted in case of Bubble Sort taking O(n) time in Best Case.\r\n\r\n<strong>III.</strong> Merge Sort runs in  Θ(n) time\r\nMerge Sort relies on Divide and Conquer paradigm to sort an array and there is no such worst or best case input for merge sort. For any sequence, Time complexity will be given by following recurrence relation,\r\n\r\nT(n) = 2T(n/2) + Θ(n)        // In-Place Merge algorithm will take Θ(n) due to copying an entire array.\r\n= Θ(nlogn)\r\n\r\n<strong>IV.</strong>  Insertion sort runs in  Θ(n) time\r\n\r\nWhenever a new element which will be greater than all the elements of the intermediate sorted sub-array ( because given array is sorted) is added, there won't be any swap but a single comparison. In n-1 passes we will be having 0 swaps and n-1 comparisons.\r\nTotal time complexity = O(n)             // N-1 Comparisons\r\n\r\n\r\n\r\nThis solution is contributed by <strong>Pranjul Ahuja</strong>\n<br/>\r\n////\r\nFor an array already sorted in ascending order,\r\nQuicksort has a complexity Θ(n<sup>2</sup>) [Worst Case]\r\nBubblesort has a complexity Θ(n) [Best Case]\r\nMergesort has a complexity Θ(n  log n) [Any Case]\r\nInsertsort has a complexity Θ(n) [Best Case]\r\n</div>",
        "keyword": "Sorting"
    },
    {
        "question": "Assume that we use Bubble Sort to sort n distinct elements in ascending order. When does the best case of Bubble Sort occur?",
        "answer": [
            "When elements are sorted in ascending order",
            "When elements are sorted in descending order",
            "When elements are not sorted by any order",
            "There is no best case for Bubble Sort. It always takes O(n*n) time"
        ],
        "correct": "A",
        "explain": "None",
        "keyword": "Sorting"
    },
    {
        "question": "If we use Radix Sort to sort n integers in the range (nk/2,nk], for some k>0 which is independent of n, the time taken would be?",
        "answer": [
            "Θ(n)",
            "Θ(kn)",
            "Θ(nlogn)",
            "Θ(n2)"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Radix sort time complexity = O(wn)<br/>\r\nfor n keys of word size= w\r\n<br/>=&gt;w = log(n<sup>k</sup>)\r\n<br/>O(wn)=O(klogn.n)\r\n<br/> =&gt; kO(nlogn)</div>",
        "keyword": "Sorting"
    },
    {
        "question": "Consider an array of elements arr[5]= {5,4,3,2,1} , what are the steps of insertions done while doing insertion sort in the array.\r\n\r\n ",
        "answer": [
            "4 5 3 2 1\r\n3 4 5 2 1\r\n2 3 4 5 1\r\n1 2 3 4 5\r\n",
            "5 4 3 1 2\r\n5 4 1 2 3\r\n5 1 2 3 4\r\n1 2 3 4 5\r\n",
            "4 3 2 1 5\r\n3 2 1 5 4\r\n2 1 5 4 3\r\n1 5 4 3 2\r\n",
            "4 5 3 2 1\r\n2 3 4 5 1\r\n3 4 5 2 1\r\n1 2 3 4 5\r\n"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> In the insertion sort , just imagine that the first element is already sorted and all the right side Elements are unsorted, we need to insert all elements one by one from left to right in the sorted Array.\r\n\r\nSorted : 5                                unsorted : 4 3 2 1\r\n\r\nInsert all elements less than 5 on the left (Considering 5 as the key )\r\n\r\nNow key value is 4 and array will look like this\r\n\r\nSorted : 4 5                             unsorted : 3 2 1\r\n\r\nSimilarly for all the cases the key will always be the newly inserted value and all the values will be compared to that key and inserted in to proper position.</div>",
        "keyword": "Sorting"
    },
    {
        "question": "Which is the correct order of the following algorithms with respect to their time Complexity in the best case ?",
        "answer": [
            "Merge sort > Quick sort >Insertion sort > selection sort",
            "insertion sort < Quick sort < Merge sort <  selection sort ",
            "Merge sort > selection sort > quick sort > insertion sort",
            "Merge sort > Quick sort > selection sort > insertion sort "
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>\r\nIn best case, \r\n\r\nQuick sort: O (nlogn) \r\nMerge sort: O (nlogn)\r\nInsertion sort: O (n)\r\nSelection sort: O (n^2)  </pre>\n</div>",
        "keyword": "Sorting"
    },
    {
        "question": "Which of the following statements is correct with respect to insertion sort ? \r\n*Online - can sort a list at runtime\r\n*Stable - doesn't change the relative \r\n          order of elements with equal keys. ",
        "answer": [
            "Insertion sort is stable, online but not suited well for large number of elements.",
            "Insertion sort is unstable and online",
            "Insertion sort is online and can be applied to more than 100 elements",
            "Insertion sort is stable & online and can be applied to more than 100 elements"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Time taken by algorithm is good for small number of elements, but increases quadratically for large number of elements.</div>",
        "keyword": "Sorting"
    },
    {
        "question": "Consider the array A[]= {6,4,8,1,3} apply the insertion sort to sort the array . Consider the cost associated with each sort is 25 rupees , what is the total cost of the insertion sort when element 1 reaches the first position of the array  ?",
        "answer": [
            "50",
            "25",
            "75",
            "100"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> When the element 1 reaches the first position of the array two comparisons are only required hence 25 * 2= 50 rupees.\r\n\r\n*step 1: 4 6 8 1 3 .\r\n\r\n*step 2: 1 4 6 8 3.</div>",
        "keyword": "Sorting"
    },
    {
        "question": "The auxiliary space of insertion sort is O(1), what does O(1) mean ?",
        "answer": [
            "The memory (space) required to process the data is not constant.",
            "It means the amount of extra memory Insertion Sort consumes doesn't depend on the input. The algorithm should use the same amount of memory for all inputs.",
            "It takes only 1 kb of memory .",
            "It is the speed at which the elements are traversed."
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> The term O(1) states that the space required by the insertion sort is constant i.e., space required doesn't depend on input.</div>",
        "keyword": "Sorting"
    },
    {
        "question": "What is the best sorting algorithm to use for the elements in array are more than 1 million in general?",
        "answer": [
            "Merge sort.\r\n",
            "Bubble sort.",
            "Quick sort.",
            "Insertion sort.\r\n\r\n"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Most practical implementations of Quick Sort use randomized version. The randomized version has expected time complexity of O(nLogn). The worst case is possible in randomized version also, but worst case doesn’t occur for a particular pattern (like sorted array) and randomized Quick Sort works well in practice.\r\n\r\nQuick Sort is also a cache friendly sorting algorithm as it has good locality of reference when used for arrays.\r\n\r\nQuick Sort is also tail recursive, therefore tail call optimizations is done.</div>",
        "keyword": "Sorting"
    },
    {
        "question": "Which of the below given sorting techniques has highest best-case runtime complexity.",
        "answer": [
            " Quick sort \r\n",
            "Selection sort ",
            "Insertion sort \r\n",
            "Bubble sort \r\n"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> \r\nQuick sort best case time complexity is Ο(n logn) <br/>\r\nSelection sort best case time complexity is Ο(n^2 ) \r\nInsertion sort best case time complexity is Ο(n)<br/> \r\nBubble sort best case time complexity is Ο(n) \r\n</div>",
        "keyword": "Sorting"
    },
    {
        "question": "A sorting technique is called stable if:",
        "answer": [
            "It takes O(nlog n)time",
            "It maintains the relative order of occurrence of non-distinct elements ",
            "It uses divide and conquer paradigm",
            "It takes O(n) space"
        ],
        "correct": "B",
        "explain": "None",
        "keyword": "Sorting"
    },
    {
        "question": "If one uses straight two-way merge sort algorithm to sort the following elements in ascending order 20, 47, 15, 8, 9, 4, 40, 30, 12, 17\r\nthen the order of these elements after the second pass of the algorithm is:",
        "answer": [
            "8, 9, 15, 20, 47, 4, 12, 17, 30, 40",
            "8, 15, 20, 47, 4, 9, 30, 40, 12, 17",
            "15, 20, 47, 4, 8, 9, 12, 30, 40, 17",
            "4, 8, 9, 15, 20, 47, 12, 17, 30, 40"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> In first pass the elements are sorted in n/4 (first 2 elements in each group) sub arrays but in second pass the elements are sorted in n/2 (first 4 elements in each group) sub arrays.</div>",
        "keyword": "Sorting"
    },
    {
        "question": "Quicksort is run on two inputs shown below to sort in ascending order taking first element as pivot,\r\n(i) 1, 2, 3,......., n\r\n(ii) n, n-1, n-2,......, 2, 1 \r\nLet C1 and C2 be the number of comparisons made for the inputs (i) and (ii) respectively. Then,",
        "answer": [
            "C1 < C2 ",
            "C1 > C2",
            "C1 = C2",
            "We cannot say anything for arbitrary n"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> <a href=\"https://www.geeksforgeeks.org/quick-sort/\" rel=\"noopener\" target=\"_blank\">Quick Sort</a> performs in worst case when input is sorted in either ascending order or descending order. So, quick sort will return equal number of comparisons for both given inputs.\r\n\r\nOption (C) is correct.</div>",
        "keyword": "Sorting"
    },
    {
        "question": "A two dimensional array A[1...n][1...n] of integers is partially sorted if\r\n∀i, j ∈ [1...n−1], A[i][j] < A[i][j+1] and A[i][j] < A[i+1][j]\r\nFill in the blanks:\r\n\r\na) The smallest item in the array is at A[i][j] where i=..................and j=......................\r\nb) The smallest item is deleted. Complete the following O(n) procedure to insert item x (which is guaranteed to be smaller than any item in the last row or column) still keeping A partially sorted.\r\nprocedure insert (x: integer);\r\nvar i,j: integer;\r\nbegin\r\n    i:=1; j:=1, A[i][j]:=x;\r\n    while (x > ...... or x > ......) do\r\n        if A[i+1][j] < A[i][j] ......... then begin\r\n            A[i][j]:=A[i+1][j]; i:=i+1;\r\n        end\r\n        else begin\r\n            ............\r\n        end\r\n    A[i][j]:= .............\r\nend\r\n.\r\n",
        "answer": "None",
        "correct": "None",
        "explain": "None",
        "keyword": "Sorting"
    },
    {
        "question": "A sorting technique is called stable if",
        "answer": [
            "If it takes O(n log n) time",
            "It uses divide and conquer technique",
            "Relative order of occurrence of non-distinct elements is maintained",
            "It takes O(n) space"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Refer <a href=\"https://www.geeksforgeeks.org/stability-in-sorting-algorithms\" rel=\"noopener\" target=\"_blank\">Stability in sorting algorithms</a>\r\nOption (C) is correct.</div>",
        "keyword": "Sorting"
    },
    {
        "question": "Quick sort is run on 2 inputs shown below to sort in ascending order\r\nA. 1, 2, 3……n\r\nB. n, n – 1, n – 2 …… 1\r\nLet C1 and C2 be the number of comparisons made for A and B respectively. Then\r\n",
        "answer": [
            "C1 > C2",
            "C1 = C2",
            "C1 < C2 \n",
            "Cannot say anything for arbitrary n"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Both case A and case B will yield worst case comparisons if the pivot chosen is either first or last element.\r\n\r\nRefer: <a href=\"https://www.geeksforgeeks.org/gate-gate-cs-1996-question-40/\" rel=\"noopener\" target=\"_blank\">GATE CS 1996 | Question 40</a>\r\n\r\nOption (B) is correct. </div>",
        "keyword": "Sorting"
    },
    {
        "question": "You are given a sequence of n elements to sort. The input sequence consists of n/k subsequences,each containing k elements. The elements in a given subsequence are all smaller than the elements in the succeeding subsequence and larger than the elements in the preceding subsequence. Thus, all that is needed to sort the whole sequence of length n is to sort the k elements in each of the n/k subsequences.\r\n\r\nThe lower bound on the number of comparisons needed to solve this variant of the sorting problem is",
        "answer": [
            "Ω (n)",
            "Ω (n/k)",
            "Ω (nlogk )",
            "Ω (n/klogn/k)"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> We have n/k subsequences each containing k elements.\r\n\r\nIf we use the quick sort technique to sort k elements in a subsequence then the complexity of sorting k elements of a subsequence is klogk.\r\n\r\nAnd we have n/k such sequences. Then the time complexity of n/k subsequences having k elements will be:\r\n\r\n= (n/k)* klogk\r\n\r\n= nlogk</div>",
        "keyword": "Sorting"
    },
    {
        "question": "Which of the following is true for computation time in insertion, deletion and finding maximum and minimum element in a sorted array ? ",
        "answer": [
            "Insertion – 0(1), Deletion – 0(1), Maximum – 0(1), Minimum – 0(l) ",
            "Insertion – 0(1), Deletion – 0(1), Maximum – 0(n), Minimum – 0(n)",
            "Insertion – 0(n), Deletion – 0(n), Maximum – 0(1), Minimum – 0(1)",
            "Insertion – 0(n), Deletion – 0(n), Maximum – 0(n), Minimum – 0(n) "
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> <ol><li>In a sorted array, if we want to insert or delete then we have to traverse whole array and check where is the suitable position, so it will take \r\nO(n). </li>\n<li>If array is sorted then end position will tell the maximum or minimum, so finding maximum or minimum will take O(1).</li></ol>\r\nSo, option (C) is correct.\r\n</div>",
        "keyword": "Sorting"
    },
    {
        "question": "Consider the following sorting algorithms.\r\nI.   Quicksort\r\nII.  Heapsort\r\nIII. Mergesort\r\nWhich of them perform in least time in the worst case?",
        "answer": [
            "I and II only",
            "II and III only",
            "III only",
            "I, II and III"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Worst case complexity of Heap Sort and Merge Sort is O(n log n) whereas the worst case complexity of Quicksort is O(n<sup>2</sup>).\r\n(B) option is correct.</div>",
        "keyword": "Sorting"
    },
    {
        "question": "Which of the following algorithms sort n integers, having the range 0 to (n2 - 1), in ascending order in O(n) time ? ",
        "answer": [
            "Selection sort   ",
            "Bubble sort   ",
            "Radix sort\t",
            "Insertion sort"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> <ul><li>Selection sort takes O(n<sup>2</sup>) time.</li><li>Bubble sort takes O(n<sup>2</sup>) time.</li><li>Radix sort\ttakes O(n) time.</li><li>Insertion sort takes O(n<sup>2</sup>) time.</li></ul>\r\nSo, option (C) is correct.</div>",
        "keyword": "Sorting"
    },
    {
        "question": "Which one of the following in place sorting algorithms needs the minimum number of swaps?\r\n",
        "answer": [
            "Quick sort",
            "Insertion sort",
            "Selection sort",
            " Heap sort\r\n"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Selection sort takes minimum number of swaps to sort an array. It takes maximum of O(n) comparisons to sort an array with n elements.\r\nRefer: <a href=\"https://www.geeksforgeeks.org/selection-sort/\" rel=\"noopener\" target=\"_blank\">Selection sort  </a></div>",
        "keyword": "Sorting"
    },
    {
        "question": "Which of the following algorithm design technique is used in merge sort?",
        "answer": [
            "Greedy method",
            "Backtracking",
            " Dynamic programming",
            " Divide and Conquer"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> <a href=\"https://www.geeksforgeeks.org/merge-sort/\" rel=\"noopener\" target=\"_blank\">Merge sort</a> uses <strong>Divide and Conquer</strong> approach to sort the elements. Array is recursively divided in two halves till the size becomes 1. Once the size of array becomes 1, the merge process comes into action and starts merging the arrays back till the complete array is merged.\r\n</div>",
        "keyword": "Sorting"
    },
    {
        "question": "Selection sort algorithm design technique is an example of",
        "answer": [
            "Greedy method",
            "Divide-and-conquer",
            "Dynamic Programming",
            "Backtracking"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> The selection sort algorithm sorts an array by repeatedly finding the minimum element (considering ascending order) from unsorted part and putting it at the beginning. The algorithm maintains two subarrays in a given array.\r\n\r\n1) The subarray which is already sorted.\r\n2) Remaining subarray which is unsorted.\r\n\r\nIn every iteration of selection sort, the minimum element (considering ascending order) from the unsorted subarray is picked and moved to the sorted subarray. Clearly, it is a greedy approach to sort the array.\r\n\r\nOption (A) is correct.</div>",
        "keyword": "Sorting"
    },
    {
        "question": "The average case and worst case complexities for Merge sort algorithm are",
        "answer": [
            "O ( n2 ), O ( n2 )",
            " O ( n2 ), O ( n log2n )",
            "O ( n log2n ),  O ( n2)",
            "O ( n log2n ), O ( n log2n )"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> The best case, average case and worst case complexities for Merge sort algorithm are O( nlog<sub>2</sub>n ).\r\n\r\nSo, option (D) is correct.</div>",
        "keyword": "Sorting"
    },
    {
        "question": "You have to sort a list L, consisting of a sorted list followed by a few ‘random’ elements. Which of the following sorting method would be most suitable for such a task?",
        "answer": [
            "Bubble sort",
            "Selection sort",
            "Quick sort",
            "Insertion sort\r\n"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> For a sorted list with few random numbers:\r\n<li>Bubble sort will take O(n<sup>2</sup>) time in best case.</li><li>Selection sort will take O(n<sup>2</sup>) time in best case.</li><li>Quick sort will take O(n<sup>2</sup>) time in this case because it is the worst case for quick sort.</li><li>Insertion sort will take O(n)</li>\r\nSo, option (D) is correct.</div>",
        "keyword": "Sorting"
    },
    {
        "question": "Which of the following algorithms is NOT a divide & conquer algorithm by nature?",
        "answer": [
            "Euclidean algorithm to compute the greatest common divisor ",
            "Heap Sort",
            "Cooley-Tukey fast Fourier transform ",
            "Quick Sort"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> See <a href=\"http://www.geeksforgeeks.org/divide-and-conquer-set-1-find-closest-pair-of-points/\">Divide and Conquer</a></div>",
        "keyword": "Divide and Conquer"
    },
    {
        "question": "Consider the following C program\r\n\r\n\r\nint main() \r\n{ \r\n   int x, y, m, n; \r\n   scanf (\"%d %d\", &x, &y); \r\n   /* x > 0 and y > 0 */\r\n   m = x; n = y; \r\n   while (m != n) \r\n   { \r\n      if(m>n) \r\n         m = m - n; \r\n      else\r\n         n = n - m; \r\n   } \r\n   printf(\"%d\", n); \r\n}\r\n\r\nWhat does the program compute? (GATE CS 2004)",
        "answer": [
            "x + y using repeated subtraction",
            "x mod y using repeated subtraction",
            "the greatest common divisor of x and y",
            "the least common multiple of x and y\r\n"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> This is an implementation of <a href=\"http://en.wikipedia.org/wiki/Euclidean_algorithm\">Euclid’s algorithm</a> to find GCD</div>",
        "keyword": "Divide and Conquer"
    },
    {
        "question": "Consider the polynomial p(x) = a0 + a1x + a2x^2 +a3x^3, where ai != 0, for all i. The minimum number of multiplications needed to evaluate p on an input x is:",
        "answer": [
            "3",
            "4",
            "6",
            "9"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Multiplications can be minimized using following order for evaluation of the given expression.\r\np(x) = a0 + x(a1 + x(a2 + a3x))</div>",
        "keyword": "Divide and Conquer"
    },
    {
        "question": "Maximum Subarray Sum problem is to find the subarray with maximum sum.  For example, given an array {12, -13, -5, 25, -20, 30, 10}, the maximum subarray sum is 45.\r\n\r\nThe naive solution for this problem is to calculate sum of all subarrays starting with every element and return the maximum of all.  We can solve this using Divide and Conquer, what will be the worst case time complexity using Divide and Conquer.",
        "answer": [
            "O(n)",
            "O(nLogn)",
            "O(Logn)",
            "O(n^2)"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> See <a href=\"http://www.geeksforgeeks.org/divide-and-conquer-maximum-sum-subarray/\" target=\"_blank\">http://www.geeksforgeeks.org/divide-and-conquer-maximum-sum-subarray/</a></div>",
        "keyword": "Divide and Conquer"
    },
    {
        "question": "Consider a situation where you don't have function to calculate power (pow() function in C) and you need to calculate x^n where x can be any number and n is a positive integer.  What can be the best possible time complexity of your power function?",
        "answer": [
            "O(n)",
            "O(nLogn)",
            "O(LogLogn)",
            "O(Logn)"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> We can calculate power using divide and conquer in O(Logn) time.  See <a href=\"http://www.geeksforgeeks.org/write-a-c-program-to-calculate-powxn/\" target=\"_blank\">http://www.geeksforgeeks.org/write-a-c-program-to-calculate-powxn/</a>.\r\n</div>",
        "keyword": "Divide and Conquer"
    },
    {
        "question": "Consider the problem of searching an element x in an array 'arr[]' of size n.  The problem can be solved in O(Logn) time if.\r\n1) Array is sorted \r\n2) Array is sorted and rotated by k.  k is given to you and k  <= n\r\n3) Array is sorted and rotated by k.  k is NOT given to you and k  <= n\r\n4) Array is not sorted",
        "answer": [
            "1 Only",
            "1 & 2 only",
            "1, 2 and 3 only",
            "1, 2, 3 and 4"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> See  <a href=\"http://www.geeksforgeeks.org/search-an-element-in-a-sorted-and-pivoted-array/\" target=\"_blank\">http://www.geeksforgeeks.org/search-an-element-in-a-sorted-and-pivoted-array/</a></div>",
        "keyword": "Divide and Conquer"
    },
    {
        "question": "The secant method is used to find the root of an equation f(x) = 0. It is started from two distinct estimates xa and xb for the root. It is an iterative procedure involving linear interpolation to a root. The iteration stops if f(xb) is very small and then xb is the solution. The procedure is given below. Observe that there is an expression which is missing and is marked by? Which is the suitable expression that is to be put in place of? So that it follows all steps of the secant method?\r\n\r\nSecant\nInitialize: xa, xb, ε, N     // ε = convergence indicator\r\nfb = f(xb) i = 0\r\nwhile (i < N and |fb| > ε) do\r\n   i = i + 1                 // update counter\r\n   xt = ?                    // missing expression for\r\n                             // intermediate value\r\n   xa = xb                   // reset xa\r\n   xb = xt                   // reset xb\r\n   fb = f(xb)                // function value at new xb\r\nend while\r\nif |fb| > ε\r\n  then // loop is terminated with i = N\r\n  write “Non-convergence”\r\nelse\r\n  write “return xb”\r\nend if ",
        "answer": [
            "xb – (fb– f(xa)) fb/ (xb – xa)",
            "xa– (fa– f(xa)) fa/ (xb – xa) ",
            "xb – (fb – xa) fb/ (xb – fb(xa)",
            "xa – (xb – xa) fa/ (fb – f(xa))"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> <a href=\"http://en.wikipedia.org/wiki/Secant_method\">ttp://en.wikipedia.org/wiki/Secant_method</a></div>",
        "keyword": "Divide and Conquer"
    },
    {
        "question": "Suppose you are provided with the following function declaration in the C programming language. \r\n   int partition (int a[], int n); \r\nThe function treats the first element of a[] as a pivot, and rearranges the array so that all elements less than or equal to the pivot is in the left part of the array, and all elements greater than the pivot is in the right part. In addition, it moves the pivot so that the pivot is the last element of the left part. The return value is the number of elements in the left part. The following partially given function in the C programming language is used to find the kth smallest element in an array a[ ] of size n using the partition function. We assume k ≤ n\r\n\r\n\r\nint kth_smallest (int a[], int n, int k)\r\n{\r\n   int left_end = partition (a, n);\r\n   if (left_end+1==k)\r\n   {\r\n       return a [left_end];\r\n   }\r\n   if (left_end+1 > k)\r\n   {\r\n      return kth_smallest (____________________);\r\n   }\r\n   else\r\n   {\r\n      return kth_smallest (____________________);\r\n    }\r\n}\r\n\r\n\r\nThe missing argument lists are respectively",
        "answer": [
            "(a, left_end, k) and (a+left_end+1, n–left_end–1, k–left_end–1)",
            "(a, left_end, k) and (a, n–left_end–1, k–left_end–1)",
            "(a, left_end+1, N–left_end–1, K–left_end–1) and(a, left_end, k)",
            "(a, n–left_end–1, k–left_end–1) and (a, left_end, k)"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> See method 4 of <a href=\"http://www.geeksforgeeks.org/kth-smallestlargest-element-unsorted-array/\">http://www.geeksforgeeks.org/kth-smallestlargest-element-unsorted-array/</a></div>",
        "keyword": "Divide and Conquer"
    },
    {
        "question": "Consider the problem of computing min-max in an unsorted array where min and max are minimum and maximum elements of array. Algorithm A1 can compute min-max in a1 comparisons without divide and conquer. Algorithm A2 can compute min-max in a2 comparisons by scanning the array linearly. What could be the relation between a1 and a2 considering the worst case scenarios?\r\n",
        "answer": [
            "a1 < a2\r\n",
            "a1 > a2",
            "a1 = a2\r\n",
            "Depends on the input\r\n"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\">  When Divide and Conquer is used to find the minimum-maximum element in an array, Recurrence relation for the number of comparisons is <br/>\r\nT(n) = 2T(n/2) + 2    where 2 is for comparing the minimums as well the maximums of the left and right subarrays \r\n\r\nOn solving, T(n) = 1.5n - 2. <br/>\r\nWhile doing linear scan, it would take 2*(n-1) comparisons in the worst case to find both minimum as well maximum in one pass.\r\n</div>",
        "keyword": "Divide and Conquer"
    },
    {
        "question": "Let G be the directed, weighted graph shown in below figure\r\n\r\n\r\n\r\nWe are interested in the shortest paths from A.\r\n\r\n(a) Output the sequence of vertices identified by the Dijkstra’s algorithm for single source shortest path when the algorithm is started at node A.\r\n(b) Write down sequence of vertices in the shortest path from A to E.\r\n(c) What is the cost of the shortest path from A to E?",
        "answer": "None",
        "correct": "None",
        "explain": "<div class=\"mtq_explanation-text\"> According to <a href=\"https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/\" rel=\"noopener\" target=\"_blank\">Dijkstra's algorithm</a>:\r\n(a) Sequence of vertices when algorithm start traversing from A: A -&gt; B -&gt; D -&gt; C -&gt; F -&gt; E\r\n(b) The sequence remain same as answer (a).\r\n(c) Cost of the shortest path from A to E is 84.</div>",
        "keyword": "Divide and Conquer"
    },
    {
        "question": "Let P be an array containing n integers. Let t be the lowest upper bound on the number of comparisons of the array elements, required to find the minimum and maximum values in an arbitrary array of n elements. Which one of the following choices is correct?",
        "answer": [
            "t>2n−2",
            "t>3⌈n/2⌉ and t≤2n−2",
            "t>n and t≤3⌈n/2⌉",
            "t>⌈log2(n)⌉ and t≤n"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> It will take t≤2n−2 comparisons without divide and conquer technique. \r\n\r\nIt will take t≤ 3⌈n/2⌉ - 2 <a href=\"https://www.geeksforgeeks.org/?p=4583\" rel=\"noopener\" target=\"_blank\">with divide and conquer technique</a>.</div>",
        "keyword": "Divide and Conquer"
    },
    {
        "question": "Consider the following array.\r\n\r\n\r\nWhich algorithm out of the following options uses the least number of comparisons (among the array elements) to sort the above array in ascending order?",
        "answer": [
            "Selection sort",
            "Mergesort",
            "Insertion sort",
            "Quicksort using the last element as pivot"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Since, given array is almost sorted in ascending order, so <a href=\"https://www.geeksforgeeks.org/insertion-sort/\" rel=\"noopener\" target=\"_blank\">Insertion sort</a> will give its best case with time complexity of order O(n).\r\n\r\n</div>",
        "keyword": "Divide and Conquer"
    },
    {
        "question": "A binary search tree T contains n distinct elements. What is the time complexity of picking an element in T that is smaller than the maximum element in T?",
        "answer": [
            "Θ(nlogn)",
            "Θ(n)",
            "Θ(logn)",
            "Θ(1)"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> Pick any two element from the root, and return minimum of these two. \r\n\r\nSo, time is Θ(1).</div>",
        "keyword": "Divide and Conquer"
    },
    {
        "question": "Which of the following standard algorithms is not a Greedy algorithm?",
        "answer": [
            "Dijkstra's shortest path algorithm",
            "Prim's algorithm",
            "Kruskal algorithm",
            "Huffman Coding",
            "Bellmen Ford Shortest path algorithm"
        ],
        "correct": "E",
        "explain": "<div class=\"mtq_explanation-text\"> See<a href=\"http://www.geeksforgeeks.org/greedy-algorithms-set-1-activity-selection-problem/\" target=\"_blank\"> http://www.geeksforgeeks.org/greedy-algorithms-set-1-activity-selection-problem/</a>  and <a href=\"http://www.geeksforgeeks.org/dynamic-programming-set-23-bellman-ford-algorithm/\" target=\"_blank\">http://www.geeksforgeeks.org/dynamic-programming-set-23-bellman-ford-algorithm/</a></div>",
        "keyword": "Greedy Algorithms"
    },
    {
        "question": "Suppose we run Dijkstra’s single source shortest-path algorithm on the following edge weighted directed graph with vertex P as the source. In what order do the nodes get included into the set of vertices for which the shortest path distances are finalized? (GATE CS 2004)\r\n\n",
        "answer": [
            "P, Q, R, S, T, U",
            "P, Q, R, U, S, T",
            "P, Q, R, U, T, S",
            "P, Q, T, R, U, S"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Refer <a href=\"http://www.geeksforgeeks.org/greedy-algorithms-set-6-dijkstras-shortest-path-algorithm/\">http://www.geeksforgeeks.org/greedy-algorithms-set-6-dijkstras-shortest-path-algorithm/</a></div>",
        "keyword": "Greedy Algorithms"
    },
    {
        "question": "A networking company uses a compression technique to encode the message before transmitting over the network. Suppose the message contains the following characters with their frequency:\r\n\r\n\r\ncharacter   Frequency\r\n    a\t        5\r\n    b           9\r\n    c           12\r\n    d           13\r\n    e           16\r\n    f           45\r\n\nNote : Each character in input message takes 1 byte.\r\n\r\nIf the compression technique used is Huffman Coding, how many bits will be saved in the message?",
        "answer": [
            "224",
            "800",
            "576",
            "324"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>\r\nTotal number of characters in the message = 100. \r\nEach character takes 1 byte. So total number of bits needed = 800.\r\n\r\nAfter <em>Huffman Coding</em>, the characters can be represented with:\r\nf: 0\r\nc: 100\r\nd: 101\r\na: 1100\r\nb: 1101\r\ne: 111\r\nTotal number of bits needed = 224\r\nHence, number of bits saved = 800 - 224 = 576\r\nSee <a href=\"http://www.geeksforgeeks.org/greedy-algorithms-set-3-huffman-coding/\" target=\"_blank\">here</a> for complete explanation and algorithm.\r\n</pre></div>",
        "keyword": "Greedy Algorithms"
    },
    {
        "question": "What is the time complexity of Huffman Coding?",
        "answer": [
            "O(N)",
            "O(NlogN)",
            "O(N(logN)^2)",
            "O(N^2)"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> O(nlogn) where n is the number of unique characters. If there are n nodes, extractMin() is called 2*(n – 1) times. extractMin() takes O(logn) time as it calles minHeapify(). So, overall complexity is O(nlogn).\r\nSee <a href=\"http://www.geeksforgeeks.org/greedy-algorithms-set-3-huffman-coding/\" target=\"_blank\">here</a> for more details of the algorithm.</div>",
        "keyword": "Greedy Algorithms"
    },
    {
        "question": "In question #2, which of the following represents the word \"dead\"?",
        "answer": [
            "1011111100101",
            "0100000011010",
            "Both A and B",
            "None of these"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> The <em>Huffman Tree</em> generated is:\r\n<img alt=\"Huffman Tree\" src=\"http://www.geeksforgeeks.org/wp-content/uploads/fig-6.jpg\"/>\n<pre>\r\ncharacter   code-word\r\n    f          0\r\n    c          100\r\n    d          101\r\n    a          1100\r\n    b          1101\r\n    e          111\r\n</pre>\r\nThe word <em>dead</em> can be represented as:\r\n101 111 1100 101\r\nHowever, the alternative codeword can also be found by assigning 1 to the left edge and 0 to the right edge of the tree, i.e. <em>dead</em> can also be represented as:\r\n010 000 0011 010\r\nSee <a href=\"http://www.geeksforgeeks.org/greedy-algorithms-set-3-huffman-coding/\">here </a>for more details of the algorithm.</div>",
        "keyword": "Greedy Algorithms"
    },
    {
        "question": "Which of the following is true about Kruskal and Prim MST algorithms?  Assume that Prim is implemented for adjacency list representation using Binary Heap and Kruskal is implemented using union by rank.",
        "answer": [
            "Worst case time complexity of both algorithms is same.",
            "Worst case time complexity of Kruskal is better than Prim",
            "Worst case time complexity of Prim is better than Kruskal"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> See following\r\n\r\n<a href=\"http://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/\" target=\"_blank\">Kruskal’s Minimum Spanning Tree Algorithm</a>\n<a href=\"http://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-mst-for-adjacency-list-representation/\" target=\"_blank\">Prim’s MST for Adjacency List Representation</a>\n</div>",
        "keyword": "Greedy Algorithms"
    },
    {
        "question": "Which of the following is true about Huffman Coding.",
        "answer": [
            "Huffman coding may become lossy in some cases",
            "Huffman Codes may not be optimal lossless codes in some cases",
            "In Huffman coding, no code is prefix of any other code.",
            "All of the above"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Huffman coding is a lossless data compression algorithm. The codes assigned to input characters are Prefix Codes, means the codes  are assigned in such a way that the code assigned to one character is not prefix of code assigned to any other character. This is how Huffman Coding makes sure that there is no ambiguity when decoding.</div>",
        "keyword": "Greedy Algorithms"
    },
    {
        "question": "Suppose the letters a, b, c, d, e, f have probabilities 1/2, 1/4, 1/8, 1/16, 1/32, 1/32 respectively. Which of the following is the Huffman code for the letter a, b, c, d, e, f?  ",
        "answer": [
            " 0, 10, 110, 1110, 11110, 11111 ",
            " 11, 10, 011, 010, 001, 000",
            "11, 10, 01, 001, 0001, 0000 ",
            "110, 100, 010, 000, 001, 111 "
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> We get the following Huffman Tree after applying <a href=\"http://www.geeksforgeeks.org/greedy-algorithms-set-3-huffman-coding/\" target=\"_blank\">Huffman Coding Algorithm</a>. The idea is to keep the least probable characters as low as possible by picking them first. \r\n\r\n<pre>\r\nThe letters a, b, c, d, e, f have probabilities \r\n1/2, 1/4, 1/8, 1/16, 1/32, 1/32 respectively. \r\n\r\n                 1\r\n               /   \\\r\n              /     \\\r\n             1/2    a(1/2)\r\n            /  \\\r\n           /    \\\r\n          1/4  b(1/4) \r\n         /   \\\r\n        /     \\\r\n       1/8   c(1/8) \r\n      /  \\\r\n     /    \\\r\n   1/16  d(1/16)\r\n  /  \\\r\n e    f</pre></div>",
        "keyword": "Greedy Algorithms"
    },
    {
        "question": "Suppose the letters a, b, c, d, e, f have probabilities 1/2, 1/4, 1/8, 1/16, 1/32, 1/32 respectively. What is the average length of Huffman codes?",
        "answer": [
            "3",
            "2.1875",
            "2.25",
            "1.9375"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> We get the following Huffman Tree after applying <a href=\"http://www.geeksforgeeks.org/greedy-algorithms-set-3-huffman-coding/\" target=\"_blank\">Huffman Coding Algorithm</a>. The idea is to keep the least probable characters as low as possible by picking them first. \r\n<pre>\r\nThe letters a, b, c, d, e, f have probabilities \r\n1/2, 1/4, 1/8, 1/16, 1/32, 1/32 respectively. \r\n\r\n                 1\r\n               /   \\\r\n              /     \\\r\n             1/2    a(1/2)\r\n            /  \\\r\n           /    \\\r\n          1/4  b(1/4) \r\n         /   \\\r\n        /     \\\r\n       1/8   c(1/8) \r\n      /  \\\r\n     /    \\\r\n   1/16  d(1/16)\r\n  /  \\\r\n e    f\r\nThe average length = (1*1/2 + 2*1/4 + 3*1/8 + 4*1/16 + 5*1/32 + 5*1/32)\r\n                   = 1.9375 \r\n</pre></div>",
        "keyword": "Greedy Algorithms"
    },
    {
        "question": "\nConsider the undirected graph below:  Using Prim's algorithm to construct a minimum spanning tree starting with node A, which one of the following sequences of edges represents a possible order in which the edges would be added to construct the minimum spanning tree?\n",
        "answer": [
            "\n(E, G), (C, F), (F, G), (A, D), (A, B), (A, C)\n",
            "\n(A, D), (A, B), (A, C), (C, F), (G, E), (F, G)\n",
            "\n(A, B), (A, D), (D, F), (F, G), (G, E), (F, C)\n",
            "\n(A, D), (A, B), (D, F), (F, C), (F, G), (G, E)\n"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\">\n<p>A<strong>. False </strong><br/>The idea behind Prim’s algorithm is to construct a spanning tree – <strong>means all vertices must be connected </strong>but here vertices are disconnected</p>\n<p>B. <strong>False </strong><br/>The idea behind Prim’s algorithm is to construct a spanning tree – <strong>means all vertices must be connected </strong>but here vertices are disconnected</p>\n<p>C.<strong> False. </strong><br/>Prim’s is a <strong>greedy algorithm</strong> and At every step, it considers all the edges that connect the two sets, and picks the minimum weight edge from these edges. In this option, since weight of AD&lt;AB, so AD must be picked up first (which is not true as per the options).</p>\n<p>D.<strong>TRUE.</strong></p>\n<p><strong>Therefore, Answer is D</strong></p>\n<p>Prim’s algorithm is also a <a href=\"https://www.geeksforgeeks.org/archives/18528\"><u>Greedy algorithm</u></a>. It starts with an empty spanning tree. The idea is to maintain two sets of vertices. The first set contains the vertices already included in the MST, the other set contains the vertices not yet included. At every step, it considers all the edges that connect the two sets, and picks the minimum weight edge from these edges. After picking the edge, it moves the other endpoint of the edge to the set containing MST.</p>\n<p>Read more at: <a href=\"https://www.geeksforgeeks.org/prims-minimum-spanning-tree-mst-greedy-algo-5/\">Prim’s Minimum Spanning Tree (MST)</a></p>\n</div>",
        "keyword": "Greedy Algorithms"
    },
    {
        "question": "Consider the weights and values of items listed below. Note that there is only one unit of each item.\r\n\n\n\r\nThe task is to pick a subset of these items such that their total weight is no more than 11 Kgs and their total value is maximized. Moreover, no item may be split. The total value of items picked by an optimal algorithm is denoted by Vopt. A greedy algorithm sorts the items by their value-to-weight ratios in descending order and packs them greedily, starting from the first item in the ordered list. The total value of items picked by the greedy algorithm is denoted by Vgreedy.\r\n\r\nThe value of Vopt − Vgreedy is ______ .\r\n\r\n\nNote -This was Numerical Type question.",
        "answer": [
            "16",
            "8",
            "44",
            "60"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> <img alt=\"gate_cs_2018_60\" class=\"aligncenter size-full wp-image-183112\" height=\"460\" src=\"https://www.geeksforgeeks.org/wp-content/uploads/gate_cs_2018_60.png\" width=\"499\"/>\r\nFirst we will pick item_4 (Value weight ratio is highest). Second highest is item_1, but cannot be picked because of its weight. Now item_3 shall be picked. item_2 cannot be included because of its weight. \r\nTherefore, overall profit by V<sub>greedy</sub> = 20+24 = 44\r\n\r\nHence, <b>V<sub>opt</sub> - V<sub>greedy</sub> = 60-44 = 16 </b>\r\n\r\nSo, answer is 16.\r\n\r\n</div>",
        "keyword": "Greedy Algorithms"
    },
    {
        "question": "A text is made up of the characters a, b, c, d, e each occurring with the probability 0.11, 0.40, 0.16, 0.09 and 0.24 respectively. The optimal Huffman coding technique will have the average length of:",
        "answer": [
            "2.40",
            "2.16",
            "2.26",
            "2.15"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> a = 0.11\r\nb = 0.40\r\nc = 0.16\r\nd = 0.09\r\ne = 0.24\r\nwe will draw a huffman tree:\r\n<img alt=\"huffman1\" class=\"alignnone size-medium wp-image-187908\" height=\"300\" src=\"https://www.geeksforgeeks.org/wp-content/uploads/huffman1-300x300.png\" width=\"300\"/>\r\n\r\nnow huffman coding for character:\r\n<pre> a = 1111\r\n      b = 0\r\n      c = 110\r\n      d = 1111\r\n      e = 10\r\nlenghth for each character = no of bits * frequency of occurence:\r\na = 4 * 0.11\r\n  = 0.44\r\nb = 1 * 0.4\r\n  =  0.4\r\nc = 3 * 0.16\r\n  = 0.48\r\nd = 4 * 0.09\r\n  =  0.36 \r\ne = 2 * 0.24\r\n  = 0.48\r\nNow add these lenght for average length:\r\n 0.44 + 0.4 + 0.48 + 0.36 + 0.48 = 2.16\r\n</pre>\r\nSo, option (B) is correct.\r\n \r\n\r\n</div>",
        "keyword": "Greedy Algorithms"
    },
    {
        "question": "Six files F1, F2, F3, F4, F5 and F6 have 100, 200, 50, 80, 120, 150 records respectively. In what order should they be stored so as to optimize act. Assume each file is accessed with the same frequency",
        "answer": [
            "F3, F4, F1, F5, F6, F2",
            "F2, F6, F5, F1, F4, F3",
            "F1, F2, F3, F4, F5, F6",
            "Ordering is immaterial as all files are accessed with the same frequency."
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>This question is based on the Optimal Storage on Tape problem\r\nwhich uses greedy approach to find the optimal time to retrieve them.\r\nThere are n programs of length L that are to be stored on a computer\r\ntape. Associated with each program i is a length Li. So in order to\r\nretrieve these programs most optimally, we need to store them in the\r\nnon-decreasing order of length Li.\r\nSo, the correct order is F3, F4, F1, F5, F6, F2</pre>\n</div>",
        "keyword": "Greedy Algorithms"
    },
    {
        "question": "Consider a job scheduling problem with 4 jobs J1, J2, J3, J4 and with corresponding deadlines: ( d1, d2, d3, d4) = (4, 2, 4, 2). Which of the following is not a feasible schedule without violating any job schedule?\r\n",
        "answer": [
            "J2, J4, J1, J3",
            "J4, J1, J2, J3",
            "J4, J2, J1, J3",
            "J4, J2, J3, J1"
        ],
        "correct": "B",
        "explain": "None",
        "keyword": "Greedy Algorithms"
    },
    {
        "question": "The number of permutations of the characters in LILAC so that no character appears in its original position, if the two L’s are indistinguishable, is ________ .\r\n\r\n\r\nNote - This question was Numerical Type.",
        "answer": [
            "12",
            "10",
            "8",
            "15"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> There are 3 choices for the first slot, and then 2 for the third slot. That leaves one letter out of I,A,C unchosen and there are 2 slots that one might occupy. After that, the L′s must go in the 2 unfilled slots.\r\n\r\nHence the answer is,\r\n<pre>3×2×1×2 = 12 </pre>\r\n\r\nOption (A) is correct.</div>",
        "keyword": "Greedy Algorithms"
    },
    {
        "question": "Consider a graph G=(V, E), where V = { v1,v2,…,v100 }, E={ (vi, vj) ∣ 1≤ii",
        "answer": "None",
        "correct": "None",
        "explain": "None",
        "keyword": "Greedy Algorithms"
    },
    {
        "question": "What is the other name of Dijkstra algorithm?",
        "answer": [
            "single-source shortest path problem",
            "multiple-source shortest path problem",
            "multiple-destination shortest path problem",
            "single-destination shortest path problem"
        ],
        "correct": "A",
        "explain": "None",
        "keyword": "Greedy Algorithms"
    },
    {
        "question": "Define Rn to be the maximum amount earned by cutting a rod of length n meters into one or more pieces of integer length and selling them. For i>0, let p[i] denote the selling price of a rod whose length is i meters. Consider the array of prices:\r\n\r\np[1]=1, p[2]=5, p[3]=8, p[4]=9, p[5]=10, p[6]=17, p[7]=18 \r\nWhich of the following statements is/are correct about R7?",
        "answer": [
            "R7=18",
            "R7=19",
            "R7 is achieved by three different solutions",
            "R7 cannot be achieved by a solution consisting of three pieces"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> According to given data,\r\n\r\n<figure class=\"table\"><table><tbody><tr><td>Number of pieces</td><td>Possible max profits with combination of rod size </td></tr><tr><td>7</td><td>7 (1, 1, 1, 1, 1, 1, 1)</td></tr><tr><td>6</td><td>10 (2, 1, 1, 1, 1, 1)</td></tr><tr><td>5</td><td>13 (2, 2, 1, 1, 1)</td></tr><tr><td>4</td><td>16 (2, 2, 2, 1)</td></tr><tr><td>3</td><td>18 (2, 2, 3)</td></tr><tr><td>2</td><td>18 (6, 1)</td></tr><tr><td>1</td><td>18 (7)</td></tr></tbody></table></figure>\r\n\r\nTherefore,\r\n\r\nOption (A) and (C) are correct.\r\n\r\nRefer - <a href=\"https://www.geeksforgeeks.org/cutting-a-rod-dp-13/\" rel=\"noopener\" target=\"_blank\">Cutting a Rod | DP-13</a>, and solution - <a href=\"https://ide.geeksforgeeks.org/lbBeyHa3xd\" rel=\"noopener\" target=\"_blank\">https://ide.geeksforgeeks.org/lbBeyHa3xd</a>\n</div>",
        "keyword": "Greedy Algorithms"
    },
    {
        "question": "Consider the string abbccddeee. Each letter in the string must be assigned a binary code satisfying the following properties:\r\n\nFor any two letters, the code assigned to one letter must not be a prefix of the code assigned to the other letter.\r\n\nFor any two letters of the same frequency, the letter which occurs earlier in the dictionary order is assigned a code whose length is at most the length of the code assigned to the other letter.\r\n\n\r\nAmong the set of all binary code assignments which satisfy the above two properties, what is the minimum length of the encoded string?",
        "answer": [
            "21",
            "23",
            "25",
            "30"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>Alphabet      Frequency\r\na                1\r\nb                2\r\nc                2\r\nd                2\r\ne                3</pre><img src=\"https://media.geeksforgeeks.org/wp-content/uploads/20210414170709/HuffmanTree.PNG\"/>\n<p>Required answer, </p>\n<pre>= 1×3 + 2×3 + 3×2 + 2×2 + 2×2 \r\n= 23 </pre>\n<p>Correct Option B</p></div>",
        "keyword": "Greedy Algorithms"
    },
    {
        "question": "Which of the following standard algorithms is not Dynamic Programming based.",
        "answer": [
            "Bellman–Ford Algorithm for single source shortest path",
            "Floyd Warshall Algorithm for all pairs shortest paths",
            "0-1 Knapsack problem",
            "Prim's Minimum Spanning Tree"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> <a href=\"http://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-minimum-spanning-tree-mst-2/\">Prim's Minimum Spanning Tree</a> is a Greedy Algorithm.  All other are dynamic programming based.</div>",
        "keyword": "Dynamic Programming"
    },
    {
        "question": "We use dynamic programming approach when",
        "answer": [
            "We need an optimal solution",
            "The solution has optimal substructure",
            "The given problem can be reduced to the 3-SAT problem",
            "It's faster than Greedy"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> <a href=\"http://www.geeksforgeeks.org/dynamic-programming-set-2-optimal-substructure-property/\">http://www.geeksforgeeks.org/dynamic-programming-set-2-optimal-substructure-property/</a>\r\n\r\nOption (D) is incorrect because Greedy algorithms are generally faster than Dynamic programming.  See <a href=\"http://www.geeksforgeeks.org/greedy-algorithms-set-1-activity-selection-problem/\">http://www.geeksforgeeks.org/greedy-algorithms-set-1-activity-selection-problem/</a></div>",
        "keyword": "Dynamic Programming"
    },
    {
        "question": "An algorithm to find the length of the longest monotonically increasing sequence of numbers in an array A[0 :n-1] is given below.\r\nLet Li denote the length of the longest monotonically increasing sequence starting at index i in the array.\r\n\n\n\r\nWhich of the following statements is TRUE?",
        "answer": [
            "The algorithm uses dynamic programming paradigm",
            "The algorithm has a linear complexity and uses branch and bound paradigm",
            "The algorithm has a non-linear polynomial complexity and uses branch and bound paradigm",
            "The algorithm uses divide and conquer paradigm."
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Please see <a href=\"http://www.geeksforgeeks.org/dynamic-programming-set-3-longest-increasing-subsequence/\" target=\"_blank\">http://www.geeksforgeeks.org/dynamic-programming-set-3-longest-increasing-subsequence/</a></div>",
        "keyword": "Dynamic Programming"
    },
    {
        "question": "Kadane algorithm is used to find:",
        "answer": [
            "Maximum sum subsequence in an array                                                                                ",
            "Maximum sum subarray in an array                                                                                ",
            "Maximum product subsequence in an array                                                                                ",
            "Maximum product subarray in an array                                                                                "
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Kadane algorithm is used to find the maximum sum subarray in an array. It runs in O(n) time complexity. See details of the algorithm <a href=\"http://www.geeksforgeeks.org/largest-sum-contiguous-subarray/\" target=\"_blank\">here</a>.</div>",
        "keyword": "Dynamic Programming"
    },
    {
        "question": "Four matrices M1, M2, M3 and M4 of dimensions pxq, qxr, rxs and sxt respectively can be multiplied is several ways with different number of total scalar multiplications. For example, when multiplied as ((M1 X M2) X (M3 X M4)), the total number of multiplications is pqr + rst + prt. When multiplied as (((M1 X M2) X M3) X M4), the total number of scalar multiplications is pqr + prs + pst.\r\n\r\nIf p = 10, q = 100, r = 20, s = 5 and t = 80, then the number of scalar multiplications needed is",
        "answer": [
            "248000",
            "44000",
            "19000",
            "25000"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> It is basically <a href=\"http://www.geeksforgeeks.org/dynamic-programming-set-8-matrix-chain-multiplication/\" target=\"_blank\">matrix chain multiplication </a>problem. We get minimum number of multiplications using ((M1 X (M2 X M3)) X M4).\r\n\r\nTotal number of multiplications = 100x20x5 (for M2 x M3) + 10x100x5 + 10x5x80 = 19000.</div>",
        "keyword": "Dynamic Programming"
    },
    {
        "question": "The subset-sum problem is defined as follows. Given a set of n positive integers, S = {a1 ,a2 ,a3 ,…,an} and positive integer W, is there a subset of S whose elements sum to W? A dynamic program for solving this problem uses a 2-dimensional Boolean array X, with n rows and W+1 columns. X[i, j],1 <= i <= n, 0 <= j <= W, is TRUE if and only if there is a subset of {a1 ,a2 ,...,ai} whose elements sum to j. Which of the following is valid for 2 <= i <= n and ai <= j <= W?",
        "answer": [
            "X[i, j] = X[i - 1, j] ∨ X[i, j -ai]",
            "X[i, j] = X[i - 1, j] ∨ X[i - 1, j - ai]",
            " X[i, j] = X[i - 1, j] ∧ X[i, j - ai]",
            "X[i, j] = X[i - 1, j] ∧ X[i -1, j - ai]"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> X[I, j] (2 &lt;= i &lt;= n and ai &lt;= j &lt;= W), is true if any of the following is true\r\n1) Sum of weights excluding ai is equal to j, i.e., if X[i-1, j] is true.\r\n2) Sum of weights including ai is equal to j, i.e., if X[i-1, j-ai] is true so that we get (j – ai) + ai as j\r\n\r\nSee <a href=\"http://www.geeksforgeeks.org/dynamic-programming-subset-sum-problem/\" target=\"_blank\">http://www.geeksforgeeks.org/dynamic-programming-subset-sum-problem/</a> for details.</div>",
        "keyword": "Dynamic Programming"
    },
    {
        "question": "In the above question, which entry of the array X, if TRUE, implies that there is a subset whose elements sum to W?",
        "answer": [
            " X[1, W]",
            "X[n ,0]",
            " X[n, W]",
            "X[n -1, n]"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> If we get the entry X[n, W] as true then there is a subset of {a1, a2, .. an} that has sum as W.\r\n\r\nReference: <a href=\"http://en.wikipedia.org/wiki/Subset_sum_problem\">http://en.wikipedia.org/wiki/Subset_sum_problem</a></div>",
        "keyword": "Dynamic Programming"
    },
    {
        "question": "A sub-sequence of a given sequence is just the given sequence with some elements (possibly none or all) left out. We are given two sequences X[m] and Y[n] of lengths m and n respectively, with indexes of X and Y starting from 0.\r\nWe wish to find the length of the longest common sub-sequence(LCS) of X[m] and Y[n] as l(m,n), where an incomplete recursive definition for the function l(i,j) to compute the length of The LCS of X[m] and Y[n] is given below: \r\nl(i,j) = 0, if either i=0 or j=0\r\n       = expr1, if i,j > 0 and X[i-1] = Y[j-1]\r\n       = expr2, if i,j > 0 and X[i-1] != Y[j-1] \n",
        "answer": [
            "expr1 ≡ l(i-1, j) + 1",
            "expr1 ≡ l(i, j-1)",
            "expr2 ≡ max(l(i-1, j), l(i, j-1))",
            "expr2 ≡ max(l(i-1,j-1),l(i,j))"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> In <a href=\"http://www.geeksforgeeks.org/dynamic-programming-set-4-longest-common-subsequence/\" target=\"_blank\">Longest common subsequence problem</a>, there are two cases for X[0..i] and Y[0..j]\r\n<pre>\r\n1) The last characters of two strings match. \r\n   The length of lcs is length of lcs of X[0..i-1] and Y[0..j-1]\r\n2) The last characters don't match.\r\n   The length of lcs is max of following two lcs values\r\n   a) LCS of X[0..i-1] and Y[0..j]\r\n   b) LCS of X[0..i] and Y[0..j-1]\r\n</pre></div>",
        "keyword": "Dynamic Programming"
    },
    {
        "question": "Consider two strings A = \"qpqrr\" and B = \"pqprqrp\". Let x be the length of the longest common subsequence (not necessarily contiguous) between A and B and let y be the number of such longest common subsequences between A and B. Then x + 10y = ___.",
        "answer": [
            "33",
            "23",
            "43",
            "34"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> //The LCS is of length 4. There are 3 LCS of length 4 \"qprr\", \"pqrr\" and qpqr\r\n\r\n \r\n\r\nA subsequence is a sequence that can be derived from another sequence by selecting zero or more elements from it, without changing the order of the remaining elements. Subsequence need not be contiguous. Since the length of given strings A = “qpqrr” and B = “pqprqrp” are very small, we don’t need to build a 5x7 matrix and solve it using dynamic programming. Rather we can solve it manually just by brute force. We will first check whether there exist a subsequence  of length 5 since min_length(A,B) = 5.\r\n\r\nSince there is no subsequence , we will now check for length 4. “qprr”, “pqrr” and “qpqr” are common in both strings.\r\n\r\nX = 4 and Y = 3\r\n\r\nX + 10Y = 34\r\n\r\n \r\n\r\nThis solution is contributed by <b class=\"gmail_sendername\">Pranjul Ahuja</b></div>",
        "keyword": "Dynamic Programming"
    },
    {
        "question": "Let A1, A2, A3, and A4 be  four  matrices  of  dimensions  10 x 5, 5 x 20, 20 x 10,  and  10 x 5,  respectively.   The  minimum  number  of  scalar  multiplications  required  to  find  the  product A1A2A3A4 using the basic matrix multiplication method is\r\n",
        "answer": [
            "1500",
            "2000",
            "500",
            "100"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> We have many ways to do matrix chain multiplication because matrix multiplication is associative. In other words, no matter how we parenthesize the product, the result of the matrix chain multiplication obtained will remain the same. Here we have four matrices A1, A2, A3, and A4, we would have:\r\n\r\n((A1A2)A3)A4 = ((A1(A2A3))A4) = (A1A2)(A3A4) = A1((A2A3)A4) = A1(A2(A3A4)).\r\n\r\nHowever, the order in which we parenthesize the product affects the number of simple arithmetic operations needed to compute the product, or the efficiency. Here, A1 is a 10 × 5 matrix, A2 is a 5 x 20 matrix, and A3 is a 20 x 10 matrix, and A4 is 10 x 5. \r\n\r\nIf we multiply two matrices A and B of order l x m and m x n respectively,then the number of scalar multiplications in the multiplication of A and B will be lxmxn. \r\n\r\nThen,\r\n\r\nThe number of scalar multiplications required in the following sequence of matrices will be :\r\n\r\nA1((A2A3)A4) = (5 x 20 x 10) + (5 x 10 x 5) + (10 x 5 x 5) = 1000 + 250 + 250 = 1500. \r\n\r\nAll other parenthesized options will require number of multiplications more than 1500.</div>",
        "keyword": "Dynamic Programming"
    },
    {
        "question": "Consider the weights and values of items listed below. Note that there is only one unit of each item.\r\n\n\n\r\nThe task is to pick a subset of these items such that their total weight is no more than 11 Kgs and their total value is maximized. Moreover, no item may be split. The total value of items picked by an optimal algorithm is denoted by Vopt. A greedy algorithm sorts the items by their value-to-weight ratios in descending order and packs them greedily, starting from the first item in the ordered list. The total value of items picked by the greedy algorithm is denoted by Vgreedy.\r\n\r\nThe value of Vopt − Vgreedy is ______ .\r\n\r\n\nNote -This was Numerical Type question.",
        "answer": [
            "16",
            "8",
            "44",
            "60"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> <img alt=\"gate_cs_2018_60\" class=\"aligncenter size-full wp-image-183112\" height=\"460\" src=\"https://www.geeksforgeeks.org/wp-content/uploads/gate_cs_2018_60.png\" width=\"499\"/>\r\nFirst we will pick item_4 (Value weight ratio is highest). Second highest is item_1, but cannot be picked because of its weight. Now item_3 shall be picked. item_2 cannot be included because of its weight. \r\nTherefore, overall profit by V<sub>greedy</sub> = 20+24 = 44\r\n\r\nHence, <b>V<sub>opt</sub> - V<sub>greedy</sub> = 60-44 = 16 </b>\r\n\r\nSo, answer is 16.\r\n\r\n</div>",
        "keyword": "Dynamic Programming"
    },
    {
        "question": "Consider the following two sequences :\r\nX = < B, C, D, C, A, B, C >, and \r\nY = < C, A, D, B, C, B > \r\nThe length of longest common subsequence of X and Y is :\r\n",
        "answer": [
            "5",
            "3",
            "4",
            "2"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Initially, We check for length 5 sub-sequence between both given sequences but couldn't find.\r\n\r\nThen checked for length 4 sub-sequences and CDBC and CDCB two sub-sequences found.</div>",
        "keyword": "Dynamic Programming"
    },
    {
        "question": "Consider a sequence F00 defined as :\r\n F00(0) = 1, F00(1) = 1\r\n F00(n) = 10 ∗ F00(n – 1) + 100\r\nF00(n – 2) for n ≥ 2\r\n Then what shall be the set of values of the sequence F00 ? ",
        "answer": [
            "(1, 110, 1200) ",
            "(1, 110, 600, 1200) ",
            "(1, 2, 55, 110, 600, 1200) ",
            "(1, 55, 110, 600, 1200) "
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> <pre> F<sub>00</sub>(0) = 1, F<sub>00</sub>(1) = 1\r\n F<sub>00</sub>(n) = 10 ∗ F<sub>00</sub>(n – 1) + 100\r\n F<sub>00</sub>(2) = 10 * F<sub>00</sub>(1) + 100\r\n = 10 * 1 + 100\r\n = 10 + 100\r\n = 110\r\nSimilarly:\r\nF<sub>00</sub>(3) = 10 * F<sub>00</sub>(2) + 100\r\n = 10 * 110 + 100\r\n = 1100 + 100\r\n = 1200\r\nThe sequence will be (1, 110, 1200).</pre>\r\nSo, (A) will be the answer.</div>",
        "keyword": "Dynamic Programming"
    },
    {
        "question": "The following paradigm can be used to find the solution of the problem in minimum time:\r\nGiven a set of non-negative integer, and a value K, determine if there is a subset of the given set with sum equal to K:\r\n",
        "answer": [
            "Divide and Conquer ",
            "Dynamic Programming",
            "Greedy Algorithm     ",
            "Branch and Bound"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Given  problem is Subset-sum problem in which a set of non-negative integers, and a value sum is given, to determine if there is a subset of the given set with sum equal to given sum. With recursion technique, time complexity of the above problem is exponential. We can solve the problem in Pseudo-polynomial time using Dynamic programming.\r\n\r\nRefer: <a href=\"https://www.geeksforgeeks.org/dynamic-programming-subset-sum-problem/\" rel=\"noopener\" target=\"_blank\">Subset Sum Problem</a>\r\n\r\nOption (B) is correct</div>",
        "keyword": "Dynamic Programming"
    },
    {
        "question": "What happens when a top-down approach of dynamic programming is applied to any problem?",
        "answer": [
            "It increases both, the time complexity and the space complexity",
            "It increases the space complexity and decreases the time complexity.",
            "It increases the time complexity and decreases the space complexity",
            "It decreases both, the time complexity and the space complexity"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> As the mentioned approach uses the memoization technique it always stores the previously calculated values. Due to this, the time complexity is decreased but the space complexity is increased.</div>",
        "keyword": "Dynamic Programming"
    },
    {
        "question": "Which of the following is not a backtracking algorithm?",
        "answer": [
            "Knight tour problem                                                                                                                                                                                                        ",
            "N queen problem                                                                                                                                                                                                        ",
            "Tower of hanoi                                                                                                                                                                                                        ",
            "M coloring problem                                                                                                                                                                                                        "
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> <a href=\"http://www.geeksforgeeks.org/backtracking-set-1-the-knights-tour-problem/\" target=\"_blank\">Knight tour problem</a>, <a href=\"http://www.geeksforgeeks.org/backtracking-set-3-n-queen-problem/\" target=\"_blank\">N Queen problem</a> and <a href=\"http://www.geeksforgeeks.org/backttracking-set-5-m-coloring-problem/\" target=\"_blank\">M coloring problem</a> involve backtracking. Tower of hanoi uses simple recursion.</div>",
        "keyword": "Backtracking"
    },
    {
        "question": "In a complete k-ary tree, every internal node has exactly k children. The number of leaves in such a tree with n internal nodes is: (GATE CS 2005)",
        "answer": [
            "nk",
            " (n – 1) k+ 1",
            " n( k – 1) + 1",
            " n( k – 1) "
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> For an k-ary tree where each node has k children or no children, following relation holds\r\nL = (k-1)*n + 1\r\n\r\nWhere L is the number of leaf nodes and n is the number of internal nodes.\r\n\r\nLet us see following for example <pre>\r\n             o\r\n        /    |    \\\r\n      o      o      o\r\n   / | \\          / | \\\r\n  o  o  o        o  o  o\r\n                  / | \\\r\n                 o  o  o\r\n\r\nk = 3\r\nNumber of internal nodes n = 4\r\nNumber of leaf nodes = (k-1)*n  + 1\r\n                     = (3-1)*4 + 1\r\n                     = 9 </pre></div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "Given 8 identical coins out of which one coin is heavy and a pan balance. How many minimum number of measurements are needed to find the heavy coin?",
        "answer": [
            "2",
            "3",
            "4",
            "7"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>\r\nDivide the coins into three groups and name the coins according to there group:\r\nA: A1, A2, A3\r\nB: B1, B2, B3\r\nC: C1, C2\r\n\r\nMeasure group A and group B. Two cases arise:\r\n1. They are equal. One more measurement is needed to find the heavy \r\n   coin in group C. Total two measurements needed in this case.\r\n2. They are not equal. Find the heavy group, say A. Pick any two coins\r\n   from this group,  say A1 and A3. Measure A1 and A3 in the pan balance. \r\n   Two cases arise:\r\n   2.1 They are equal. A2 is the heavy coin. Total two measurements \r\n       needed.\r\n   2.2 They are not equal. It is known which of A1 or A3 is heavy. \r\n       Total two measurements needed.\r\nSo, the above observations says that in any case, 2 measurements are enough\r\nto find the heavy coin.\r\n\r\n<em>Follow up:</em>\r\nGeneralize the minimum number of measurements for <strong>n</strong> coins \r\nwith one coin heavy.\r\n</pre>\n</div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "In a village, people build houses in the same side of the road. A thief plans to loot the village. He wants maximum amount of money without having any risk of getting caught. By some means, the villagers know that their adjacent house is being looted or not and thus they become alert. So the thief cannot loot contiguous two houses. Given that the thief knows the amount of money stored in each house and the road is straight and there is no turning, which is the most efficient algorithmic strategy to solve this problem?",
        "answer": [
            "Brute-force",
            "Dynamic Programming",
            "Backtracking",
            "Divide and Conquer"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>If we take a closer look, the problem boils down to:\r\nGiven an array with some finite size where each element represents \r\na positive number, find the maximum sum such that no two elements \r\nare adjacent.\r\nDynamic Programming is the efficient technique to solve this. \r\nThe algorithm can be given as follows:\r\nMaintain an auxiliary array loot.\r\n<strong>loot[0] = arr[0]\r\nloot[1] = arr[1]\r\nloot[i] = max(loot[i - 1], loot[i - 2] + arr[i])</strong>,  <strong>2 &lt;= i &lt; n</strong>\r\nloot[n - 1] gives the maximum amount of money the thief can take away.\r\n</pre>\n</div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "Which of the following is not an in-place algorithm?",
        "answer": [
            "Insertion sort",
            "Selection sort",
            "Merge sort",
            "Heap sort"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> An in-place algorithm is an algorithm which uses a constant amount of extra space apart from input.\r\nMerge sort uses an extra O(n) space in the merging part.</div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "A set X can be represented by an array x[n] as follows: \n\r\n\r\nConsider the following algorithm in which x,y and z are Boolean arrays of size n:\r\n\r\nalgorithm zzz(x[] , y[], z [])\r\n{\r\n   int i;\r\n   for (i=O; i<n; ++i)\r\n     z[i] = (x[i] ^ ~y[i]) V (~x[i] ^ y[i])\r\n}\r\n\r\nThe set Z computed by the algorithm is:",
        "answer": [
            " (X Intersection Y)",
            "(X Union Y)",
            "(X-Y) Intersection (Y-X)",
            "(X-Y) Union (Y-X)"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> The expression x[i] ^ ~y[i]) results the only 1s in x where corresponding entry in y is 0. An array with these set bits represents set X – Y\r\nThe expression ~x[i] ^ y[i]) results the only 1s in y where corresponding entry in x is 0. An array with these set bits represents set Y – X.\r\nThe operator “V” results in Union of the above two sets.</div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "The minimum number of comparisons required to determine if an integer appears more than n/2 times in a sorted array of n integers is",
        "answer": "None",
        "correct": "None",
        "explain": "None",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "An element in an array X is called a leader if it is greater than all elements to the right of it in X. The best algorithm to find all leaders in an array (GATE CS 2006)",
        "answer": "None",
        "correct": "None",
        "explain": "None",
        "keyword": "Algorithm Misc"
    },
    {
        "question": " Consider the following C function. \r\n\r\nfloat f(float x, int y) \r\n{ \r\n  float p, s; int i; \r\n  for (s=1, p=1, i=1; i < y; i ++) \r\n  { \r\n    p*= x/i; \r\n    s+=p; \r\n  } \r\n  return s; \r\n}   \r\n\r\n  \r\nFor large values of y, the return value of the function f best approximates (GATE CS 2003)",
        "answer": [
            "x^y ",
            "e^x ",
            "ln(1 + x) ",
            "x^x "
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> The function f() is implementation of Taylor's Series to calculates e^x \r\n<pre>\r\n   e^x = 1 + x + x^2/2! + x^3/3! + ---\r\n</pre>\r\nMore is the value of y more precise value of e^x will be returned by f() </div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "Suppose you are given an array s[1...n] and a procedure reverse (s,i,j) which reverses the order of elements in a between positions i and j (both inclusive). What does the following sequence \r\ndo, where 1 < k <= n:\r\n  reverse (s, 1, k);\r\n  reverse (s, k + 1, n);\r\n  reverse (s, 1, n);\r\n\r\n(GATE CS 2000)",
        "answer": [
            "Rotates s left by k positions",
            "Leaves s unchanged",
            "Reverses all elements of s",
            "None of the above"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Effect of the above 3 reversals for any k is equivalent to left rotation of the array of size n by k. Please see <a href=\"https://www.geeksforgeeks.org/program-for-array-rotation-continued-reversal-algorithm/\">this post</a> for details.\r\nIf we rotate an array n times for k = 1 to n, we get the same array back.</div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "An inversion in a an array A[] is a pair (A[i], A[j]) such that A[i] > A[j] and i < j. An array will have maximum number of inversions if it is:",
        "answer": [
            "Sorted in increasing order",
            "Sorted in decreasing order",
            "Sorted in alternate fashion",
            "Both A and B"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> If the array is sorted in decreasing order, each pair will be an inversion.\r\ne.g. 5, 4, 3, 2, 1\r\nMaximum number of inversions possible = n * (n - 1) / 2 where n is the size of the array.</div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "The procedure given below is required to find and replace certain characters inside an input character string supplied in array A. The characters to be replaced are supplied in array oldc, while their respective replacement characters are supplied in array newc. Array A has a fixed length of five characters, while arrays oldc and newc contain three characters each. However, the procedure is flawed\r\nvoid find_and_replace(char *A, char *oldc, char *newc) {\r\n    for (int i = 0; i < 5; i++)\r\n       for (int j = 0; j < 3; j++)\r\n           if (A[i] == oldc[j]) A[i] = newc[j];\r\n} The procedure is tested with the following four test cases\r\n(1) oldc = \"abc\", newc = \"dab\"\r\n(2) oldc = \"cde\", newc =  \"bcd\"\r\n(3) oldc  = \"bca\", newc  = \"cda\"\r\n(4) oldc = \"abc\", newc = \"bac\"\r\nThe tester now tests the program on all input strings of length five consisting of characters ‘a’, ‘b’, ‘c’, ‘d’ and ‘e’ with duplicates allowed. If the tester carries out this testing with the four test cases given above, how many test cases will be able to capture the flaw? \r\n",
        "answer": [
            "Only one ",
            "Only two ",
            "Only three ",
            " All four"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> The test cases 3 and 4 are the only cases that capture the flaw. The code doesn't work properly when an old character is replaced by a new character and the new character is again replaced by another new character.  This doesn't happen in test cases (1) and (2), it happens only in cases (3) and (4).</div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "In the above question, if array A is made to hold the string “abcde”, which of the above four test cases will be successful in exposing the flaw in this procedure? ",
        "answer": [
            "None ",
            " 2 only ",
            "3 and 4 only ",
            " 4 only"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> [sourcecode language=\"C\"]\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\nvoid find_and_replace(char *A, char *oldc, char *newc) {\r\n    for (int i = 0; i &lt; 5; i++)\r\n       for (int j = 0; j &lt; 3; j++)\r\n           if (A[i] == oldc[j]) A[i] = newc[j];\r\n}\r\n\r\nint main()\r\n{\r\n    char *oldc1 = \"abc\", *newc1 = \"dab\";\r\n    char *oldc2 = \"cde\", *newc2 = \"bcd\";\r\n    char *oldc3 = \"bca\", *newc3 = \"cda\";\r\n    char *oldc4 = \"abc\", *newc4 = \"bac\";\r\n\r\n    char test[] =  \"abcde\";\r\n\r\n    printf(\"Test 2\\n\");\r\n    printf(\"%s\\n\", test);\r\n    find_and_replace(test, oldc2, newc2);\r\n    printf (\"%s\\n\", test);\r\n\r\n    printf(\"\\nTest 3\\n\");\r\n    strcpy(test, \"abcde\");\r\n    printf(\"%s\\n\", test);\r\n    find_and_replace(test, oldc3, newc3);\r\n    printf (\"%s\\n\", test);\r\n\r\n    printf(\"\\nTest 4\\n\");\r\n    strcpy(test, \"abcde\");\r\n    printf(\"%s\\n\", test);\r\n    find_and_replace(test, oldc4, newc4);\r\n    printf (\"%s\\n\", test);\r\n}\r\n[/sourcecode]\r\nOutput:<pre>Test 2\r\nabcde\r\nabbcd\r\n\r\nTest 3\r\nabcde\r\naddde\r\n\r\nTest 4\r\nabcde\r\naacde</pre>\n</string.h></stdio.h></div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "There are 25 horses among which you need to find out the fastest 3 horses. You can conduct race among at most 5 to find out their relative speed. At no point you can find out the actual speed of the horse in a race. Find out how many races are required to get the top 3 horses.",
        "answer": [
            "5",
            "7",
            "8",
            "9"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Divide the horses in 5 groups and run 5 races.  Take toppers of 5 races and run 6th race more race, the topper of this race will be the fastest horse among all 25.  Now run the 7th race among following horses.\r\n1)  Second and third fastest horses of 6th race\r\n1)  Take the second and third fastest horses of the group which belong to the topper of 6th race.\r\n2)  Take the second fastest horse of the group which belongs to second fastest horse of 6th race. \r\n\r\nThe fastest and second fastest of 7th race are the 2nd and 3rd fastest among all 25.</div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "Which of the following is the best possible time complexity to get Nth Fibonacci number with O(1) extra space",
        "answer": [
            "Time complexity T(n) is T(n-1) + T(n-2) which is exponential",
            "O(n)",
            "O(Logn)",
            "O(n^2)"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> The best possible time complexity is O(Logn).  See <a href=\"http://www.geeksforgeeks.org/program-for-nth-fibonacci-number/\" target=\"_blank\">Program for nth Fibonacci number</a>\n</div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "You are given an array with even integer elements. You and some other player take turns to pick numbers. Each player can pick either the leftmost element or the rightmost number. Find the maximum possible score (sum of numbers chosen) by you.\r\nFor example: if array is 5 8 4 2, then player you can choose either 5 or 2. Suppose you choose 2, then the other player can choose 5 or 4. Irrespective of what player 2 chooses, in next round you will have chance to choose 8. Thus, maximum possible score by player you, in this scenario, is (8+2)=10.\r\nThis problem can efficiently solved using?",
        "answer": [
            "Greedy Algorithm",
            "Dynamic Programming",
            "Backtracking",
            "Recursion."
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> See <a href=\"http://www.geeksforgeeks.org/dynamic-programming-set-31-optimal-strategy-for-a-game/\" target=\"_blank\">Optimal Strategy for a Game</a>\n</div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "What is the return value of following function for 484?  What does it to in general?\r\n\r\n\r\nbool fun(int n)\r\n{\r\n    int sum = 0;\r\n    for (int odd = 1; n > sum; odd = odd+2)\r\n       sum = sum + odd;\r\n    return (n == sum);\r\n}",
        "answer": [
            "False, it checks whether a given number is power of 3",
            "False, it checks whether a given number is even or not",
            "False, it checks whether a given number is odd or not",
            "True, it checks whether a given number is perfect square."
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> The given function adds all odd numbers 1, 3, 5, 7, 9, 11.... till the sum is smaller than n.  If the sum becomes equal to n, then it returns true.  This is basically a test for perfect square numbers.\r\n\r\nAll perfect square numbers can be written as sum of odd numbers.\r\n\r\n4 = 1 + 3\r\n9 = 1 + 3 + 5\r\n16 = 1 + 3 + 5 + 7\r\n36 = 1 + 3 + 5 + 7 + 9\r\n49 = 1 + 3 + 5 + 7 + 9 + 11</div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "Consider the following C function in which size is the number of elements in the array E:\r\n\r\nThe value returned by the function MyX is the\r\n\r\nint MyX(int *E, unsigned int size)\r\n{\r\n    int Y = 0;\r\n    int Z;\r\n    int i, j, k;\r\n    for(i = 0; i < size; i++)\r\n        Y = Y + E[i];\r\n    for(i = 0; i < size; i++)\r\n        for(j = i; j < size; j++)\r\n        {\r\n            Z = 0;\r\n            for(k = i; k <= j; k++)\r\n                Z = Z + E[k];\r\n            if (Z > Y)\r\n                Y = Z;\r\n        }\r\n    return Y;\r\n}\r\n",
        "answer": [
            "maximum possible sum of elements in any sub-array of array E.",
            "maximum element in any sub-array of array E.",
            "sum of the maximum elements in all possible sub-arrays of array E",
            " the sum of all the elements in the array E."
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> <b>Explanation: </b>The function does following\r\nY is used to store maximum sum seen so far and Z is used to store current sum\r\n1) Initialize Y as sum of all elements\r\n2) For every element, calculate sum of all subarrays starting with arr[i]. Store the current sum in Z. If Z is greater than Y, then update Y.</div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "Consider the expression tree shown. Each leaf represents a numerical value, which can either be 0 or 1. Over all possible choices of the values at the leaves, the maximum possible value of the expression represented by the tree is ___.\r\n\r\n",
        "answer": [
            "4",
            "6",
            "8",
            "10"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> An <a href=\"http://www.geeksforgeeks.org/expression-tree/\">Expression Tree</a> is a binary tree in which each internal node corresponds to operator and each leaf node corresponds to operand so for example expression tree for 3 + ((5+9)*2) would be:.\r\n\r\nBelow diagram shows values to pick to get the maximum value in expresison tree\r\n\r\n<a href=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2015/11/GATECS2014Q38.png\"><img alt=\"GATECS2014Q38\" class=\"alignnone size-large wp-image-20797\" height=\"370\" src=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2015/11/GATECS2014Q38-1024x500.png\" width=\"600\"/></a>\n<iframe allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen=\"\" frameborder=\"0\" height=\"315\" src=\"https://www.youtube.com/embed/Sn5eIxvrNBc?start=1982\" title=\"YouTube video player\" width=\"560\"></iframe></div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "The minimum number of arithmetic operations required to evaluate the polynomial P(X) = X5 + 4X3 + 6X + 5 for a given value of X using only one temporary variable.",
        "answer": [
            "6",
            "7",
            "8",
            "9"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>P(X) = x<sup>5</sup> + 4x<sup>3</sup> + 6x + 5\r\n\r\n     =x ( x<sup>4</sup> + 4x<sup>2</sup> + 6 ) +5\r\n\r\n     =x ( x ( x<sup>3</sup> + 4x ) + 6 ) + 5\r\n\r\n     =x ( x ( x ( x<sup>2</sup> + 4 ) ) + 6 ) + 5\r\n\r\n     =x ( x ( x (x (x) + 4 ) ) + 6 ) + 5\r\n\r\nLet T be a temporary variable to store intermediate results.\r\n\r\n1. T = (x) * (x)\r\n2. T = T + 4\r\n3. T = (x) * (T)\r\n4. T = (x) * (T)\r\n5. T = T + 6\r\n6. T = (x) * T\r\n7. T = T + 5\r\n\r\nThus, we need 7 operations if we are to use only one temporary variable.</pre>\r\nPlease comment below if you find anything wrong in the above post.</div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "Suppose there are  ⌈ log n ⌉ sorted lists of ⌊ n/log n ⌋ elements each. The time complexity of producing a sorted list of all these elements is :\r\n(Hint : Use a heap data structure)",
        "answer": [
            "O(n log log n)",
            "θ(n log n)",
            "Ω(n log n)",
            "Ω(n3/2)"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> <a href=\"http://www.geeksforgeeks.org/merge-k-sorted-arrays/\" target=\"_blank\">We can merge x arrays of each size y in in O(xy*Logy) time using Min Heap.</a>\r\n\r\nx = Logn\r\ny = n/Logn\r\n\r\nWe get O(n/Logn * Logn * Log Log n) which is O(nLogLogn)</div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "We are given 9 tasks T1, T2.... T9. The execution of each task requires one unit of time. We can execute one task at a time. Each task Ti has a profit Pi and a deadline di Profit Pi is earned if the task is completed before the end of the dith unit of time. \r\nTask     T1  T2\t T3  T4  T5  T6\t T7 T8  T9\r\nProfit   15  20\t 30  18  18  10\t 23 16  25\r\nDeadline 7   2 \t 5   3 \t 4   5 \t 2  7   3 \r\nAre all tasks completed in the schedule that gives maximum profit?\t",
        "answer": [
            "All tasks are completed",
            "T1 and T6 are left out",
            "T1 and T8 are left out",
            "T4 and T6 are left out"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>\r\nTask     T1  T2\t T3  T4  T5  T6\t T7 T8  T9\r\nProfit   15  20\t 30  18  18  10\t 23 16  25\r\nDeadline 7   2 \t 5   3 \t 4   5 \t 2  7   3 </pre>\r\n\r\nTo maximize profit, we can finish tasks in following order T7, T2, T9, T5, T3, T8, T1</div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "We are given 9 tasks T1, T2.... T9. The execution of each task requires one unit of time. We can execute one task at a time. Each task Ti has a profit Pi and a deadline di Profit Pi is earned if the task is completed before the end of the dith unit of time. \r\nTask     T1  T2\t T3  T4  T5  T6\t T7 T8  T9\r\nProfit   15  20\t 30  18  18  10\t 23 16  25\r\nDeadline 7   2 \t 5   3 \t 4   5 \t 2  7   3 \r\n\r\nWhat is the maximum profit earned?",
        "answer": [
            "147",
            "165",
            "167",
            "175"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>Task     T1  T2\t T3  T4  T5  T6\t T7 T8  T9\r\nProfit   15  20\t 30  18  18  10\t 23 16  25\r\nDeadline 7   2 \t 5   3 \t 4   5 \t 2  7   3 </pre>\r\n\r\nTo maximize profit, we can finish tasks in following order T7, T2, T9, T5, T3, T8, T1. \r\n\r\nWe get the maximum profit as 23 + 20 + 25 + 18 + 30 + 16 + 15 = 147</div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "Consider the following program fragment for reversing the digits in a given integer to obtain a new integer. Let n = D1D2…Dm\r\n\r\nint n, rev;\r\nrev = 0;\r\nwhile (n > 0)\r\n{\r\n   rev = rev*10 + n%10;\r\n   n = n/10;\r\n}\r\n\r\n\r\nThe loop invariant condition at the end of the ith iteration is:",
        "answer": [
            "n = D1D2….Dm-i and rev = DmDm-1…Dm-i+1",
            "n = Dm-i+1…Dm-1Dm and rev = Dm-1….D2D1",
            " n != rev",
            "n = D1D2….Dm and rev = DmDm-1…D2D1"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> The loop one by adds digits to rev starting from the last digit of n.  It also removes digits from n starting from left.</div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "Consider the following C program\r\n\r\nmain()\r\n{\r\n    int x, y, m, n;\r\n    scanf (\"%d %d\", &x, &y);\r\n    /* Assume x > 0 and y > 0  */\r\n    m = x;\r\n    n = y;\r\n    while (m! = n)\r\n    {\r\n        if (m > n)\r\n            m = m - n;\r\n        else\r\n            n = n - m;\r\n    }\r\n    print f (\"% d\", n);\r\n}\r\n\r\nThe program computes\t\t \r\n\r\n",
        "answer": [
            "x ÷ y using repeated subtraction",
            "x mod y using repeated subtraction",
            "the greatest common divisor of x and y",
            "the least common multiple of x and y"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> The given program is iterative implementation of <a href=\"http://geeksquiz.com/c-program-find-gcd-hcf-two-numbers/\" target=\"_blank\">Euclid's Algorithm for GCD</a></div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "What does the following algorithm approximate?\r\n\r\n    x = m;\r\n    y = 1;\r\n    while (x - y > e)\r\n    {\r\n        x = (x + y)/2;\r\n        y = m/x;\r\n    }\r\n    print(x);\r\n\r\n(Assume m > 1, e > 0).\r\n",
        "answer": [
            "log m",
            "m2",
            "m1/2",
            "m1/3"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> The given code is implementation of <a href=\"http://www.geeksforgeeks.org/square-root-of-a-perfect-square/\" target=\"_blank\">Babylonian method for square root</a></div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "In a permutation a1.....an of n distinct integers, an inversion is a pair (ai, aj) such that i < j and ai > aj. If all permutations are equally likely, what is the expected number of inversions in a randomly chosen permutation of 1.....n ?",
        "answer": [
            "n(n - 1)/2\r\n",
            "n(n - 1)/4",
            "n(n + 1)/4",
            "2n[log2 n]"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>\r\nThere are n(n-1)/2 pairs such that i &lt; j.\r\n\r\nFor a pair (ai, aj), probability of being inversion is 1/2.\r\n\r\nTherefore expected value of inversions = 1/2 * (n(n-1)/2)\r\n                                       = n(n-1)/4</pre></div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "The cube root of a natural number n is defined as the largest natural number m such that m3 ≤ n. The complexity of computing the cube root of n (n is represented in binary notation) is:",
        "answer": [
            "O(n) but not O(n0.5)",
            "O(n0.5) but not O((log n)k) for any constant k > 0",
            "O((log n)k) for some constant k > 0, but not O ((log log n)m) for any constant m > 0",
            "O((log log n)m) for some constant k > 0.5, but not O((log log n)0.5)"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Refer <a href=\"http://stackoverflow.com/questions/20767702/complexity-to-find-cube-root-of-n\" target=\"_blank\">http://stackoverflow.com/questions/20767702/complexity-to-find-cube-root-of-n</a></div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "The following are the starting and ending times of activities A, B, C, D, E, F, G and H respectively in chronological order: \"asbscsaedsceesfsbedegseefehsgehe\"\r\n\r\nHere, xs denotes the starting time and xe  denotes the ending time of activity X. W need to schedule the activities in a set of rooms available to us. An activity can be scheduled in a room only if the room is reserved for the activity for its entire duration. What is the minimum number of rooms required ?",
        "answer": [
            "3",
            "4",
            "5",
            "6"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Room1 - As\r\nRoom2 - Bs\r\nRoom3 - As\r\nnow A ends (Ae) and now Room3 is free\r\nRoom3-Ds\r\nnow A ends (Ae) and Room1 is free\r\nRoom1-Es\r\nRoom4-Fs\r\nnow B ends Room2 is free\r\nnow D ends Room3 is free\r\nRoom2-Gs\r\nnow E ends Room1 free\r\nnow F ends Room4 free\r\nRoom1-Hs\r\nnow G and H ends.\r\nTotally used 4 rooms\r\n\r\nSource: https://www.gatementor.com/viewtopic.php?f=267&amp;t=2195</div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "In the following C program fragment, j, k n and TwoLog_n are integer variables, and A is an array of integers. The variable n is initialized to an integer ≥ 3, and TwoLog_n is initialized to the value of 2*⌈log2(n)⌉\r\n\r\n\r\nfor (k = 3; k < = n; k++)\r\n    A[k] = 0;\r\nfor (k = 2; k < = TwoLog_n; k++)\r\n    for (j = k + 1; j < = n; j++)\r\n        A[j] = A[j] || (j % k);\r\nfor (j = 3; j < = n; j++)\r\n    if (!A[j]) printf(\"%d\", j);\r\n\r\n\r\nThe set of numbers printed by this program fragment is",
        "answer": [
            "{m | m ≤ n, (∃ i) [m = i!]} Here i! mean factorial of i",
            "{m | m ≤ n, (∃ i) [m = i2]}",
            "{m | m ≤ n, m is prime}",
            "{}"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> Option (D) is correct because if take n=4 then TwoLog_n value 4.\r\nfirst loop initially A[3]=A[4]=0;\r\nthen two loop  k = 2 to 4 and j = 3 to 4\r\n<pre>\r\nif k=2 \r\n         j=3  A[3] = A[3] || (3%2) \r\n                          = 0 || 1\r\n                  A[3] = 1 \r\n       j=4  A[4] = A[4] || (4%2)\r\n                         = 0 || 0\r\n                A[4] = 0\r\nK=3\r\n         j=4  A[4] = A[4] || (4%3)\r\n\r\n                        = 0 || 1\r\n               A[4] = 1\r\nK=4\r\n     J=5 condition false means terminate\r\n A[3] = A[4] = 1\r\n</pre>\r\nMeans last print loop never execute.\r\n</div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "An n x n array v is defined as follows: \r\nv[i, j] = i-j for all i, j, 1 <= i <= n, 1 <= j <= n\r\nThe sum of the elements of the array v is",
        "answer": [
            "0",
            "n-1",
            "n2 - 3n + 2",
            "n2 (n+1)/2"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> In this case, the matrix would be <pre>\r\n0    -1    -2    -3    -4    -5    -6    -7    ...    -n\r\n1     0    -1    -2    -3    -4    -5    -6    ...  -(n-1)\r\n2     1     0    -1    -2    -3    -4    -5    ...  -(n-2)\r\n3     2     1     0    -1    -2    -3    -4    ...  -(n-3)\r\n4     3     2     1     0    -1    -2    -3    ...  -(n-4)\r\n5     4     3     2     1     0    -1    -2    ...  -(n-5)\r\n6     5     4     3     2     1     0    -1    ...  -(n-6)\r\n7     6     5     4     3     2     1     0    ...  -(n-6)\r\n.     .     .     .     .     .     .     .     .   .   .\r\n.     .     .     .     .     .     .     .     .   .   .\r\n.     .     .     .     .     .     .     .     .   .   .\r\nn    n-1   n-2   n-3   n-4   n-5   n-6    n-7  ...  2   1</pre>\r\n\r\nNow, we take the sum of first row and first column, which comes out to be zero. Similarly, we take the sum of second row and second column, third row and third column, and so on, and it is found that all have a sum equal to zero.\r\nSo, the sum of all the elements in the matrix is zero.\r\n<br/> \r\nThus, A is the correct choice.\r\n<br/> <br/>\r\nPlease comment below if you find anything wrong in the above post.</div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "X, Y and Z are closed intervals of unit length on the real line. The overlap of X and Y is half a unit. The overlap of Y and Z is also half a unit. Let the overlap of X and Z be k units. Which of the following is true?",
        "answer": [
            "k must be 1 ",
            "k must be 0",
            " k can take any value between 0 and 1 (d) None\r\nof the above ",
            "None of the above"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\">  \r\n\r\n<a href=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/12/anil.png\"><img alt=\"anil\" class=\"alignnone size-full wp-image-28877\" height=\"928\" src=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/12/anil.png\" width=\"654\"/></a>\r\n\r\n \r\n\r\nThis solution is contributed by <span class=\"im\"><b class=\"gmail_sendername\">Anil Saikrishna Devarasetty</b></span>.</div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "Suppose you are given an array s[1..n] and a procedure reverse (s, i, j) which reverses the order of elements in a between positions i and j (both inclusive). What does the following sequence do, where 1 <= k <= n:\r\n\r\nreverse(s, 1, k) ;\r\nreverse(s, k + 1, n);\r\nreverse(s, l, n); ",
        "answer": [
            "Rotates s left by k positions",
            " Leaves s unchanged\r\n",
            "Reverses all elements of s ",
            "None of the above "
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Effect of the above 3 reversals for any k is equivalent to left rotation of the array of size n by k. Please see <a href=\"https://www.geeksforgeeks.org/program-for-array-rotation-continued-reversal-algorithm/\">this post</a> for details.\r\nIf we rotate an array n times for k = 1 to n, we get the same array back.</div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "Given an array that represents elements of arithmetic progression in order. It is also given that one element is missing in the progression, the worst case time complexity to find the missing element efficiently is:",
        "answer": [
            "Θ(n)",
            "Θ(nLogn)",
            "Θ(Logn)",
            "Θ(1)"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> We can use Binary Search to find the missing element.  See following link for details.\r\n<a href=\"http://www.geeksforgeeks.org/find-missing-number-arithmetic-progression/\">\r\nhttp://www.geeksforgeeks.org/find-missing-number-arithmetic-progression/</a></div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "Let swap() be a function that swaps two elements using their addresses.  Consider the following C function. \r\n\r\n\r\nvoid fun(int arr[], int n)\r\n{\r\n    for (int i = 0; i < n; i+=2)\r\n    {\r\n        if (i>0 && arr[i-1] > arr[i] )\r\n            swap(&arr[i], &arr[i-1]); \r\n        if (i<n-1 && arr[i] < arr[i+1] )\r\n            swap(&arr[i], &arr[i + 1]);\r\n    }\r\n}\r\n\r\n\r\nIf an array {10, 20, 30, 40, 50, 60, 70, 80} is passed to the function, the array is changed to",
        "answer": [
            "{20, 10, 40, 30, 60, 50, 80, 70}\r\n\r\n",
            "{10,  30,  20, 40,  60,  50,  80, 70} ",
            "{10, 20, 30, 40, 50, 60, 70, 80} ",
            "{80, 70, 60, 50, 40, 30, 20, 10}"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> The function sorts the array in waveform.  See <a href=\"http://www.geeksforgeeks.org/sort-array-wave-form-2/\">Sort an array in wave form</a> for more details.</div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "Match the following \r\nList-I\r\nA. Prim’s algorithm for minimum spanning tree\r\nB. Floyd-Warshall algorithm for all pairs shortest paths\r\nC. Mergesort\r\nD. Hamiltonian circuit\r\nList-II\r\n1. Backtracking\r\n2. Greed method\r\n3. Dynamic programming\r\n4. Divide and conquer\r\nCodes:\r\n    A B C D\r\n(a) 3 2 4 1\r\n(b) 1 2 4 3\r\n(c) 2 3 4 1\r\n(d) 2 1 3 4 ",
        "answer": [
            "a",
            "b",
            "c",
            "d"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> <a href=\"http://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-minimum-spanning-tree-mst-2/\">Prim's Algorithm</a> is a greedy algorithm where greedy choice is to pick minimum weight edge from cut that divides already picked vertices and vertices yet to be picked. \r\n\r\n\r\n<a href=\"http://www.geeksforgeeks.org/dynamic-programming-set-16-floyd-warshall-algorithm/\">Floyd-Warshall algorithm for all pairs shortest paths</a> is a Dynamic Programming algorithm where we keep updating the distance matrix in bottom up manner. \r\n\r\n<a href=\"http://geeksquiz.com/merge-sort/\">\r\nMerge Sort </a>is clearly divide and conquer which follows all steps of divide and conquer. It first divides the array in two halves, then conquer the two halves and finally combines the conquered results.\r\n\r\n\r\n<a href=\"http://www.geeksforgeeks.org/backtracking-set-7-hamiltonian-cycle/\">Hamiltonian circuit is a NP complete problem, that can be solved using Backtracking</a>\n</div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "Consider the following pseudo code, where x and y are positive integers. \r\nbegin\r\n   q := 0\r\n   r := x\r\nwhile r >= y do\r\n   begin\r\n      r := r – y\r\n      q := q + 1\r\n   end\r\nend \r\nThe post condition that needs to be satisfied after the program terminates is",
        "answer": [
            "{r = qx + y ∧ r < y}",
            "{x = qy + r ∧ r < y}",
            "{y = qx +  r ∧ 0 < r < y}",
            "{ q + 1 < r–y ∧ y > 0}"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> The given pseudo code does following for given x and y which positive integers.\r\n<pre>1) It initializes r as x.\r\n2) It repeatedly subtracts y from r until r becomes\r\n   smaller than y.  For every subtraction, it \r\n   increments count q.\r\n3) Finally r contains remainder, i.e., x%y and q contains\r\n   ⌊x/y⌋</pre>\r\nSee below pseudo code with comments.\r\n<pre>begin\r\n   q := 0  // q is going to contain floor(x/y)\r\n   r := x  // r is going to contain x % y\r\n\r\n// Repeatedly subtract y from x.\r\nwhile r &gt;= y do\r\n   begin\r\n      r := r – y\r\n      q := q + 1\r\n   end\r\nend</pre></div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "Let an represent the number of bit strings of length n containing two consecutive 1s. What is the recurrence relation for an?",
        "answer": [
            "an–2 + an–1 + 2n–2 ",
            "an–2 + 2an–1 + 2n–2",
            "2an–2 + an–1 + 2n–2 ",
            " 2an–2 + 2an–1 + 2n–2"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> <strong>Simple Solution</strong>\r\nOne way to solve this is to try for small values and rule out options.\r\n<pre>a<sub>0</sub> = 0  \r\na<sub>1</sub> = 0  \r\na<sub>2</sub> = 1  [\"11\"]\r\na<sub>3</sub> = 3  [\"011\", \"110\", \"111\"] \r\na<sub>4</sub> = 8  [\"0011\", \"0110\", \"0111\", \"1101\",\r\n                    \"1011\", \"1100\", \"1110\", \"1111\"]\r\n</pre>\r\nIf we check for a<sub>3</sub>, we can see that only A and C satisfy the value. Among (A) and (C), only (A) satisfies for a<sub>4</sub>.\r\n\r\n<strong>Another Solution (With Proof)</strong>\n<pre>\r\nA string of length n (n &gt;= 2) can be formed by \r\nfollowing 4 prefixes\r\n\r\n1) <strong>11 </strong>followed by a string of length n-2\r\n2) <strong>00 </strong>followed by a string of length n-2\r\n3) <strong>01 </strong>followed by a string of length n-2\r\n4) <strong>10 </strong>followed by a string of length n-2\r\n\r\nNumber 1 has already two consecutive 1's so number \r\nof binary strings beginning with number 3 is 2<sup>n-2</sup>\r\nas remaining n-2 bits can have any value.\r\n\r\nNumber 2 has two 0's so remaining n-2 bits must have\r\ntwo consecutive 1's. Therefore number of binary strings\r\nthat can be formed by number 2 is a<sub>n-2</sub>.\r\n\r\nNumber 3 and Number 4 together form all strings of length\r\nn-1 and two consecutive 1's.</pre></div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "Given below are some algorithms, and some algorithm design paradigms. \r\nList-I\r\nA. Dijkstra’s Shortest Path\r\nB. Floyd-Warshall algorithm to compute all pairs shortest path\r\nC. Binary search on a sorted array\r\nD. Backtracking search on a graph\r\n\r\nList-II\r\n1. Divide and Conquer\r\n2. Dynamic Programming\r\n3. Greedy design\r\n4. Depth-first search\r\n5. Breadth-first search \r\nMatch the above algorithms on the left to the corresponding design paradigm they follow\r\n\r\nCodes: \r\n    A B C D\r\n(a) 1 3 1 5\r\n(b) 3 3 1 5\r\n(c) 3 2 1 4\r\n(d) 3 2 1 5 ",
        "answer": [
            "a",
            "b",
            "c",
            "d"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>\r\n<a href=\"http://www.geeksforgeeks.org/greedy-algorithms-set-6-dijkstras-shortest-path-algorithm/\">Dijkstra’s Shortest Path</a> is a <a href=\"http://www.geeksforgeeks.org/greedy-algorithms-set-1-activity-selection-problem/\">Greedy Algorithm</a>.\r\n\r\n<a href=\"http://geeksquiz.com/binary-search/\">Floyd-Warshall </a>algorithm is Dynamic Programming.\r\n<a href=\"http://geeksquiz.com/binary-search/\">\r\nBinary search</a> is a <a href=\"http://www.geeksforgeeks.org/divide-and-conquer-set-1-find-closest-pair-of-points/\">Divide and Conquer</a>.\r\n\r\n<a href=\"http://www.geeksforgeeks.org/backtracking-set-1-the-knights-tour-problem/\">Backtracking </a>is <a href=\"http://www.geeksforgeeks.org/depth-first-traversal-for-a-graph/\">Depth-first search</a>\r\n</pre>\n</div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "Suppose c = 〈c[0], ... , c[k – 1]〉 is an array of length k, where all the entries are from the set {0, 1}. For any positive integers a and n, consider the following pseudocode.\r\n\r\nDOSOMETHING (c, a, n)\r\nz ← 1\r\nfor i ← 0 to k – 1\r\n    do z ← z2 mod n\r\n    if c[i] = 1\r\n       then z ← (z × a) mod n\r\nreturn z \r\nIf k = 4, c = 〈1, 0, 1, 1〉, a = 2 and n = 8, then the output of DOSOMETHING(c, a, n) is ____________.",
        "answer": [
            "0",
            "1",
            "2",
            "3"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>\r\nDOSOMETHING (c, a, n)\r\nz ← 1\r\nfor i ← 0 to k – 1\r\n    do z ← z<sup>2</sup> mod n\r\n    if c[i] = 1\r\n       then z ← (z × a) mod n\r\nreturn z </pre>\r\nIf k = 4, c = 〈1, 0, 1, 1〉, a = 2 and n = 8, then the output of DOSOMETHING(c, a, n) is ____________.\r\n\r\n<pre>\r\nFor i = 0, z = 1 mod 8 = 1, since c[0] = 1, z = 1*2 mod 8 = 2.\r\n\r\nFor i = 1, z = 2*2 mod 8 = 1, since c[1] = 0, z remains 4.\r\n\r\nFor i = 2, z = 16 mod 8 = 0 </pre>\r\n\r\nOnce z becomes 0, none of the statements inside DOSOMETHING() can make it non-zero.\r\n\r\n\r\n\r\n</div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "The following function computes XY for positive integers X and Y.\r\n\r\n\r\nint exp(int X, int Y)\r\n{\r\n    int res = 1, a = X, b = Y;\r\n    while ( b != 0 )\r\n    {\r\n        if ( b%2 == 0)\r\n        {\r\n            a = a*a;\r\n            b = b/2;\r\n        }\r\n        else\r\n        {\r\n            res = res*a;\r\n            b = b-1;\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\n\r\nWhich one of the following conditions is TRUE before every iteration of the loop\r\n\r\n",
        "answer": [
            "A",
            "B",
            "C",
            "D"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> \r\nWe can solve this question taking any two values for X and Y.\r\nSuppose X= 2 and Y= 5, now this code will calculate\r\nLooking at each iteration separately\r\nBefore iteration 1 – X=2 Y= 5 a=2 , b=5, res=1\r\nIteration 1 – since b%2 !=0 we go to else part\r\nTherefore after iteration 1, X=2, Y=5, a=2, b=4, res=2\r\nIteration 2 – since b%2=0 we go to if part\r\nTherefore after iteration 2 , X=2, Y=5, a=4, b=2, res=2\r\nIteration 3 – since b%2=0 we go to if part\r\nTherefore after iteration 3 , X=2, Y=5, a=16, b=1, res=2\r\nIteration 4 – since b%2!=0 we go to else part\r\nTherefore after iteration 4 , X=2, Y=5, a=16, b=0, res=32\r\nNow putting the values of X, Y , a, b, res in the equations given in options after each\r\niteration we can see only equation c is correct.\r\n\r\n\r\nThis solution is contributed by <strong>Parul sharma.</strong>\n<strong>Another solution</strong>\r\n\r\nIn option C <pre>\r\nBefore Iteration 1: X^Y=64 res ∗ (a^b)=64\r\nBefore Iteration 2: X^Y=64 res ∗ (a^b)=64\r\nBefore Iteration 3: X^Y=64 res ∗ (a^b)=64 </pre>\n<iframe allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen=\"\" frameborder=\"0\" height=\"315\" src=\"https://www.youtube.com/embed/Key2RKhzRGY?start=3067\" title=\"YouTube video player\" width=\"560\"></iframe></div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "The number of tokens in the Fortran statement DO 10  I= 1.25 is",
        "answer": [
            "3",
            "4",
            "5",
            "None of above"
        ],
        "correct": "C",
        "explain": "None",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "RAID configurations of disks are used to provide",
        "answer": [
            "Fault-tolerance ",
            "High speed",
            "High data density",
            "None of the above"
        ],
        "correct": "A",
        "explain": "None",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "Consider the following table\r\n\r\n\r\n       Algorithms                   Design Paradigms\r\n(P) Dijkastra’s Algorithm              (i) Divide and Conquer\r\n(Q) Strassen’s Matrix Multiplication   (ii) Greedy\r\n(R) Fibonacci numbers                  (iii) Dynamic Programming \r\n\r\nMatch the algorithm to design paradigms they are based on:",
        "answer": [
            "P-(ii), Q-(iii), R-(i)",
            "P-(iii), Q-(i), R-(ii)",
            "P-(ii), Q-(i), R-(iii)",
            "P-(i), Q-(ii), R-(iii)"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Dijkstra’s algorithm is Greedy technique to find the shortest path from a single source vertex to all other vertices in the given graph.\r\nStrassen’s Matrix Multiplication is Divide and conquer technique to multiply matrices in efficient way.\r\nFibonacci numbers uses Dynamic programming.\r\n\r\nTherefore, option (C) is true.\r\n</div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "Huffman coding is a lossless data compression algorithm. The most frequent character gets the smallest code and the least frequent character gets the largest code. Consider the following statements regarding Huffman coding algorithm?\r\nS1 : The time complexity of the Huffman algorithm is O(nlogn). Using a heap to store the weight of each tree, each iteration requires O(logn) time to determine the cheapest weight and insert the new weight. There are O(n) iterations, one for each item.\r\nS2 : If the input array is sorted, there exists a linear time algorithm.\r\nS3 : A divide-and-conquer approach might have us asking which characters should appear in the left and right subtrees and trying to build the tree from the top down. As with the optimal binary search tree, this will lead to to an exponential time algorithm.\r\n\r\nWhich of the following option is correct?",
        "answer": [
            "Statement S1 is correct, Statements S2 and S3 are not correct.",
            "Statements S1 and S2 are correct and statement S3 is not correct.",
            "Statements S2 and S3 are correct and statement S1 is not correct.",
            "All statements S1, S2, and S3 are correct."
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> All given statements are correct.</div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "A queue is implemented using a non-circular singly linked list. The queue has a head pointer and a tail pointer, as shown in the figure. Let n denote the number of nodes in the queue. Let 'enqueue' be implemented by inserting a new node at the head, and 'dequeue' be implemented by deletion of a node from the tail.\r\n\r\n\n\r\nWhich one of the following is the time complexity of the most time-efficient implementation of 'enqueue' and 'dequeue, respectively, for this data structure?",
        "answer": [
            "Θ(1),  Θ(1)",
            "Θ(1),  Θ(n)",
            "Θ(n),  Θ(1)",
            "Θ(n),  Θ(n)"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> For Enqueue operation, performs in constant amount of time (i.e., Θ(1)), because it modifies only two pointers, i.e., \r\n<pre>\r\nCreate a Node P.\r\nP--&gt;Data = Data\r\nP--&gt;Next = Head\r\nHead = P\r\n</pre>\r\n\r\nFor Dequeue operation, we need address of second last node of single linked list to make NULL of its next pointer. Since we can not access its previous node in singly linked list, so need to traverse entire linked list to get second last node of linked list, i.e.,\r\n<pre>\r\ntemp = head;\r\n While( temp-Next--&gt;Next != NULL){\r\n        temp = temp-Next;\r\n        }\r\ntemp--&gt;next = NULL;\r\nTail = temp;\r\n</pre>\r\nSince, we are traversing entire linked for each Dequeue, so time complexity will be Θ(n).\r\n\r\nOption (B) is correct.\r\n\r\n<iframe allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen=\"\" frameborder=\"0\" height=\"315\" src=\"https://www.youtube.com/embed/j9Vmf5yRw-I?start=2566\" title=\"YouTube video player\" width=\"560\"></iframe>\n</div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "Match the following and choose the correct answer for the order A, B, C, D\r\n\r\n\r\n\n\nA. Strassen matrix multiplication\np. Decrease and Conquer\n\n\nB. Insertion sort\nq. Dynamic Programming\n\n\nC. Guassian Elimination\nr. Divide and Conquer\n\n\nD. Floyd shortest path algorithm\ns. Transform and Conquer\n\n\n",
        "answer": [
            "r, s, p, q ",
            "r, p, s, q",
            "q, s, p, r",
            "s, p, q, r"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Strassen matrix multiplication uses Divide and Conquer technique to reduce the complexity of matrix multiplication. For details refer: <a href=\"https://www.geeksforgeeks.org/strassens-matrix-multiplication/\" rel=\"noopener\" target=\"_blank\">Strassen’s Matrix Multiplication</a>\r\n\r\nInsertion sort uses decrease and conquer approach as its loop invariant condition is at each step, A[1..j-1] contains the first j-1 elements in sorted order. Refer <a href=\"https://www.geeksforgeeks.org/decrease-and-conquer/\" rel=\"noopener\" target=\"_blank\"> Decrease and Conquer </a>\r\n\r\nGaussian elimination uses transform and conquer approach to solve set of equations. Refer <a href=\"https://www.geeksforgeeks.org/gaussian-elimination/\" rel=\"noopener\" target=\"_blank\">Gaussian Elimination to Solve Linear Equations</a>\r\n\r\nFloyd Warshall shortest path algorithm is an all-pair shortest path algorithm which uses Dynamic Programming to compute the result. Refer <a href=\"https://www.geeksforgeeks.org/dynamic-programming-set-16-floyd-warshall-algorithm/\" rel=\"noopener\" target=\"_blank\">Floyd Warshall Algorithm</a></div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "The infix expression A + (B - C)* D is correctly represented in prefix notation as",
        "answer": [
            "A + B − C ∗ D",
            "+ A ∗ − B C D",
            "A B C − D ∗ +",
            "A + B C − D ∗"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Given Expression =  A + (B - C)* D\r\n<pre>Prefix Notation:\r\nA + (- B C) * D\r\nA + (* - B C D)\r\n+ A * - B C D</pre>\r\n\r\nOption(B) is correct.</div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "An A* algorithm is a heuristic search technique which",
        "answer": [
            "is like a depth-first search where most promising child is selected for expansion",
            "generates all successor nodes and computes an estimate of distance (cost) from start node to a goal node through each of the successors. It then chooses the successor with shortest cost",
            "saves all path lengths (costs) from start node to all generated nodes and chooses shortest path for further expansion.",
            "none of the above"
        ],
        "correct": "B",
        "explain": "None",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "Let H be a binary min-heap consisting of n elements implemented as an array. What is the worst case time complexity of an optimal algorithm to find the maximum element in H?",
        "answer": [
            "Θ(1)",
            "Θ(logn)",
            "Θ(n)",
            "Θ(nlogn)"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> In case of min heap if we need to find out max element than it should be present at leave nodes so in worst case we need to search till leaf nodes we can't perform binary search here because its not BST and heaps need not be in sorted order so in worst case it would be (n/2)+1. On normalizing it would be O(n) which is option 3.\r\n\r\n\r\nRefer - <a href=\"https://www.geeksforgeeks.org/maximum-element-in-min-heap/\" rel=\"noopener\" target=\"_blank\">Maximum element in min heap</a>\n<iframe allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen=\"\" frameborder=\"0\" height=\"315\" src=\"https://www.youtube.com/embed/I43aLH5qEBc?start=1255\" title=\"YouTube video player\" width=\"560\"></iframe></div>",
        "keyword": "Algorithm Misc"
    },
    {
        "question": "Assuming P != NP, which of the following is true ?\r\n(A) NP-complete = NP\r\n(B) NP-complete  P = \n(C) NP-hard = NP\r\n(D) P = NP-complete",
        "answer": [
            "A",
            "B",
            "C",
            "D"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> The answer is B (no <a href=\"http://en.wikipedia.org/wiki/NP-complete\">NP-Complete</a> problem can be solved in polynomial time). Because, if one NP-Complete problem can be solved in polynomial time, then all NP problems can solved in polynomial time. If that is the case, then NP and P set become same which contradicts the given condition.\r\n</div>",
        "keyword": "NP Complete"
    },
    {
        "question": "Let S be an NP-complete problem and Q and R be two other problems not known to be in NP. Q is polynomial time reducible to S and S is polynomial-time reducible to R. Which one of the following statements is true? (GATE CS 2006)",
        "answer": [
            "R is NP-complete",
            "R is NP-hard",
            "Q is NP-complete",
            "Q is NP-hard"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> (A) Incorrect because R is not in NP. A NP Complete problem has to be in both NP and NP-hard.\r\n(B) Correct because a NP Complete problem S is polynomial time educable to R.\r\n(C) Incorrect because Q is not in NP.\r\n(D) Incorrect because there is no NP-complete problem that is polynomial time Turing-reducible to Q.</div>",
        "keyword": "NP Complete"
    },
    {
        "question": " Let X be a problem that belongs to the class NP. Then which one of the following is TRUE?",
        "answer": [
            "There is no polynomial time algorithm for X.",
            "If X can be solved deterministically in polynomial time, then P = NP.",
            "If X is NP-hard, then it is NP-complete.\r\n",
            "X may be undecidable."
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> (A) is incorrect because set NP includes both P(Polynomial time solvable) and NP-Complete .\r\n(B) is incorrect because X may belong to P (same reason as (A))\r\n(C) is correct because NP-Complete set is intersection of NP and NP-Hard sets.\r\n(D) is incorrect because all NP problems are decidable in finite set of operations.</div>",
        "keyword": "NP Complete"
    },
    {
        "question": "The problem 3-SAT and 2-SAT are\r\n",
        "answer": [
            "both in P",
            "both NP complete",
            "NP-complete and in P respectively",
            "undecidable and NP-complete respectively"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> The Boolean satisfiability problem (SAT) is a decision problem, whose instance is a Boolean expression written using only AND, OR, NOT, variables, and parentheses. The problem is: given the expression, is there some assignment of TRUE and FALSE values to the variables that will make the entire expression true? A formula of propositional logic is said to be satisfiable if logical values can be assigned to its variables in a way that makes the formula true.\r\n\r\n3-SAT and 2-SAT are special cases of k-satisfiability (k-SAT) or simply satisfiability (SAT), when each clause contains exactly k = 3 and k = 2  literals respectively. \r\n\r\n2-SAT is P while 3-SAT is NP Complete. (See <a href=\"http://suraj.lums.edu.pk/~cs514s05/data/2SAT.pdf\">this </a>for explanation)\r\n\r\nReferences:<a href=\"http://en.wikipedia.org/wiki/Boolean_satisfiability_problem\">\r\nhttp://en.wikipedia.org/wiki/Boolean_satisfiability_problem</a>\n</div>",
        "keyword": "NP Complete"
    },
    {
        "question": " Which of the following statements are TRUE? \r\n(1) The problem of determining whether there exists a cycle in an undirected graph is in P. \r\n(2) The problem of determining whether there exists a cycle in an undirected graph is in NP. \r\n(3) If a problem A is NP-Complete, there exists a non-deterministic polynomial time algorithm to solve A.",
        "answer": [
            " 1, 2 and 3 ",
            "1 and 3",
            "2 and 3",
            "1 and 2"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> <strong>1 </strong>is true because cycle detection can be done in polynomial time using DFS (See <a href=\"http://www.geeksforgeeks.org/detect-cycle-in-a-graph/\" target=\"_blank\">this</a>).\r\n<strong>2 </strong>is true because P is a subset of NP.\r\n<strong>3 </strong>is true because NP complete is also a subset of NP and NP means <strong>N</strong>on-deterministic <strong>P</strong>olynomial time solution exists. (See <a href=\"http://en.wikipedia.org/wiki/NP_(complexity)\" target=\"_blank\">this</a>)</div>",
        "keyword": "NP Complete"
    },
    {
        "question": "Which of the following is true about NP-Complete and NP-Hard problems.",
        "answer": [
            "If we want to prove that a problem X is NP-Hard, we take a known NP-Hard problem Y and reduce Y to X",
            "The first problem that was proved as NP-complete was the circuit satisfiability problem.",
            "NP-complete is a subset of NP Hard",
            "All of the above",
            "None of the above"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> See<a href=\"http://www.geeksforgeeks.org/np-completeness-set-1/\"> NP-Completeness </a>\n</div>",
        "keyword": "NP Complete"
    },
    {
        "question": "Which of the following statements are TRUE? \r\n1. The problem of determining whether there exists\r\n   a cycle in an undirected graph is in P.\r\n2. The problem of determining whether there exists\r\n   a cycle in an undirected graph is in NP.\r\n3. If a problem A is NP-Complete, there exists a \r\n   non-deterministic polynomial time algorithm to solve A. \n",
        "answer": [
            "1, 2 and 3 ",
            "1 and 2 only ",
            "2 and 3 only ",
            "1 and 3 only"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> 1. We can either use BFS or DFS to find whether there is a cycle in an undirected graph.  For example, see <a href=\"http://www.geeksforgeeks.org/detect-cycle-undirected-graph/\" target=\"_blank\">DFS based implementation to detect cycle in an undirected graph</a>.  The time complexity is O(V+E) which is polynomial.\r\n\r\n\r\n2. If a problem is in P, then it is definitely in NP (can be verified in polynomial time).  See <a href=\"http://www.geeksforgeeks.org/np-completeness-set-1/\" target=\"_blank\">NP-Completeness </a>\r\n\r\n\r\n3.  True.  See See <a href=\"http://www.geeksforgeeks.org/np-completeness-set-1/\" target=\"_blank\">NP-Completeness </a>\n</div>",
        "keyword": "NP Complete"
    },
    {
        "question": "Suppose a polynomial time algorithm is discovered that correctly computes the largest clique in a given graph. In this scenario, which one of the following represents the correct Venn diagram of the complexity classes P, NP and NP Complete (NPC)?\r\n\r\n",
        "answer": [
            "A",
            "B",
            "C",
            "D"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> Clique is an <a href=\"http://www.geeksforgeeks.org/np-completeness-set-1/\" target=\"_blank\">NP complete problem.</a>  If one NP complete problem can be solved in polynomial time, then all of them can be.  So NPC set becomes equals to P.</div>",
        "keyword": "NP Complete"
    },
    {
        "question": "Consider the decision problem 2CNFSAT defined as follows:\r\n\r\n\n",
        "answer": [
            "NP-Complete.",
            " solvable in polynomial time by reduction to directed graph reachability.",
            "solvable in constant time since any input instance is satisfiable.",
            " NP-hard, but not NP-complete."
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> 2CNF-SAT can be reduced to strongly connected components problem.  And strongly connected component has a polynomial time solution.  Therefore 2CNF-SAT is polynomial time solvable.  See <a href=\"https://en.wikipedia.org/wiki/2-satisfiability#Strongly_connected_components\">https://en.wikipedia.org/wiki/2-satisfiability#Strongly_connected_components</a> for details.\r\n\r\nAs a side note, <a href=\"https://en.wikipedia.org/wiki/Boolean_satisfiability_problem#3-satisfiability\">3CNFSAT</a> is NP Complete problem.</div>",
        "keyword": "NP Complete"
    },
    {
        "question": "Let SHAM3 be the problem of finding a Hamiltonian cycle in a graph G = (V,E) with V divisible by 3 and DHAM3 be the problem of determining if a Hamiltonian cycle exists in such graphs. Which one of the following is true?",
        "answer": [
            "Both DHAM3 and SHAM3 are NP-hard",
            "SHAM3 is NP-hard, but DHAM3 is not",
            "DHAM3 is NP-hard, but SHAM3 is not",
            "Neither DHAM3 nor SHAM3 is NP-hard"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> The problem of finding whether there exist a Hamiltonian Cycle or not is NP Hard and NP Complete Both. \r\n\r\nFinding a Hamiltonian cycle in a graph G = (V,E) with V divisible by 3 is also NP Hard.</div>",
        "keyword": "NP Complete"
    },
    {
        "question": "Consider the following two problems on undirected graphs \r\nα : Given G(V, E), does G have an independent set of size | V | - 4?\r\nβ : Given G(V, E), does G have an independent set of size 5? \r\nWhich one of the following is TRUE?\t\t \r\n",
        "answer": [
            "α is in P and β is NP-complete",
            "α is NP-complete and β is in P",
            "Both α and β are NP-complete",
            "Both α and β are in P"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Graph independent set decision problem is NP Complete.</div>",
        "keyword": "NP Complete"
    },
    {
        "question": "Ram and Shyam have been asked to show that a certain problem Π is NP-complete. Ram shows a polynomial time reduction from the 3-SAT problem to Π, and Shyam shows a polynomial time reduction from Π to 3-SAT. Which of the following can be inferred from these reductions ?",
        "answer": [
            "Π is NP-hard but not NP-complete",
            "Π is in NP, but is not NP-complete",
            "Π is NP-complete",
            "Π is neither NP-hard, nor in NP"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Since polynomial time reduction from the 3-SAT problem to Π is possible, it is NP hard.\r\n\r\nSince polynomial time reduction from Π  to 3-SAT is possible, it is NP-Complete.</div>",
        "keyword": "NP Complete"
    },
    {
        "question": "Consider the following two problems of graph.  \r\n\r\n1)   Given a graph, find if the graph has a cycle that visits every vertex exactly once except the first visited vertex which must be visited again to complete the cycle.\r\n\r\n2)  Given a graph, find if the graph has a cycle that visits every edge exactly once.\r\n\r\nWhich of the following is true about above two problems.\r\n",
        "answer": [
            "Problem 1 belongs NP Complete set and 2 belongs to P",
            "Problem 1 belongs to P set  and 2 belongs to NP Complete set",
            "Both problems belong to P set",
            "Both problems belong to NP complete set"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Problem 1 is Hamiltonian Cycle problem which is a famous NP Complete problem.\r\n\r\nProblem 2 is Euler Circuit problem which is solvable in Polynomial time.</div>",
        "keyword": "NP Complete"
    },
    {
        "question": "Consider two decision problems Q1, Q2 such that Q1 reduces in polynomial time to 3-SAT and 3-SAT reduces in polynomial time to Q2. Then which one of the following is consistent with the above statement?",
        "answer": [
            "Q1 is in NP, Q2 is NP hard",
            "Q2 is in NP, Q1 is NP hard",
            "Both Q1 and Q2 are in NP",
            "Both Q1 and Q2 are in NP hard"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>\r\nQ1 reduces in polynomial time to 3-SAT \r\n==&gt; Q1 is in NP\r\n\r\n3-SAT reduces in polynomial time to Q2 \r\n==&gt; Q2 is NP Hard.  If Q2 can be solved in P, then 3-SAT\r\n    can be solved in P, but 3-SAT is NP-Complete, that makes \r\n    Q2 NP Hard\r\n</pre> </div>",
        "keyword": "NP Complete"
    },
    {
        "question": "Language L1 is polynomial time reducible to language L2. Language L3 is polynomial time reducible to L2, which in turn is polynomial time reducible to language L4. Which of the following is/are True? \r\nI. If L4 ∈ P, L2 ∈ P\r\nII. If L1 ∈ P or L3 ∈ P, then L2 ∈ P\r\nIII. L1 ∈ P, if and only if L3 ∈ P\r\nIV. If L4 ∈ P, then L1 ∈ P and L3 ∈ P ",
        "answer": [
            "II only",
            "III only",
            "I and IV only",
            " I only"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Refer <a href=\"http://www.geeksforgeeks.org/np-completeness-set-1/\">http://www.geeksforgeeks.org/np-completeness-set-1/</a></div>",
        "keyword": "NP Complete"
    },
    {
        "question": "A problem in NP is NP-complete if\r\n\r\n ",
        "answer": [
            "It can be reduced to the 3-SAT problem in polynomial time",
            "The 3-SAT problem can be reduced to it in polynomial time",
            "It can be reduced to any other problem in NP in polynomial time",
            "some problem in NP can be reduced to it in polynomial time"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> A problem in NP becomes NPC if all NP problems can be reduced to it in polynomial time. This is same as reducing any of the NPC problem to it. 3-SAT being an NPC problem, reducing it to a NP problem would mean that NP problem is NPC.\r\n\r\n \r\n\r\nPlease refer: http://www.geeksforgeeks.org/np-completeness-set-1/</div>",
        "keyword": "NP Complete"
    },
    {
        "question": "For problems X and Y, Y is NP-complete and X reduces to Y in polynomial time. Which of the following is TRUE?",
        "answer": [
            "If X can be solved in polynomial time, then so can Y",
            "X is NP-complete",
            "X is NP-hard",
            "X is in NP, but not necessarily NP-complete"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\">  \r\n<p align=\"justify\"><span style=\"color: #000000;\"><span style=\"font-family: Arial;\"><span style=\"font-size: small;\">In order to solve these type of questions in GATE, we will give 2 important theorems. Proofs of these is beyond the scope of this explanation. For Proofs please refer to Introduction To Algorithms by Thomas Cormen.</span></span></span></p>\n<p align=\"justify\"><span style=\"color: #000000;\"><span style=\"font-family: Arial;\"><span style=\"font-size: small;\"><b>Theorem - 1\r\n</b>When a given Hard Problem (NPC, NPH and Undecidable Problems) is reduced to an unknown problem in polynomial time, then unknown problem also becomes Hard.\r\n</span></span></span></p>\n<p align=\"justify\"><span style=\"color: #000000;\"><span style=\"font-family: Arial;\"><span style=\"font-size: small;\"><i>Case - 1 </i> When NPC(NP-Complete) problem is reduced to unknown problem, unknown problem becomes NPH(NP-Hard).</span></span></span></p>\n<p align=\"justify\"><span style=\"color: #000000;\"> </span><span style=\"font-size: small;\"><span style=\"color: #000000;\"><span style=\"font-family: Arial;\"><i>Case - 2</i></span></span> <span style=\"color: #000000;\"><span style=\"font-family: Arial;\">When NPH(NP-Hard) problem is reduced to unknown problem, unknown problem becomes NPH(NP-Hard).</span></span></span></p>\n<p align=\"justify\"><span style=\"font-size: small;\"><span style=\"color: #000000;\"><span style=\"font-family: Arial;\"><i>Case - 3</i></span></span> <span style=\"color: #000000;\"><span style=\"font-family: Arial;\">When undecidable problem is reduced to unknown problem, unknown problem becomes also becomes undecidable.</span></span></span></p>\n<p align=\"justify\"><span style=\"color: #000000;\"><span style=\"font-family: Arial;\"><span style=\"font-size: small;\">Remember that Hard problems needs to be converted for this theorem but not the other way.</span></span></span></p>\n<p align=\"justify\"><span style=\"color: #000000;\"><span style=\"font-family: Arial;\"><span style=\"font-size: small;\"><b>Theorem - 2</b></span></span></span></p>\n<p align=\"justify\"><span style=\"color: #000000;\"><span style=\"font-family: Arial;\"><span style=\"font-size: small;\">When an unknown problem  is reduced to an  Easy problem(P or NP) in polynomial time, then unknown problem also becomes easy.</span></span></span></p>\n<p align=\"justify\"><span style=\"font-size: small;\"><span style=\"color: #000000;\"><span style=\"font-family: Arial;\"><i>Case - 1 </i></span></span><span style=\"color: #000000;\"> </span><span style=\"color: #000000;\"><span style=\"font-family: Arial;\">When an unknown problem  is reduced to a P type problem, unknown problem also becomes P.</span></span></span></p>\n<p align=\"justify\"><span style=\"font-size: small;\"><span style=\"color: #000000;\"><span style=\"font-family: Arial;\"><i>Case - 2</i></span></span> <span style=\"color: #000000;\"><span style=\"font-family: Arial;\">When an unknown problem  is reduced to a NP type problem, unknown problem also becomes NP.</span></span></span></p>\n<p align=\"justify\"><span style=\"color: #000000;\"><span style=\"font-family: Arial;\"><span style=\"font-size: small;\">Remember that unknown problems needs to be converted for this theorem to work but not the other way.</span></span></span></p>\n<p align=\"justify\"><span style=\"font-size: small;\"><span style=\"color: #000000;\"><span style=\"font-family: Arial;\">In the given question, X which is unknown problem is reduced to NPC problem in polynomial time so Theorem - 1 will not work. But all NPC problems are also NP, so we can say that X is getting reduced to a known NP problem so that  </span></span><span style=\"color: #000000;\"><span style=\"font-family: Arial;\"><b>Theorem - 2 </b></span></span><span style=\"color: #000000;\"><span style=\"font-family: Arial;\">is applicable and X is also NP. In order to make it NPC, we have to prove it NPH first which is not the case as Y is not getting reduced to X.</span></span></span></p>\n<p align=\"justify\"></p>\n<p align=\"justify\">This solution is contributed by <b class=\"gmail_sendername\">Pranjul Ahuja</b>.</p>\n<p align=\"justify\"><span style=\"color: #000000;\"><span style=\"font-family: Arial;\"><span style=\"font-size: small;\"> </span></span></span></p></div>",
        "keyword": "NP Complete"
    },
    {
        "question": "The problems 3-SAT and 2-SAT are",
        "answer": [
            "Both NP-complete",
            "Both in P",
            "NP-complete and in P, respectively",
            "Undecidable and NP-complete, respectively"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> 3-SAT problem is NP- complete problem whereas 2- SAT problem is P- class problem.\r\nRefer: <a href=\"https://www.geeksforgeeks.org/2-satisfiability-2-sat-problem/\" rel=\"noopener\" target=\"_blank\">2-Satisfiability (2-SAT) Problem</a>\r\nOption (C) is correct.</div>",
        "keyword": "NP Complete"
    },
    {
        "question": "Given the following statements:\r\nS1 : Every context-sensitive language L is recursive\r\nS2 : There exists a recursive language that is not context-sensitive\r\nWhich statements are true?",
        "answer": [
            "Only S1 is correct",
            "Only S2 is correct",
            "Both S1 and S2 are not correct",
            "Both S1 and S2 are correct"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> According to Chomsky Hierarchy:\r\nRefer: <a href=\"https://www.geeksforgeeks.org/toc-chomsky-hierarchy/\" rel=\"noopener\" target=\"_blank\">Theory of Computation | Chomsky Hierarchy</a>\r\nCSL languages are the subset of recursive languages, so, (S1) is correct.\r\nAlso, Recursive languages are the superset of CSL and it is not necessary that every Recursive language is CSL. So, (S2) is also correct.\r\nOption (D) is correct.</div>",
        "keyword": "NP Complete"
    },
    {
        "question": "What is the output of following program?\r\n\r\n\r\n#include <stdio.h>\r\n\r\nvoid print(int n, int j)\r\n{\r\n   if (j >= n)\r\n      return;\r\n   if (n-j > 0 && n-j >= j)\r\n       printf(\"%d %dn\", j, n-j);\r\n   print(n, j+1);\r\n}\r\n\r\nint main()\r\n{\r\n    int n = 8;\r\n    print(n, 1);\r\n}\r\n\r\n\n",
        "answer": [
            "1 7\r\n2 6\r\n3 5\r\n4 4\r\n4 4\n",
            "1 7\r\n2 6\r\n3 5\r\n4 4",
            "1 7\r\n2 6\r\n3 5",
            "1 2\r\n3 4\r\n5 6\r\n7 8"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> For a given number n, the program prints all distinct pairs of positive integers with sum equal to n.</div>",
        "keyword": "Searching"
    },
    {
        "question": "Which of the following is correct recurrence for worst case of Binary Search?",
        "answer": [
            "T(n) = 2T(n/2) + O(1) and T(1) = T(0) = O(1)",
            "T(n) = T(n-1) + O(1) and T(1) = T(0) = O(1)",
            "T(n) = T(n/2) + O(1) and T(1) = T(0) = O(1)",
            "T(n) = T(n-2) + O(1) and T(1) = T(0) = O(1)"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Following is typical implementation of Binary Search.  \r\n\r\n[sourcecode language=\"C\"]\r\n// Searches x in arr[low..high].  If x is present, then returns its index, else -1\r\nint binarySearch(int arr[], int low, int high, int x)\r\n{\r\n    if(high &gt;= low)\r\n    {\r\n        int mid = low + (high - low)/2;\r\n        if (x == arr[mid])\r\n            return mid;\r\n        if (x&gt; arr[mid])\r\n            return binarySearch(arr, (mid + 1), high);\r\n        else\r\n            return binarySearch(arr, low, (mid -1));\r\n    }\r\n\r\n    return -1;\r\n}\r\n[/sourcecode]\r\n\r\nIn Binary Search, we first compare the given element x with middle of the array.  If x matches with middle element, then we return middle index.  Otherwise, we either recur for left half of array or right half of array.\r\n\r\nSo recurrence is T(n) = T(n/2) + O(1)</div>",
        "keyword": "Searching"
    },
    {
        "question": "Given a sorted array of integers, what can be the minimum worst case time complexity to find ceiling of a number x in given array?  Ceiling of an element x is the smallest element present in array which is greater than or equal to x.  Ceiling is not present if x is greater than the maximum element present in array. For example, if the given array is {12, 67, 90, 100, 300, 399} and x = 95, then output should be 100.  ",
        "answer": [
            "O(LogLogn)",
            "O(n)",
            "O(Logn)",
            "O(Logn * Logn)"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> We modify standard binary search to find ceiling.  The time complexity T(n) can be written as \r\n\r\nT(n) &lt;= T(n/2) + O(1)\r\n\r\nSolution of above recurrence can be obtained by Master Method.  It falls in case 2 of Master Method.  Solution is O(Logn).\r\n\r\n\r\n[sourcecode language=\"C\"]\r\n#include<stdio.h>\r\n \r\n/* Function to get index of ceiling of x in arr[low..high]*/\r\nint ceilSearch(int arr[], int low, int high, int x)\r\n{\r\n  int mid;    \r\n \r\n  /* If x is smaller than or equal to the first element,\r\n    then return the first element */\r\n  if(x &lt;= arr[low])\r\n    return low; \r\n \r\n  /* If x is greater than the last element, then return -1 */\r\n  if(x &gt; arr[high])\r\n    return -1;  \r\n \r\n  /* get the index of middle element of arr[low..high]*/\r\n  mid = (low + high)/2;  /* low + (high - low)/2 */\r\n \r\n  /* If x is same as middle element, then return mid */\r\n  if(arr[mid] == x)\r\n    return mid;\r\n     \r\n  /* If x is greater than arr[mid], then either arr[mid + 1]\r\n    is ceiling of x or ceiling lies in arr[mid+1...high] */ \r\n  else if(arr[mid] &lt; x)\r\n  {\r\n    if(mid + 1 &lt;= high &amp;&amp; x &lt;= arr[mid+1])\r\n      return mid + 1;\r\n    else\r\n      return ceilSearch(arr, mid+1, high, x);\r\n  }\r\n \r\n  /* If x is smaller than arr[mid], then either arr[mid] \r\n     is ceiling of x or ceiling lies in arr[mid-1...high] */   \r\n  else\r\n  {\r\n    if(mid - 1 &gt;= low &amp;&amp; x &gt; arr[mid-1])\r\n      return mid;\r\n    else    \r\n      return ceilSearch(arr, low, mid - 1, x);\r\n  }\r\n}\r\n \r\n/* Driver program to check above functions */\r\nint main()\r\n{\r\n   int arr[] = {1, 2, 8, 10, 10, 12, 19};\r\n   int n = sizeof(arr)/sizeof(arr[0]);\r\n   int x = 20;\r\n   int index = ceilSearch(arr, 0, n-1, x);\r\n   if(index == -1)\r\n     printf(\"Ceiling of %d doesn't exist in array \", x);\r\n   else \r\n     printf(\"ceiling of %d is %d\", x, arr[index]);\r\n   getchar();\r\n   return 0;\r\n}\r\n[/sourcecode]</stdio.h></div>",
        "keyword": "Searching"
    },
    {
        "question": "Consider the following C program that attempts to locate an element x in an array Y[] using binary search. The program is erroneous. (GATE CS 2008)\r\n\r\n\r\n1.   f(int Y[10], int x) {\r\n2.     int i, j, k;\r\n3.     i = 0; j = 9;\r\n4.     do {\r\n5.             k =  (i + j) /2;\r\n6.             if( Y[k] < x)  i = k; else j = k;\r\n7.         } while(Y[k] != x && i < j);\r\n8.     if(Y[k] == x) printf (\"x is in the array \") ;\r\n9.     else printf (\" x is not in the array \") ;\r\n10. }\r\n\r\n\r\nOn which of the following contents of Y and x does the program fail?",
        "answer": [
            "Y is [1 2 3 4 5 6 7 8 9 10] and x < 10",
            "Y is [1 3 5 7 9 11 13 15 17 19] and x < 1",
            "Y is [2 2 2 2 2 2 2 2 2 2] and x > 2",
            "Y is [2 4 6 8 10 12 14 16 18 20] and 2 < x < 20 and x is even"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> The above program doesn’t work for the cases where element to be searched is the last element of Y[] or greater than the last element (or maximum element) in Y[]. For such cases, program goes in an infinite loop because i is assigned value as k in all iterations, and i never becomes equal to or greater than j. So while condition never becomes false.</div>",
        "keyword": "Searching"
    },
    {
        "question": " In the above question, the correction needed in the program to make it work properly is (GATE CS 2008)",
        "answer": [
            "Change line 6 to: if (Y[k] < x) i = k + 1; else j = k-1;",
            "Change line 6 to: if (Y[k] < x) i = k - 1; else j = k+1;",
            "Change line 6 to: if (Y[k] <= x) i = k; else j = k;",
            "Change line 7 to: } while ((Y[k] == x) && (i < j));"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Below is the corrected function\r\n\r\n[sourcecode language=\"C\"]\r\nf(int Y[10], int x) {\r\n   int i, j, k;\r\n   i = 0; j = 9;\r\n   do {\r\n           k =  (i + j) /2;\r\n           if( Y[k] &lt; x)  i = k + 1; else j = k - 1;\r\n       } while(Y[k] != x &amp;&amp; i &lt; j);\r\n   if(Y[k] == x) printf (\"x is in the array \") ;\r\n   else printf (\" x is not in the array \") ;\r\n}[/sourcecode]\r\nReference: http://en.wikipedia.org/wiki/Binary_search_algorithm#Implementations</div>",
        "keyword": "Searching"
    },
    {
        "question": "You are given a list of 5 integers and these integers are in the range from 1 to 6. There are no duplicates in list. One of the integers is missing in the list. Which of the following expression would give the missing number.\r\n^ is bitwise XOR operator. \r\n~ is bitwise NOT operator. \r\n\r\nLet elements of list can be accessed as list[0], list[1], list[2], list[3], list[4]",
        "answer": [
            "list[0] ^ list[1] ^ list[2] ^ list[3] ^ list[4]",
            "list[0] ^ list[1] ^ list[2] ^ list[3] ^ list[4] ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6",
            "list[0] ^ list[1] ^ list[2] ^ list[3] ^ list[4] ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ",
            "~(list[0] ^ list[1] ^ list[2] ^ list[3] ^ list[4])"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> XOR of all list elements and numbers from 1 to 6 gives the missing number.  See <a href=\"http://www.geeksforgeeks.org/find-the-missing-number/\">this </a>for details</div>",
        "keyword": "Searching"
    },
    {
        "question": "Consider the C function given below. Assume that the array listA contains n (> 0) elements, sorted in ascending order.\r\n\r\nint ProcessArray(int *listA, int x, int n)\r\n{\r\n    int i, j, k;\r\n    i = 0;\r\n    j = n-1;\r\n    do\r\n    {\r\n        k = (i+j)/2;\r\n        if (x <= listA[k])\r\n            j = k-1;\r\n        if (listA[k] <= x)\r\n            i = k+1;\r\n    }\r\n    while (i <= j);\r\n    if (listA[k] == x)\r\n        return(k);\r\n    else\r\n        return -1;\r\n}\r\n\r\nWhich one of the following statements about the function ProcessArray is CORRECT?",
        "answer": [
            "It will run into an infinite loop when x is not in listA.",
            " It is an implementation of binary search.",
            "It will always find the maximum element in listA.",
            " It will return −1 even when x is present in listA."
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>\r\nThe function is iterative implementation of <a href=\"http://geeksquiz.com/binary-search/\">Binary Search</a>.  \r\n\r\nk keeps track of current middle element.\r\n\r\ni and j keep track of left and right corners\r\nof current subarray</pre></div>",
        "keyword": "Searching"
    },
    {
        "question": "Consider a sorted array of n numbers. What would be the time complexity of the best known algorithm to find a pair 'a' and 'b' such that |a-b| = k , k being a positive integer.",
        "answer": [
            "O(n)",
            "O(n log n)",
            " O(n ^ 2)",
            " O(log n)"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Just maintain two pointers at the start and accordingly increment one of them depending upon whether difference is less than or greater than k. Just a single pass is required so the answer is O(n).</div>",
        "keyword": "Searching"
    },
    {
        "question": "Consider a sorted array of n numbers. What would be the time complexity of the best known algorithm to find a pair 'a' and 'b' such that |a-b| = k , k being a positive integer.",
        "answer": [
            "O(n)",
            "O(n log n)",
            " O(n ^ 2)",
            " O(log n)"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Just maintain two pointers at the start and accordingly increment one of them depending upon whether difference is less than or greater than k. Just a single pass is required so the answer is O(n).</div>",
        "keyword": "Searching"
    },
    {
        "question": "The average number of key comparisons done in a successful sequential search in a list of length it is",
        "answer": [
            "log n",
            "(n-1)/2",
            "n/2",
            "(n+1)/2"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> If element is at 1 position then it requires 1 comparison.\r\nIf element is at 2 position then it requires 2 comparison.\r\nIf element is at 3 position then it requires 3 comparison.\r\nSimilarly , If element is at n position then it requires n comparison.\r\n<pre>Total comparison \r\n= n(n+1)/2\r\n\r\nFor average comparison \r\n= (n(n+1)/2) / n \r\n= (n+1)/2 </pre>\r\n\r\nOption (D) is correct.</div>",
        "keyword": "Searching"
    },
    {
        "question": "Consider the following program that attempts to locate an element x in a sorted array a[ ] using binary search. Assume N>1. The program is erroneous. Under what conditions does the program fail?\r\nvar i,j,k: integer;  x: integer;\r\n    a: array; [1....N] of integer;\r\nbegin\ti:= 1; j:= N;\r\nrepeat\t\r\n    k:(i+j) div 2;\r\n    if a[k] < x then i:= k \r\n    else j:= k \r\nuntil (a[k] = x) or (i >= j);\r\n    \r\nif (a[k] = x) then\r\n    writeln ('x is in the array')\r\nelse\r\n    writeln ('x is not in the array')\r\nend;\r\n",
        "answer": [
            "x is the last element of the array a[]",
            "x is greater than all elements of the array a[]",
            "Both of the Above",
            "x is less than the last element of the array a[]"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> The above program doesn’t work for the cases where element to be searched is the last element of a[] or greater than the last element (or maximum element) in a[]. For such cases, program goes in an infinite loop because i is assigned value as k in all iterations, and i never becomes equal to or greater than j. So while condition never becomes false. </div>",
        "keyword": "Searching"
    },
    {
        "question": "The recurrence relation that arises in relation with the complexity of binary search is:",
        "answer": [
            "T(n) = 2T(n/ 2) + k , where k is constant",
            "T(n) = T(n / 2) + k , where k is constant",
            "T(n) = T(n / 2) + log n",
            "T(n) = T(n / 2) + n"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Binary Search is a linear searching algorithm and takes  O(log n) when array is sorted. Refer: <a href=\"https://www.geeksforgeeks.org/binary-search/\" rel=\"noopener\" target=\"_blank\">Binary Search</a>\r\nT(n) = T(n / 2) + k , where k is constant produces a complexity of O(log n) </div>",
        "keyword": "Searching"
    },
    {
        "question": "The average number of key comparisons required for a successful search for sequential search on items is",
        "answer": [
            "n/2",
            "(n-1)/2",
            "(n+1)/2",
            "None of these"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> If element is at i-th position where 1 &lt;= i &lt;= n, then we need i comparisons.  So average number of comparisons is (1 + 2 + 3 + ..... n)/n = (n * (n + 1)/ 2) / n = (n + 1)/2</div>",
        "keyword": "Searching"
    },
    {
        "question": "Suppose there are 11 items in sorted order in an array. How many searches are required on the average, if binary search is employed and all searches are successful in finding the item?",
        "answer": [
            "3.00",
            "3.46",
            "2.81",
            "3.33"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> For 11 items, Binary search required total number of comparisons for each item as following:\r\n\r\n<img alt=\"333\" class=\"aligncenter size-full wp-image-198822\" height=\"301\" src=\"https://www.geeksforgeeks.org/wp-content/uploads/333-3.png\" width=\"431\"/>\r\n\r\nTherefore, total number of caparisons required\r\n= 1*1 + 2*2 + 4*3 + 4*4 = 33\r\n\r\nAverage comparisons required for 11 items = 33/11 = 3\r\n\r\nSo, option (A) is correct.</div>",
        "keyword": "Searching"
    },
    {
        "question": "Let n = 4 and  (a1, a2, a3, a4) = (do, if, int, while).Let p(1 : 4) = (3 / 8,\t3 / 8,\t1 /8, 1 / 8) and Let q(1 : 4) = (2 / 8, 3 / 8, 1 / 8, 1 / 8, 1 / 8) where p(i) and q(i) denotes the probability with which we search a and the identifier x being searched satisfy ai < x < ai + 1 respectively. The optimal search tree is given by:\t\r\n(1)\r\n\r\n(2)\r\n\r\n(3)\r\n\r\n(4)\r\n\n",
        "answer": [
            "(1)",
            "(2)",
            "(3)",
            "(3)"
        ],
        "correct": "B",
        "explain": "None",
        "keyword": "Searching"
    },
    {
        "question": "The average case occurs in the Linear Search Algorithm when:",
        "answer": [
            "The item to be searched is in some where middle of the Array",
            "The item to be searched is not in the array",
            "The item to be searched is in the last of the array",
            "The item to be searched is either in the last or not in the array\r\n"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> <li>The average case occurs in the Linear Search Algorithm when the item to be searched is in some where middle of the Array.</li>\n<li>The best case occurs in the Linear Search Algorithm when the item to be searched is in starting of the Array.</li>\n<li>The worst case occurs in the Linear Search Algorithm when the item to be searched is in end of the Array.</li>\r\nSo, option (A) is correct.</div>",
        "keyword": "Searching"
    },
    {
        "question": "The average case occurs in the Linear Search Algorithm when:",
        "answer": [
            "The item to be searched is in some where middle of the Array",
            "The item to be searched is not in the array",
            "The item to be searched is in the last of the array",
            "The item to be searched is either in the last or not in the array\r\n"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> <li>The average case occurs in the Linear Search Algorithm when the item to be searched is in some where middle of the Array.</li>\n<li>The best case occurs in the Linear Search Algorithm when the item to be searched is in starting of the Array.</li>\n<li>The worst case occurs in the Linear Search Algorithm when the item to be searched is in end of the Array.</li>\r\nSo, option (A) is correct.</div>",
        "keyword": "Searching"
    },
    {
        "question": "Number of comparisons required for an unsuccessful search of an element in a sequential search, organized, fixed length, symbol table of length L is                                                                                                                                             ",
        "answer": [
            "L",
            "L/2",
            "(L+1)/2",
            "2L"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> In Sequential search, in order to find a particular element, each element of the table is searched sequentially until the desired element is not found.\r\nSo, in case of an unsuccessful search, the element would be searched until the last element and it would be a worst case when number of searches are equal to the size of the table.\r\n\r\nSo, option (A) is correct.</div>",
        "keyword": "Searching"
    },
    {
        "question": "Which of the following statements is true for Branch - and - Bound search?",
        "answer": [
            "Underestimates of remaining distance may cause deviation from optimal path.",
            "Overestimates can't cause right path to be overlooked.",
            "Dynamic programming principle can be used to discard redundant partial paths.",
            "All of the above"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> <a href=\"https://www.geeksforgeeks.org/branch-and-bound-algorithm/\" rel=\"noopener\" target=\"_blank\">Branch and bound</a> is a type of problem solving technique which is  used to solve a  combinatorial optimization problems. It is  helps in solving them faster compare to other technique.it divides a problem into two subproblem. For branch and bound search <a href=\"https://www.geeksforgeeks.org/dynamic-programming/\" rel=\"noopener\" target=\"_blank\">Dynamic programming</a> principle can be used to discard redundant partial paths. \r\n\r\nOption (C) is correct.</div>",
        "keyword": "Searching"
    },
    {
        "question": "\n\n\n\nMatch the following:\n\n\nList - I",
        "answer": "None",
        "correct": "None",
        "explain": "None",
        "keyword": "Searching"
    },
    {
        "question": "The time taken by binary search algorithm to search a key in a sorted array of n elements is",
        "answer": [
            "O ( log2n )",
            "O ( n )",
            "O ( n log2n )",
            "O ( n2 )"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Search a sorted array by repeatedly dividing the search interval in half. Begin with an interval covering the whole array. If the value of the search key is less than the item in the middle of the interval, narrow the interval to the lower half. Otherwise narrow it to the upper half. Repeatedly check until the value is found or the interval is empty. It takes a maximum of log(n) searches to search an element from the sorted array.\r\n\r\nOption (A) is correct.</div>",
        "keyword": "Searching"
    },
    {
        "question": "Suppose that we have numbers between 1 and 1000 in a binary search tree and we want to search for the number 365. Which of the following sequences could not be the sequence of nodes examined ?",
        "answer": [
            "4, 254, 403, 400, 332, 346, 399, 365",
            "926, 222, 913, 246, 900, 260, 364, 365",
            "927, 204,913, 242, 914, 247, 365",
            "4, 401, 389, 221, 268, 384, 383, 280, 365"
        ],
        "correct": "C",
        "explain": "None",
        "keyword": "Searching"
    },
    {
        "question": "Consider a sorted array of n numbers and a number x. What would be the time complexity of the best known algorithm to find a triplet with sum equal to x. For example, arr[] = {1, 5, 10, 15, 20, 30}, x = 40. Then there is a triplet {5, 15, 20} with sum 40.",
        "answer": [
            "O(n)",
            "O(n^2)\r\n",
            "O(n Log n)",
            "O(n^3)"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> We need to fix every element one by one, then apply two pointer approach to find the pair with x minus the fixed element in remaining array after the fixed element. Please see method 2 of <a href=\"https://www.geeksforgeeks.org/find-a-triplet-that-sum-to-a-given-value/\">Find a triplet that sum to a given value</a></div>",
        "keyword": "Searching"
    },
    {
        "question": "What is the value of following recurrence. \r\n\r\nT(n) = T(n/4) + T(n/2) + cn2\r\nT(1) = c\r\nT(0) = 0\r\n\r\nWhere c is a positive constant\r\n\r\n",
        "answer": [
            "O(n3)",
            "O(n2)",
            "O(n2  Logn)",
            "O(nLogn)"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Following is the initial recursion tree for the given recurrence relation.\r\n\r\n<pre>\r\n           cn^2\r\n         /      \\\r\n     T(n/4)     T(n/2)\r\n</pre>\r\n\r\nIf we further break down the expression T(n/4) and T(n/2), we get following recursion tree.\r\n<pre>\r\n               cn^2\r\n           /           \\      \r\n       c (n^2)/16       c(n^2)/4\r\n      /      \\          /     \\\r\n  T(n/16)     T(n/8)  T(n/8)    T(n/4) \r\n</pre>\r\n\r\nBreaking down further gives us following\r\n<pre>\r\n                 cn^2\r\n            /             \\      \r\n       c(n^2)/16           c(n^2)/4\r\n       /      \\            /      \\\r\nc(n^2)/256  c(n^2)/64  c(n^2)/64    c(n^2)/16\r\n /    \\      /    \\    /    \\         /    \\    \r\n \r\n\r\n</pre>\r\n\r\nTo know the value of T(n), we need to calculate sum of tree nodes level by level. If we sum the above tree level by level, we get the following series\r\nT(n)  = c(n^2 + 5(n^2)/16 + 25(n^2)/256) + ....\r\nThe above series is geometrical progression with ratio 5/16\r\nTo get an upper bound, we can sum the above series for infinite terms. We get the sum as (n^2) / (1 - 5/16) which is O(n^2) \r\n\r\nRefer following video lecture for more details.\r\n<a href=\"http://www.youtube.com/watch?v=whjt_N9uYFI\" target=\"_blank\">http://www.youtube.com/watch?v=whjt_N9uYFI</a>\n</div>",
        "keyword": "Analysis of Algorithms (Recurrences)"
    },
    {
        "question": "What is the value of following recurrence. \r\n\r\nT(n) = 5T(n/5) + ,\r\nT(1) = 1,\r\nT(0) = 0\r\n\r\n\r\n",
        "answer": [
            "Theta (n)",
            "Theta (n^2)",
            "Theta (sqrt(n))",
            "Theta (nLogn)"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> The given solution can be solved using <a href=\"http://en.wikipedia.org/wiki/Master_theorem\" target=\"_blank\">Master Method</a>.  It falls in Case 1.\r\n</div>",
        "keyword": "Analysis of Algorithms (Recurrences)"
    },
    {
        "question": "What is the worst case time complexity of following implementation of subset sum problem.\r\n\r\n\r\n\r\n// Returns true if there is a subset of set[] with sun equal to given sum\r\nbool isSubsetSum(int set[], int n, int sum)\r\n{\r\n   // Base Cases\r\n   if (sum == 0)\r\n     return true;\r\n   if (n == 0 && sum != 0)\r\n     return false;\r\n \r\n   // If last element is greater than sum, then ignore it\r\n   if (set[n-1] > sum)\r\n     return isSubsetSum(set, n-1, sum);\r\n \r\n   /* else, check if sum can be obtained by any of the following\r\n      (a) including the last element\r\n      (b) excluding the last element   */\r\n   return isSubsetSum(set, n-1, sum) || \r\n          isSubsetSum(set, n-1, sum-set[n-1]);\r\n}\r\n",
        "answer": [
            "O(n * 2^n)",
            "O(n^2)",
            "O(n^2 * 2^n)",
            "O(2^n)"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> Following is the recurrence for given implementation of subset sum problem\r\n\r\nT(n) = 2T(n-1) + C1 \r\nT(0) =  C1\r\n\r\nWhere C1 and C2 are some machine specific constants.\r\n\r\nThe solution of recurrence is O(2^n)\r\n\r\nWe can see it with the help of recurrence tree method\r\n<pre>\r\n           C1\r\n       /       \\\r\n    T(n-1)     T(n-1) \r\n\r\n\r\n                    C1\r\n                /       \\\r\n              C1           C1\r\n           /     \\        /    \\\r\n      T(n-2)  T(n-2)   T(n-2)  T(n-2)\r\n\r\n                    C1\r\n                /       \\\r\n              C1           C1\r\n           /     \\        /    \\\r\n          C1     C1      C1     C1\r\n        /   \\   /  \\    /  \\   /  \\\r\n\r\n       \r\nIf we sum the above tree level by level, we get the following series\r\nT(n) = C1 + 2C1 + 4C1 + 8C1 + ...\r\nThe above series is Geometrical progression and there will be n terms in it.\r\nSo T(n) = O(2^n)    \r\n</pre>\n</div>",
        "keyword": "Analysis of Algorithms (Recurrences)"
    },
    {
        "question": "Suppose T(n) = 2T(n/2) + n, T(0) = T(1) = 1\r\nWhich one of the following is false. ( GATE CS 2005)\r\na)\tT(n) = O(n^2)\r\nb)\tT(n) = (nLogn)\r\nc)\tT(n) = (n^2)\r\nd)\tT(n) = O(nLogn)\r\n\r\n\r\n",
        "answer": [
            "A",
            "B",
            "C",
            "D"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> See question 4 of <a href=\"http://www.geeksforgeeks.org/data-structures-and-algorithms-set-23/\" target=\"_blank\">http://www.geeksforgeeks.org/data-structures-and-algorithms-set-23/</a> for explanation.</div>",
        "keyword": "Analysis of Algorithms (Recurrences)"
    },
    {
        "question": "Consider the following recurrence:\n\r\n\r\nWhich one of the following is true?\r\n\r\n(A) T(n) = (loglogn)\r\n(B) T(n) = (logn)\r\n(C) T(n) = (sqrt(n))\r\n(D) T(n) = (n)\n",
        "answer": [
            "A",
            "B",
            "C",
            "D"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> This question can be solved by first change of variable and then Master Method.\r\n<pre>\r\n  Let n = 2^m\r\n  T(2^m) = T(2^(m/2)) + 1\r\n  Let T(2^m) =  S(m)\r\n  S(m)  = 2S(m/2) + 1  \r\n</pre>\r\n\r\nAbove expression is a binary tree traversal recursion whose time complexity is <img alt=\"\\theta\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"19\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-a372b7ef1ffaec3b4ad80e0141550990_l3.png\" style=\"vertical-align: 0px;\" title=\"Rendered by QuickLaTeX.com\" width=\"11\"/>(m).  You can also prove using <a href=\"http://en.wikipedia.org/wiki/Master_theorem#cite_note-dartmouth-2\">Master theorem</a>.\r\n<pre>\r\nS(m)  = <img alt=\"\\theta\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"19\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-a372b7ef1ffaec3b4ad80e0141550990_l3.png\" style=\"vertical-align: 0px;\" title=\"Rendered by QuickLaTeX.com\" width=\"11\"/>(m)  \r\n      = <img alt=\"\\theta\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"19\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-a372b7ef1ffaec3b4ad80e0141550990_l3.png\" style=\"vertical-align: 0px;\" title=\"Rendered by QuickLaTeX.com\" width=\"11\"/>(logn)  /* Since n = 2^m */\r\n</pre>\r\n\r\nNow, let us go back to the original recursive function T(n)\r\n<pre>\r\n  T(n)  = T(2^m) = S(m)\r\n                 = <img alt=\"\\theta\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"19\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-a372b7ef1ffaec3b4ad80e0141550990_l3.png\" style=\"vertical-align: 0px;\" title=\"Rendered by QuickLaTeX.com\" width=\"11\"/>(Logn)\r\n</pre>\n<br/></div>",
        "keyword": "Analysis of Algorithms (Recurrences)"
    },
    {
        "question": "The running time of an algorithm is represented by the following recurrence relation:",
        "answer": "None",
        "correct": "None",
        "explain": "None",
        "keyword": "Analysis of Algorithms (Recurrences)"
    },
    {
        "question": "The running time of the following algorithm \r\n\r\n  Procedure A(n)  \r\n  If n <= 2 return(1) else return A();\r\n\r\nis best described by ",
        "answer": [
            "O(n) ",
            "O(log n) ",
            "O(1og log n) ",
            "O(1) "
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> For explanation, please see question 5 of <a href=\"https://www.geeksforgeeks.org/data-structures-and-algorithms-set-11/\">this post</a>\n</div>",
        "keyword": "Analysis of Algorithms (Recurrences)"
    },
    {
        "question": "\nWhat is the time complexity of the following recursive function:  \n\nc\n\n\nint DoSomething (int n) \n{\n  if (n <= 2)\n    return 1;\n  else  \n    return (DoSomething (floor(sqrt(n))) + n);\n}\n\n(A) (n) (B) (nlogn)(C) (logn)(D) (loglogn) \n",
        "answer": [
            "A",
            "B",
            "D",
            "C"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\">\n<p>Recursive relation for the DoSomething() is <br/> </p>\n<pre>  T(n) =  T(<img alt=\"\\sqrt{n}\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"28\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-fc274251fb2cd6a23502b3d0bd192eea_l3.png\" style=\"vertical-align: -7px;\" title=\"Rendered by QuickLaTeX.com\" width=\"37\"/>) + C1 if n &gt; 2  </pre>\n<p><br/>We have ignored the floor() part as it doesn't matter here if it's a floor or ceiling. <br/> </p>\n<pre>  Let n = 2^m,  T(n) = T(2^m)\n  Let T(2^m) =  S(m)\n\n  From the above two, T(n) = S(m)\n\n  S(m) = S(m/2) + C1  /* This is simply binary search recursion*/\n  S(m)  = O(logm)      \n          = O(loglogn)  /* Since n = 2^m */\n  \n  Now, let us go back to the original recursive function T(n) \n  T(n)  = S(m) \n          = O(LogLogn)</pre>\n<p><br/><br/> </p>\n</div>",
        "keyword": "Analysis of Algorithms (Recurrences)"
    },
    {
        "question": "The time complexity of the following C function is (assume n > 0 (GATE CS 2004) \r\n\r\n\r\nint recursive (mt n)\r\n{\r\n   if (n == 1)\r\n     return (1);\r\n   else\r\n     return (recursive (n-1) + recursive (n-1));\r\n}\r\n\n",
        "answer": [
            "0(n)",
            "\t0(nlogn)",
            "0(n^2)",
            "\t0(2^n)"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> Recursive expression for the above program will be.\r\n<pre>  T(n) = 2T(n-1) + c\r\n  T(1) = c1.</pre>\r\nLet us solve it.\r\n<pre>  T(n) = 2(2T(n-2) + c) + c        = 4T(n-2) + 3c\r\n  T(n) = 8T(n-3) + 6c + c          =  8T(n-3) + 7c\r\n  T(n) = 16T(n-4) + 14c + c        =  16T(n-4) + 15c\r\n  ............................................................\r\n  .............................................................\r\n  T(n) = (2^(n-1))T(1) +  (2^(n-1) - 1)c\r\n\r\n  T(n) = O(2^n)</pre>\n</div>",
        "keyword": "Analysis of Algorithms (Recurrences)"
    },
    {
        "question": "Consider the following recurrence\r\nT(n) = 3T(n/5) + lgn * lgn\r\n\r\nWhat is the value of T(n)? \r\n\r\n(A) \r\n(B) \r\n(c) \r\n(D) ",
        "answer": [
            "A",
            "B",
            "C",
            "D"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> By Case 1 of the Master Method, we have T(n) = Theta(n ^ (log5(3)) ). [^ is for power]</div>",
        "keyword": "Analysis of Algorithms (Recurrences)"
    },
    {
        "question": "Consider the following recurrence.\r\n\r\nT(n) = T() + \r\n\r\nWhat is the value of recurrence? \r\n\r\n\r\n(A) \r\n(B) \r\n(B) \r\n(B) \n",
        "answer": [
            "A",
            "B",
            "C",
            "D"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\">  Change of variables: let m = lg n. Recurrence becomes S(m) = S(m/2) + theta(lgm). Case 2 of master’s theorem applies, so T(n) = theta( (log Log n) ^ 2).</div>",
        "keyword": "Analysis of Algorithms (Recurrences)"
    },
    {
        "question": "Which one of the following correctly determines the solution of the recurrence relation with T(1) = 1?\r\nT(n) = 2T(n/2) + Logn \n",
        "answer": [
            "Θ(n) ",
            "Θ(nLogn) ",
            "Θ(n*n) ",
            "Θ(log n)"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>\r\n T(n) = 2T(n/2) + log n\r\n T(1) = 1\r\nSubstitute n = 2^k\r\n\r\nT(2^k)  = k + 2T(2^(k-1))\r\nT(2^k)  = k + 2(k-1) + 4T(2^(k-2))\r\n        = k + 2(k-1) + 4(K-2) + 8T(2^(k-3))\r\n        = k + 2(k-1) + 4(K-2) + 8(k-3) + 16T(2^(k-4))\r\n        = k + 2(k-1) + 4(K-2) + 8(k-3) + ...... + 2^kT(2^(k-k))\r\n        = k + 2(k-1) + 4(K-2) + 8(k-3) + .......+ 2^kT(1)\r\n        = k + 2(k-1) + 4(K-2) + 8(k-3) + .......+ 2^k  --------(1)\r\n\r\n2T(2^k) =     2k     + 4(k-1) + 8(K-2) + ...... + 2*2^k + 2^(k+1) --------(2)\r\n\r\nSubtracting 1 from 2, we get below\r\nT(2^k) = - k + 2 + 4 ......    2^(k-2) + 2^(k-1) + 2^k + 2^(k+1)\r\n           = - k + 2 * (1 + 2 + 4 + ..... 2^k)\r\n           = -k + [2*(2^k - 1)] / [2-1]\r\n           = -k + [2*(2^k - 1)]\r\n\r\nT(n) = -Logn + 2*(n - 1)\r\n\r\nT(n)  = Θ(n) </pre>\n</div>",
        "keyword": "Analysis of Algorithms (Recurrences)"
    },
    {
        "question": "Consider the following recurrence relation\r\n\r\nThe value of T(m2) for m ≥ 1 is",
        "answer": [
            "(m/6) (21m - 39) + 4",
            "(m/6) (4m2  - 3m + 5)",
            "(m/2) (m2.5 - 11m + 20) - 5",
            "(m/6) (5m3 - 34m2 + 137m - 104) + (5/6)"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>One easy way to solve this is to try putting different \r\nvalues of m.\r\n\r\nFor example, we know T(1) = 1. If we put m = 1, only A\r\nand B satisfy the result.\r\n\r\nm = 2\r\n\r\nT(2) = T(1) + 1 = 2\r\nT(3) = T(2) + 1 = 3\r\nT(4) = T(3) + 2 = 5\r\n\r\nBoth A &amp; B produce 5\r\n\r\nm = 3\r\nT(9) = T(4) + 2*5 + 1 = 5 + 10 + 1 = 16\r\nBoth A &amp; B produce 16\r\n\r\nm = 4\r\nT(16) = T(9) + 3*7 + 1 = 16 + 21 + 1 = 38\r\nOnly B produces 38, A produces 34 which doesn't match </pre></div>",
        "keyword": "Analysis of Algorithms (Recurrences)"
    },
    {
        "question": "The solution to the recurrence equation T(2k) = 3 T(2k-1) + 1, T (1) = 1, is:",
        "answer": [
            "2k",
            "(3k + 1 - 1)/2",
            "3log2"
        ],
        "correct": "B",
        "explain": "None",
        "keyword": "Analysis of Algorithms (Recurrences)"
    },
    {
        "question": "Select the correct asymptotic complexity of an algorithm with runtime T(n, n) where \r\nT(x, c) = Θ(x) for c <= 2,\r\nT(c, y) = Θ(y) for c <= 2, and\r\nT(x, y) = Θ(x+y) + T(x/2, y/2) \n",
        "answer": [
            "Θ(nLogn)",
            "Θ(n2)",
            "Θ(n)",
            "Θ(n2Logn)"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> The recurrence is <pre>\r\nT(x, y) = Θ(x+y) + T(x/2, y/2) \r\n</pre>\r\n\r\nIt can be written as below. <pre>\r\nT(x, y) = Θ(x+y) + Θ((x+y)/2) + Θ((x+y)/4) +  Θ((x+y)/8)  .....\r\nT(x, y) = Θ((x+y) + (x+y)/2 + (x+y)/4 + (x+y)/8  ..... )\r\n</pre>\r\n\r\nThe above expression forms a geometric series with ratio as 2 and starting element as (x+y)/2\r\n\r\nT(x, y) is upper bounded by Θ(x+y) as sum of infinite series is 2(x+y).    It is lower bounded by (x+y)\r\n\r\n\r\n\r\nSource: <a href=\"http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/assignments/MIT6_006F11_ps1.pdf\">http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/assignments/MIT6_006F11_ps1.pdf</a>\n</div>",
        "keyword": "Analysis of Algorithms (Recurrences)"
    },
    {
        "question": "Let f(n) = n and g(n) = n(1+sin n), where n is a positive integer. Which of the following statements is/are correct?\r\nI.  f(n) = O(g(n))\r\nII. f(n) = Ω(g(n))  ",
        "answer": [
            "Only I ",
            "Only II",
            "Both I and II ",
            "Neither I nor II"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> The value of <a href=\"http://en.wikipedia.org/wiki/Sine\">sine function</a> varies from -1 to 1.  \r\nFor sin = -1 or any other negative value, I becomes false.\r\nFor sin = 1 or any other positive value, II becomes false.\r\n</div>",
        "keyword": "Analysis of Algorithms (Recurrences)"
    },
    {
        "question": "Consider a list of recursive algorithms and a list of recurrence relations as shown below. Each recurrence relation corresponds to exactly one algorithm and is used to derive the time complexity of the algorithm.\r\n\n\n\nRecursive Algorithm\n\nRecurrence Relation\n\n\n\n\nP.\nBinary search\nI.\nT(n) = T(n-k) + T(k) + cn\n\n\nQ.\nMerge sort\nII.\nT(n) = 2T(n-1) + 1\n\n\nR.\nQuick sort\nIII.\nT(n) = 2T(n/2) + cn\n\n\nS.\nTower of Hanoi\nIV.\nT(n) = T(n/2) + 1\n\n\n",
        "answer": [
            "P-II, Q-III, R-IV, S-I",
            "P-IV, Q-III, R-I, S-II",
            "P-III, Q-II, R-IV, S-I",
            "P-IV, Q-II, R-I, S-III"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> <strong>These are examples of some standard algorithms whose </strong>\n<a href=\"http://geeksquiz.com/merge-sort/\" target=\"_blank\">Merge Sort</a>:    T(n) = 2T(n/2) + Θ(n). It falls in case 2 as c is 1 and Log<sub>b</sub>a] is also 1 and  the solution is Θ(n Logn) <em>//time complexity can be evaluated using Master Method</em>\n<a href=\"http://geeksquiz.com/binary-search/\" target=\"_blank\">Binary Search</a>: T(n) = T(n/2) + Θ(1). It also falls in case 2 as c is 0 and Log<sub>b</sub>a is also 0 and the solution is Θ(Logn) <em>//time complexity can be evaluated using Master Method</em>\n<a href=\"http://geeksquiz.com/quick-sort/\">Quick Sort </a>: Time taken by QuickSort in general can be written as  T(n) = T(k) + T(n-k-1) + <img alt=\"\\theta\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"19\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-a372b7ef1ffaec3b4ad80e0141550990_l3.png\" style=\"vertical-align: 0px;\" title=\"Rendered by QuickLaTeX.com\" width=\"11\"/>(n)\r\n\r\n<a href=\"http://geeksquiz.com/c-program-for-tower-of-hanoi/\">Tower of Hanoi</a> : T(n) = 2T(n-1) + 1\r\n\r\nRead More at :  <a href=\"http://www.geeksforgeeks.org/analysis-algorithm-set-4-master-method-solving-recurrences/\">http://www.geeksforgeeks.org/analysis-algorithm-set-4-master-method-solving-recurrences/</a></div>",
        "keyword": "Analysis of Algorithms (Recurrences)"
    },
    {
        "question": "Consider the recurrence relation a1 = 8,  an = 6n2 + 2n + an-1. Let a99 = k x 104.  The value of K is _____\r\n\r\n \r\nNote : This question was asked as Numerical Answer Type.\r\n",
        "answer": [
            "190",
            "296",
            "198",
            "200"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> a<sub>1</sub> = 8\r\na<sub>n</sub> = 6n<sup>2</sup> + 2n + a<sub>n-1</sub>\r\n \r\na<sub>n</sub> = 6[n<sup>2</sup> + (n-1)<sup>2</sup>] + 2[n + (n-1)] + a<sub>n-2</sub>\r\n \r\nContinuing the same way till n=2, we get\r\na<sub>n</sub> = 6[n<sup>2</sup> + (n-1)<sup>2</sup> + (n-2)<sup>2</sup> + ... + (2)<sup>2</sup>] + 2[n + (n-1) + (n-2) + ... + (2)] + a<sub>1</sub>\r\n \r\na<sub>n</sub> = 6[n<sup>2</sup> + (n-1)<sup>2</sup> + (n-2)<sup>2</sup> + ... + (2)<sup>2</sup>] + 2[n + (n-1) + (n-2) + ... + (2)] + 8\r\n \r\na<sub>n</sub> = 6[n<sup>2</sup> + (n-1)<sup>2</sup> + (n-2)<sup>2</sup> + ... + (2)<sup>2</sup>] + 2[n + (n-1) + (n-2) + ... + (2)] + 6 + 2\r\n \r\na<sub>n</sub> = 6[n<sup>2</sup> + (n-1)<sup>2</sup> + (n-2)<sup>2</sup> + ... + (2)<sup>2</sup> + <strong>1</strong>] + 2[n + (n-1) + (n-2) + ... + (2) + <strong>1</strong>]\r\n \r\na<sub>n</sub> = (n)*(n+1)*(2n+1) + (n)(n+1) = (n)*(n+1)*(2n+2)\r\n \r\na<sub>n</sub> = 2*(n)*(n+1)*(n+1) = 2*(n)*(n+1)<sup>2</sup>\r\n \r\nNow, put n=99.\r\na<sub>99</sub> =  2*(99)*(100)<sup>2</sup> = 1980000 = K * 10<sup>4</sup>\r\nTherefore, K = 198.\r\n \r\nThus, C is the correct choice.</div>",
        "keyword": "Analysis of Algorithms (Recurrences)"
    },
    {
        "question": "The given diagram shows the flowchart for a recursive function A(n). Assume that all statements, except for the recursive calls, have O(1) time complexity. If the worst case time complexity of this function is O(nα), then the least possible value (accurate up to two decimal positions) of α is __________\r\n",
        "answer": [
            "2.2 to 2.4",
            "3.2 to 3.4",
            "0  to 1.8",
            "1"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> The time complexity of a recurrence relation is the worst case time complexity. First we have to find out the number of function calls in worst case from the flow chart.\r\nThe worst case will be when all the conditions (diamond boxes) turn out towards non-returning paths taking the longest root. In the longest path we have 5 function calls.\r\n\r\n<a href=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2017/02/complexity1.png\"><img alt=\"complexity\" class=\"aligncenter size-full wp-image-31133\" height=\"326\" src=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2017/02/complexity1.png\" width=\"617\"/></a>\r\n\r\nSo the recurrence relation will be –\r\nA(n) = 5A(n/2) + O(1)       (O(1) because rest of the statements have O(1) complexity.)\r\nSolving this recurrence relation using Master theorem –\r\na = 5 , b= 2 , f(n) =O(1) , n<sup>log<sub>b</sub> a</sup>= n<sup>log<sub>2</sub> 5</sup>  (case 1 master theorem)\r\n      A(n) =n<sup>log<sub>b</sub> a </sup>\r\nvalue of log <sub>2</sub>5 is 2.3219, so, the best option is option a\r\n\r\nThis explanation has been contributed by <strong>Parul Sharma.</strong></div>",
        "keyword": "Analysis of Algorithms (Recurrences)"
    },
    {
        "question": "When n = 22k for some k ≥ 0, the recurrence relation\r\n\r\nT(n) = √(2) T(n/2) + √n, T(1) = 1\r\n\r\nevaluates to :",
        "answer": [
            "√(n) (log n + 1)",
            "√(n) (log n )",
            "√(n) log √(n)",
            "n log √(n)"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Please note that the question is asking about exact solution.  <a href=\"http://www.geeksforgeeks.org/analysis-algorithm-set-4-master-method-solving-recurrences/\">Master theorem</a> provides results in the form of <a href=\"http://www.geeksforgeeks.org/analysis-of-algorithms-set-3asymptotic-notations/\">asymptotic notations</a>.   So we can't apply Master theorem here.  We can solve this recurrence using simple expansion or recurrence tree method.\r\n\r\n<pre>\r\nT(n) = √(2) T(n/2) + √n\r\n     = √(2) [√(2) T(n/4) + √(n/2) ] + √n\r\n     = 2 T(n/4) + √2 √(n/2) +√n\r\n     = 2[ √2 T(n/8) + √(n/4) ]+√2 √(n/2)+√n\r\n     = √(2^3) T(n/8)+ 2 √(n/4) + √2 √(n/2) +√n\r\n     = √(2^3) T(n/8)+√n +√n +√n\r\n     = √(2^3) T(n/(2^3))+3√n\r\n     .............................................\r\n     = √(2^k) T(n/(2^k))+k√n\r\n     = √(2^logn) + logn √n\r\n     = √n + logn √n\r\n     = √n(logn +1)\r\n</pre>\n<strong>\r\nAlternate Solution : </strong>\r\nThis question can be easily done by substitution method look:\r\nT(1)= 1; GIVEN.\r\nNow use n=2 in the given recurrence relation which gives 2*(1.414) (since value of root over 2 is 1.414)\r\nnow by looking at the options use n=2 which satisfies option A.\r\n\r\n</div>",
        "keyword": "Analysis of Algorithms (Recurrences)"
    },
    {
        "question": "Let T(n) be the function defined by T(1)= 1, T(n)= 2T (⌊n/2⌋) + √n  for n≥2. Which of the following statement(s) is true?\r\n\r\na.  T(n) = O(√n)\r\nb.  T(n) = O(n)\r\nc.  T(n) = O(log n)\r\nd. None of the above",
        "answer": [
            "a",
            "b",
            "c",
            "d"
        ],
        "correct": "B",
        "explain": "None",
        "keyword": "Analysis of Algorithms (Recurrences)"
    },
    {
        "question": "Consider the following function\r\nFunction F (n, m: integer): integer;\r\nbegin\r\n    If (n<=0) or (m<=0) then F:=1\r\n    else\r\n      F:= F(n-1,m) + F(n, m-1);\r\n    end;\r\nUse the recurrence relation to answer the following question.\r\n\r\n\r\n \r\n\r\n \r\n\r\n \r\n\r\n \r\n\r\nAssume that n, m are positive integers. Write only the answers without any explanation.\r\na. What is the value of F(n,2)?\r\nb. What is the value of (n,m)?\r\nc. How many recursive calls are made to the function F, including the original call, when evaluating F(n,m).",
        "answer": "None",
        "correct": "None",
        "explain": "None",
        "keyword": "Analysis of Algorithms (Recurrences)"
    },
    {
        "question": "The recurrence relation\r\n T(1) = 2\r\n T(n) = 3T(n/4)+n\r\nhas the solution, T(n) equals to",
        "answer": [
            "O(n)",
            "O(log n)",
            "O(n^3/4)",
            "None of the above"
        ],
        "correct": "A",
        "explain": "None",
        "keyword": "Analysis of Algorithms (Recurrences)"
    },
    {
        "question": "The worst-case running time of Merge sort algorithm is described by the following recurrence relation :\r\n\r\n                 ⌈ 1               , if n = 1\r\n       T(n)  =   | 2T(n/2)+ n      , otherwise\r\n                 ⌊\r\nGiven recurrence equation evaluates to -",
        "answer": [
            "2k  T(n/2k) + kn",
            "2k  T(nk/2) + kn",
            "nk"
        ],
        "correct": "A",
        "explain": "None",
        "keyword": "Analysis of Algorithms (Recurrences)"
    },
    {
        "question": "Match the following and choose the correct answer in the order A, B, C\r\n\r\n\n\nA. Heap Construction\np. O(n log n)\n\n\nB. Hash table construction with linear probing\nq. O(n2)\n\n\nC. AVL Tree construction\nr. O(n)\n\n\r\n\r\n(Bounds given may or may not be asymptotically tight)",
        "answer": [
            "q, r, p",
            "p, q, r",
            "q, p, r",
            "r, q, p"
        ],
        "correct": "D",
        "explain": "None",
        "keyword": "Analysis of Algorithms (Recurrences)"
    },
    {
        "question": "Standard planning algorithms assume environment to be __________.",
        "answer": [
            "Both deterministic and fully observable",
            "Neither deterministic nor fully observable",
            "Deterministic but not fully observable",
            "Not deterministic but fully observable"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Standard planning algorithms assume environment to be both deterministic and fully observable.\r\nSo, option (A) is correct.</div>",
        "keyword": "Analysis of Algorithms (Recurrences)"
    },
    {
        "question": "Consider the following recurrence:\r\n\r\nT(n) = 2T(n1/2) + 1\r\nT(1) = 1\r\nWhich of the following is true?\r\n",
        "answer": [
            "T(n)= O(log log n)",
            "T(n) = O(log n)",
            "T(n) = O(n1/2)",
            "T(n)= O(n)"
        ],
        "correct": "B",
        "explain": "None",
        "keyword": "Analysis of Algorithms (Recurrences)"
    },
    {
        "question": "What is the time complexity for the following C module? Assume that n>0 .\r\nint module(int n)\r\n{\r\nif (n == 1)\r\nreturn 1;\r\nelse\r\nreturn (n + module(n-1));\r\n}",
        "answer": [
            "O(n)",
            "O(log n)",
            "O(n2)",
            "O(n!)"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> F(n) = (n + f(n-1)) --&gt; n + (n-1 + f(n-2)) --&gt; n + (n-1 + (n-2 (+...+ (n-(n-1) + f(1)))\r\nTime complexity of of code is = O(n)</div>",
        "keyword": "Analysis of Algorithms (Recurrences)"
    },
    {
        "question": "We can show that the clique problem is NP-hard by proving that",
        "answer": [
            "CLIQUE ≤ P 3-CNF_SAT",
            "CLIQUE ≤ P VERTEX_COVER",
            "CLIQUE ≤ P SUBSET_SUM",
            "None of the above"
        ],
        "correct": "D",
        "explain": "None",
        "keyword": "Analysis of Algorithms (Recurrences)"
    },
    {
        "question": "The running time of an algorithm is given by\r\n\r\nT(n) = T(n-1) + T(n-2) — T(n-3), if n > 3\r\n     = n, otherwise\r\n\r\nThen what should be the relation between T(1), T(2) and T(3), so that the order of the algorithm is constant ?",
        "answer": [
            "T(1) = T(2) = T(3)  ",
            " T(1) + T(3) = 2 * T(2)",
            " T(1) - T(3) = T(2)    ",
            "T(1) + T(2) = T(3)"
        ],
        "correct": "A",
        "explain": "None",
        "keyword": "Analysis of Algorithms (Recurrences)"
    },
    {
        "question": "For parameters a and b, both of which are ω(1), T(n)=T(n1/a)+1, and T(b)=1. Then T(n) is",
        "answer": [
            "Θ(logalogbn) ",
            "Θ(logabn)",
            "Θ(logblogan)",
            "Θ(log2log2n)"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Given,\r\n<pre>T(n) = T(n<sup>1/a</sup>)+1, \r\nT(b) = 1 </pre>\r\n\r\nNow, using iterative method,\r\n<pre>= T(n) \r\n= [T(n<sup>1/a<sup>2</sup></sup>)+1] + 1\r\n= [T(n<sup>1/a<sup>3</sup></sup>)+1] + 2\r\n= [T(n<sup>1/a<sup>4</sup></sup>)+1] + 3\r\n.\r\n.\r\n.\r\n= [T(n<sup>1/a<sup>k</sup></sup>)+1] + (k-1)\r\n= T(n<sup>1/a<sup>k</sup></sup>) + k </pre>\r\n\r\nLet,\r\n<pre>→ n<sup>1/a<sup>k</sup></sup> = b\r\n→ log(n<sup>1/a<sup>k</sup></sup>) = log(b)\r\n→ a<sup>k</sup> = log(n) / log (b) = log<sub>b</sub>(n)\r\n→ k = log<sub>a</sub>log<sub>b</sub>(n)</pre>\r\nTherefore,\r\n<pre>= T(n<sup>1/a<sup>k</sup></sup>) + k\r\n= T(b) + log<sub>a</sub>log<sub>b</sub>(n)\r\n= 1 + log<sub>a</sub>log<sub>b</sub>(n)\r\n= Θ(log<sub>a</sub>log<sub>b</sub>(n)) </pre>\r\n\r\nOption (A) is correct.</div>",
        "keyword": "Analysis of Algorithms (Recurrences)"
    },
    {
        "question": "Consider the following three functions.\r\n\r\nf1 = 10n\r\nf2 = nlogn\r\nf3 = n√n \r\nWhich one of the following options arranges the functions in the increasing order of asymptotic growth rate?",
        "answer": [
            "f3,f2,f1",
            "f2,f1,f3",
            "f1,f2,f3",
            "f2,f3,f1"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> On comparing power of these given functions :\r\nf1 has n in power.\r\nf2 has logn in power.\r\nf3 has √n in power.\r\n\r\nHence, f2, f3, f1 is in increasing order.\r\n\r\nNote that you can take the log of each function then compare.</div>",
        "keyword": "Analysis of Algorithms (Recurrences)"
    },
    {
        "question": "Consider the following recurrence relation.\r\n\r\n\r\nWhich one of the following options is correct?",
        "answer": [
            "T(n) = Θ(n5/2)",
            "T(n) = Θ(nlogn)",
            "T(n) = Θ(n)",
            "T(n) = Θ((logn)5/2)"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Given, recurrence relation can be written as,\r\nT(n) = T(n/2) + T(2n/5) + 7n\r\nT(n) = T((5/2)n/5) + T(2n/5) + 7n\r\n\r\nSince, sum of numerator (5/2+2 = 4.5) is less than denominator (5), so time complexity would be function itself.\r\n\r\nHence, T(n) = Θ(7n) = Θ(n)</div>",
        "keyword": "Analysis of Algorithms (Recurrences)"
    },
    {
        "question": "What is the worst-case number of arithmetic operations performed by recursive binary search on a sorted array of size n?",
        "answer": [
            "Θ(√n)",
            "Θ(log2(n))",
            "Θ(n2)",
            "Θ(n)"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Arithmetic operations performed by <a href=\"https://www.geeksforgeeks.org/binary-search/\" rel=\"noopener\" target=\"_blank\">binary search</a> on sorted data items means computation of mid element required arithmetic operation. So it will be computed log(n) time and Hence option (C) will be correct.</div>",
        "keyword": "Analysis of Algorithms (Recurrences)"
    },
    {
        "question": "For constants a≥1 and b>1, consider the following recurrence defined on the non-negative integers:\r\n\r\nT(n) = a⋅T(n/b) + f(n) \r\nWhich one of the following options is correct about the recurrence T(n)?\r\n\r\n",
        "answer": [
            "A",
            "B",
            "C",
            "D"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> It is one of the <a href=\"https://www.geeksforgeeks.org/advanced-master-theorem-for-divide-and-conquer-recurrences/\" rel=\"noopener\" target=\"_blank\">cases of Master's theorem</a>. </div>",
        "keyword": "Analysis of Algorithms (Recurrences)"
    },
    {
        "question": "Predict output of following program\r\n\r\n\r\n#include <stdio.h>\r\n\r\nint fun(int n)\r\n{\r\n    if (n == 4)\r\n       return n;\r\n    else return 2*fun(n+1);\r\n}\r\n\r\n\r\nint main()\r\n{\r\n   printf(\"%d \", fun(2));\r\n   return 0;\r\n}\r\n\r\n",
        "answer": [
            "4",
            "8",
            "16",
            "Runtime Error"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>\r\nFun(2) = 2 * Fun(3) and Fun(3) = 2 * Fun(4) ....(i)\r\nFun(4) = 4 ......(ii)\r\nFrom equation (i) and (ii),\r\nFun(2) = 2 * 2 * Fun(4)\r\nFun(2) = 2 * 2 * 4\r\nFun(2) = 16. \r\n\r\nSo, C is the correct answer</pre></div>",
        "keyword": "Recursion"
    },
    {
        "question": "Consider the following recursive function fun(x, y).  What is the value of fun(4, 3)\r\n\r\n\r\nint fun(int x, int y) \r\n{\r\n  if (x == 0)\r\n    return y;\r\n  return fun(x - 1,  x + y);\r\n} \r\n",
        "answer": [
            "13",
            "12",
            "9",
            "10"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> The function fun() calculates and returns ((1 + 2 … + x-1 + x) +y) which is x(x+1)/2 + y. </div>",
        "keyword": "Recursion"
    },
    {
        "question": "What does the following function print for n = 25?\r\n\r\n\r\nvoid fun(int n)\r\n{\r\n  if (n == 0)\r\n    return;\r\n\r\n  printf(\"%d\", n%2);\r\n  fun(n/2);\r\n}  \r\n",
        "answer": [
            "11001",
            "10011",
            "11111",
            "00000"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> The function mainly prints binary representation in reverse order.</div>",
        "keyword": "Recursion"
    },
    {
        "question": "What does the following function do?\r\n\r\n\r\nint fun(int x, int y)\r\n{\r\n    if (y == 0)   return 0;\r\n    return (x + fun(x, y-1));\r\n}\r\n",
        "answer": [
            "x + y",
            "x + x*y",
            "x*y",
            "xy"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> The function adds x to itself y times which is x*y.</div>",
        "keyword": "Recursion"
    },
    {
        "question": "What does fun2() do in general?\r\n\r\n\r\nint fun(int x, int y)\r\n{\r\n    if (y == 0)   return 0;\r\n    return (x + fun(x, y-1));\r\n}\r\n\r\nint fun2(int a, int b)\r\n{\r\n    if (b == 0) return 1;\r\n    return fun(a, fun2(a, b-1));\r\n}\r\n",
        "answer": [
            "x*y",
            "x+x*y",
            "xy",
            "yx"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> The function multiplies x to itself y times which is x<sup>y</sup>.</div>",
        "keyword": "Recursion"
    },
    {
        "question": "Output of following program?\r\n\r\n#include<stdio.h>\r\nvoid print(int n)\r\n{\r\n    if (n > 4000)\r\n        return;\r\n    printf(\"%d \", n);\r\n    print(2*n);\r\n    printf(\"%d \", n);\r\n}\r\n\r\nint main()\r\n{\r\n    print(1000);\r\n    getchar();\r\n    return 0;\r\n}\r\n",
        "answer": [
            "1000 2000 4000",
            "1000 2000 4000 4000 2000 1000",
            "1000 2000 4000 2000 1000",
            "1000 2000 2000 1000"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> First time n=1000\r\nThen 1000 is printed by first printf function then call print(2*1000) then again print 2000 by printf function then call print(2*2000) and it prints 4000 next time print(4000*2) is called. \r\n\r\nHere 8000 is greater than 4000 condition becomes true and it return at function(2*4000). Here n=4000 then 4000 will again print through second printf. \r\n\r\nSimilarly print(2*2000) after that n=2000 then 2000 will print and come back at print(2*1000) here n=1000, so print 1000 through second printf.\r\n\r\nOption (B) is correct.</div>",
        "keyword": "Recursion"
    },
    {
        "question": "What does the following function do?\r\n\r\n\r\nint fun(unsigned int n)\r\n{\r\n    if (n == 0 || n == 1)\r\n        return n;\r\n\r\n    if (n%3 != 0)\r\n        return 0;\r\n\r\n    return fun(n/3);\r\n}\r\n",
        "answer": [
            "It returns 1 when n is a multiple of 3, otherwise returns 0",
            "It returns 1 when n is a power of 3, otherwise returns 0",
            "It returns 0 when n is a multiple of 3, otherwise returns 1",
            "It returns 0 when n is a power of 3, otherwise returns 1"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Lets solve with example, n = 27 which power of 3.\r\nFirst time if condition is false as n is neither equal to 0 nor equal to 1 then 27%3 = 0. \r\nHere, again if condition false because it is equal to 0.\r\nThen fun(27/3) will call.\r\n\r\nSecond time if condition is false as n is neither equal to 0 nor equal to 1 then 9%3 = 0. \r\nHere again if condition false because it is equal to 0.\r\n\r\nThen fun (9/3) will call and third time if condition is false as n is neither equal to 0 nor equal to 1 then 3%3 = 0. \r\nHere again if condition false because it is equal to 0.\r\n\r\nThen fun(3/3) will call here n==1 if condition gets true and it return n i.e. 1.\r\n\r\nOption (B) is correct.</div>",
        "keyword": "Recursion"
    },
    {
        "question": "Predict the output of following program\r\n\r\n#include <stdio.h>\r\nint f(int n)\r\n{\r\n    if(n <= 1)\r\n        return 1;\r\n    if(n%2 == 0)\r\n        return f(n/2);\r\n    return f(n/2) + f(n/2+1);\r\n}\r\n\r\n\r\nint main()\r\n{\r\n    printf(\"%d\", f(11));\r\n    return 0;\r\n}\r\n",
        "answer": [
            "Stack Overflow",
            "3",
            "4",
            "5"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> On successive recursion F(11) will be decomposed into\r\nF(5) + F(6) -&gt; F(2) + F(3) + F(3)\r\n-&gt; F(1) + 2 * [F(1) + F(2)] -&gt; 1 + 2 * [1 + F(1)]\r\n-&gt; 1 + 2 * (1 + 1) -&gt; 5.\r\n\r\nHence , option D is the correct answer i.e, 5.</div>",
        "keyword": "Recursion"
    },
    {
        "question": "Consider the following recursive C function that takes two arguments\r\n\r\n\r\n unsigned int foo(unsigned int n, unsigned int r) {\r\n  if (n  > 0) return (n%r +  foo (n/r, r ));\r\n  else return 0;\r\n}\r\n\r\n\r\nWhat is the return value of the function foo when it is called as foo(345, 10) ?",
        "answer": [
            "345",
            "12",
            "5",
            "3"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> The call foo(345, 10) returns sum of decimal digits (because r is 10) in the number n. Sum of digits for 345 is 3 + 4 + 5 = 12.\r\n\r\n\r\n<a href=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2017/01/pranjul_43.png\"><img alt=\"pranjul_43\" class=\"alignnone size-full wp-image-29278\" height=\"479\" src=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2017/01/pranjul_43.png\" width=\"485\"/></a>\r\n\r\n\r\nThis solution is contributed by <strong>Pranjul Ahuja</strong></div>",
        "keyword": "Recursion"
    },
    {
        "question": "Consider the same recursive C function that takes two arguments\r\n\r\nunsigned int foo(unsigned int n, unsigned int r) {\r\n  if (n  > 0) return (n%r +  foo (n/r, r ));\r\n  else return 0;\r\n}\r\nWhat is the return value of the function foo when it is called as foo(513, 2)?",
        "answer": [
            "9",
            "8",
            "5",
            "2"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> foo(513, 2) will return 1 + foo(256, 2). All subsequent recursive calls (including foo(256, 2)) will return 0 + foo(n/2, 2) except the last call foo(1, 2) . The last call foo(1, 2) returns 1. So, the value returned by foo(513, 2) is 1 + 0 + 0…. + 0 + 1.\r\nThe function foo(n, 2) basically returns sum of bits (or count of set bits) in the number n.</div>",
        "keyword": "Recursion"
    },
    {
        "question": "#include<stdio.h>\r\nint f(int *a, int n)\r\n{\r\n  if(n <= 0) return 0;\r\n  else if(*a % 2 == 0) return *a + f(a+1, n-1);\r\n  else return *a - f(a+1, n-1);\r\n}\r\n \r\nint main()\r\n{\r\n  int a[] = {12, 7, 13, 4, 11, 6};\r\n  printf(\"%d\", f(a, 6));\r\n  getchar();\r\n  return 0;\r\n}",
        "answer": [
            "-9",
            "5",
            "15",
            "19"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> f() is a recursive function which adds f(a+1, n-1) to *a if *a is even. If *a is odd then f() subtracts f(a+1, n-1) from *a. See below recursion tree for execution of f(a, 6).\r\n.\r\n<pre> f(add(12), 6) /*Since 12 is first element. a contains address of 12 */\r\n    |\r\n    |\r\n 12 + f(add(7), 5) /* Since 7 is the next element, a+1 contains address of 7 */\r\n        |\r\n        |\r\n     7 - f(add(13), 4)\r\n              |\r\n              |\r\n           13 - f(add(4), 3)\r\n                     |\r\n                     |\r\n                  4 + f(add(11), 2)\r\n                             |\r\n                             |\r\n                           11 - f(add(6), 1)\r\n                                    |\r\n                                    |\r\n                                 6 + 0</pre>\r\nSo, the final returned value is 12 + (7 – (13 – (4 + (11 – (6 + 0))))) = 15</div>",
        "keyword": "Recursion"
    },
    {
        "question": "Output of following program?\r\n\r\n#include <stdio.h>\r\nint fun(int n, int *f_p)\r\n{\r\n    int t, f;\r\n    if (n <= 1)\r\n    {\r\n        *f_p = 1;\r\n        return 1;\r\n    }\r\n    t = fun(n- 1,f_p);\r\n    f = t+ * f_p;\r\n    *f_p = t;\r\n    return f;\r\n}\r\n\r\nint main()\r\n{\r\n    int x = 15;\r\n    printf (\" %d n\", fun(5, &x));\r\n    return 0;\r\n}\r\n",
        "answer": [
            "6",
            "8",
            "14",
            "15"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>Let x is stored at location 2468 i.e. &amp;x = 2468\r\n\r\n(dots are use just to ensure alignment)\r\nx = 15\r\nfun(5, 2468)\r\n...{t = fun(4, 2468)\r\n.......{t = fun(3, 2468)\r\n...........{t = fun(2,2468)\r\n...............{t = fun(1, 2468)\r\n...................{// x=1\r\n........................return 1}\r\n................t = 1\r\n................f = 2 //1+1 //since *f_p is x\r\n................x = t = 1\r\n................return 2}\r\n...........t = 2\r\n...........f = 2+1\r\n...........x = t = 2\r\n...........return 3}\r\n........t = 3\r\n........f = 3+2\r\n........x = t = 3\r\n........return 5}\r\n....t = 5\r\n....f = 5+3\r\n....x = t = 5\r\n....return 8}\r\n\r\nwhich implies fun (5,2468) is 8.</pre></div>",
        "keyword": "Recursion"
    },
    {
        "question": "Consider the following function\r\n\r\ndouble f(double x){\r\n  if (abs(x*x - 3) < 0.01) return x;\r\n  else return f(x/2 + 1.5/x);\r\n}\r\n\r\nGive a value q (to 2 decimals) such that f(q) will return q:_____.\r\n\r\n",
        "answer": [
            "1.73",
            "2.24",
            "4.22",
            "3.42"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> <a href=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2017/01/anil_ds_50.png\"><img alt=\"anil_ds_50\" class=\"alignnone size-full wp-image-29809\" height=\"695\" src=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2017/01/anil_ds_50.png\" width=\"583\"/></a>\n<a href=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2017/01/anil_ds_50_1.png\"><img alt=\"anil_ds_50_1\" class=\"alignnone size-full wp-image-29810\" height=\"465\" src=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2017/01/anil_ds_50_1.png\" width=\"588\"/></a><br/>\r\n\r\n\r\nThis solution is contributed by <strong>Anil Saikrishna Devarasetty</strong>\n<!--\r\n<strong>Another One:</strong>\r\nThe main thing to note is the expression “abs(x*x - 3) &lt; 0.01\" inside the if condition. The function would return x when x<sup>2</sup> is close to 0 (smaller than 0.01) which means when x is close to square root of 3. Square root of 3 is 1.732.--></div>",
        "keyword": "Recursion"
    },
    {
        "question": "Consider the C function given below.\r\n\r\n\r\nint f(int j)\r\n{\r\n  static int i = 50;\r\n  int k;\r\n  if (i == j)\r\n  {\r\n    printf(“something”);\r\n    k = f(i);\r\n    return 0;\r\n  }\r\n  else return 0;\r\n}\r\n\r\nWhich one of the following is TRUE?\r\n\r\n",
        "answer": [
            "The function returns 0 for all values of j.",
            "The function prints the string something for all values of j.",
            "The function returns 0 when j = 50.",
            "The function will exhaust the runtime stack or run into an infinite loop when j = 50"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> When j is 50, the function would call itself again and again as neither i nor j is changed inside the recursion.</div>",
        "keyword": "Recursion"
    },
    {
        "question": "\r\n#include<stdio.h>\r\nvoid crazy(int n,int a,int b)\r\n{\r\n    if (n <= 0)  return;\r\n    crazy(n-1, a, b+n);\r\n    printf(\"%d %d %dn\",n,a,b);\r\n    crazy(n-1, b, a+n);\r\n}\r\n\r\nint main()\r\n{\r\n    crazy(3,4,5);\r\n    return 0;\r\n}\r\n",
        "answer": [
            "\r\n1 4 10\r\n2 4 8\r\n1 8 6\r\n3 4 5\r\n1 5 9\r\n2 5 7\r\n1 7 7",
            "\r\n3 4 5\r\n1 4 10\r\n2 4 8\r\n1 8 6\r\n1 5 9\r\n2 5 7\r\n1 7 7",
            "\n\r\n1 4 10\r\n2 4 8\r\n1 8 6\r\n3 4 5",
            "3 4 5\r\n1 5 9\r\n2 5 7\r\n1 7 7"
        ],
        "correct": "A",
        "explain": "None",
        "keyword": "Recursion"
    },
    {
        "question": "Consider the following C function:\r\n\r\nint f(int n)\r\n{\r\n   static int i = 1;\r\n   if (n >= 5)\r\n      return n;\r\n   n = n+i;\r\n   i++;\r\n   return f(n);\r\n}\r\n\r\n\r\nThe value returned by f(1) is \r\n",
        "answer": [
            "5",
            "6",
            "7",
            "8"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> See Question 3 of <a href=\"http://www.geeksforgeeks.org/c-language-set-2/\" target=\"_blank\">http://www.geeksforgeeks.org/c-language-set-2/</a></div>",
        "keyword": "Recursion"
    },
    {
        "question": "Consider the following C function.\r\n\r\nint fun (int n)\r\n{\r\n  int x=1, k;\r\n  if (n==1) return x;\r\n  for (k=1; k < n; ++k)\r\n     x = x + fun(k) * fun(n – k);\r\n  return x;\r\n}\r\n\r\nThe return value of fun(5) is __________.\r\n\r\n",
        "answer": [
            "0",
            "26",
            "51",
            "71"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>\r\nfun(5) = 1 + fun(1) * fun(4) + fun(2) * fun(3) + \r\n             fun(3) * fun(2) + fun(4) * fun(1)\r\n       = 1 + 2*[fun(1)*fun(4) + fun(2)*fun(3)]\r\n\r\nSubstituting fun(1) = 1\r\n       = 1 + 2*[fun(4) + fun(2)*fun(3)]\r\n\r\nCalculating fun(2), fun(3) and fun(4)\r\nfun(2) = 1 + fun(1)*fun(1) = 1 + 1*1 = 2\r\nfun(3) = 1 + 2*fun(1)*fun(2) = 1 + 2*1*2 = 5\r\nfun(4) = 1 + 2*fun(1)*fun(3) + fun(2)*fun(2)\r\n       = 1 + 2*1*5 + 2*2 = 15\r\n\r\nSubstituting values of fun(2), fun(3) and fun(4)\r\nfun(5) = 1 + 2*[15 + 2*5] = 51 </pre>\n</div>",
        "keyword": "Recursion"
    },
    {
        "question": "Consider the following recursive C function.  If get(6) function is being called in main() then how many times will the get() function be invoked before returning to the main()?\r\n\r\n\r\nvoid get (int n)\r\n{\r\n   if (n < 1) return;\r\n   get(n-1);\r\n   get(n-3);\r\n   printf(\"%d\", n);\r\n}\r\n",
        "answer": [
            "15",
            "25",
            "35 ",
            "45"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>                              get(6) [25 Calls]\r\n                              /      \\\r\n               [17 Calls] get(5)       <span style=\"color: #ff0000;\">get(3)</span> [7 Calls]\r\n                        /     \\\r\n                    get(4)    <span style=\"color: #0000ff;\">get(2)</span>[5 Calls]\r\n                   /    \\ \r\n     [7 Calls] <span style=\"color: #ff0000;\">get(3)</span>  <span style=\"color: #ff9900;\">get(1)<span style=\"color: #000000;\">[3 Calls]</span></span>\r\n                /     \\\r\n             <span style=\"color: #0000ff;\"><strong>get(2)</strong></span>   get(0)\r\n            /    \\\r\n[3 Calls]<span style=\"color: #ff9900;\">get(1)</span>  get(-1) \r\n   /  \\\r\nget(0) get(-2)</pre>\r\n\r\nWe can verify the same by running below program.\r\n[sourcecode language=\"CPP\"]\r\n# include <stdio.h>\r\nint count = 0;\r\n\r\nvoid get (int n)\r\n{\r\n    count++;\r\n    if (n &lt; 1) return;\r\n    get(n-1);\r\n    get(n-3);\r\n}\r\nint main()\r\n{\r\n    get(6);\r\n    printf(\"%d \", count);\r\n}\r\n[/sourcecode]\r\n\r\nOutput: 25</stdio.h></div>",
        "keyword": "Recursion"
    },
    {
        "question": "What will be the output of the following C program?\r\n\r\nvoid count(int n)\r\n{\r\n    static int d = 1;\r\n    printf(\"%d \", n);\r\n    printf(\"%d \", d);\r\n    d++;\r\n    if(n > 1) count(n-1);\r\n    printf(\"%d \", d);\r\n}\r\nint main()\r\n{\r\n    count(3);\r\n}\r\n\n",
        "answer": [
            "  3 1 2 2 1 3 4 4 4",
            "  3 1 2 1 1 1 2 2 2",
            "  3 1 2 2 1 3 4",
            " 3 1 2 1 1 1 2"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>\r\ncount(3) will print value of n and d. So 3 1 will be printed \r\nand d will become 2. \r\n\r\nThen count(2) will be called. It will print value of n and d. \r\nSo 2 2 will be printed and d will become 3. \r\n\r\nThen count(1) will be called. It will print value of n and d.\r\nSo 1 3 will be printed and d will become 4. \r\n\r\nNow count(1) will print value of d which is 4. count(1) will \r\nfinish its execution. \r\n\r\nThen count(2) will print value of d which is 4. \r\n\r\nSimilarly, count(3) will print value of d which is 4. \r\nSo series will be A.\r\n</pre>\n<iframe allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen=\"\" frameborder=\"0\" height=\"315\" src=\"https://www.youtube.com/embed/Key2RKhzRGY?start=2035\" title=\"YouTube video player\" width=\"560\"></iframe></div>",
        "keyword": "Recursion"
    },
    {
        "question": "The function f is defined as follows:\r\n\r\nint f (int n) {\r\n    if (n <= 1) return 1;\r\n    else if (n % 2  ==  0) return f(n/2);\r\n    else return f(3n - 1);\r\n}\r\n\r\nAssuming that arbitrarily large integers can be passed as a parameter to the function, consider the following statements.\r\n1.   The function f terminates for finitely many different values of n ≥ 1.\r\nii.  The function f terminates for infinitely many different values of n ≥ 1.\r\niii. The function f does not terminate for finitely many different values of n ≥ 1.\r\niv.  The function f does not terminate for infinitely many different values of n ≥ 1.\r\nWhich one of the following options is true of the above?",
        "answer": [
            "(i) and (iii)",
            "(i) and (iv)",
            "(ii) and (iii)",
            "(ii) and (iv)"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> The function terminates for all values having a factor of 2 {(2.x)2==0}<br/>\r\nSo, (i) is false and (ii) is TRUE.<br/>\r\nLet n = 3, it will terminate in 2nd iteration.<br/>\r\nLet n=5, it will go like 5 - 14 - 7 - 20 - 10 - 5 – and now it will repeat.<br/>\r\nAnd any number with a factor of 5 and 2, there are infinite recursions possible.<br/>\r\nSo, (iv) is TRUE and (iii) is false.\r\n</div>",
        "keyword": "Recursion"
    },
    {
        "question": "Consider the code fragment written in C below :\r\n\r\nvoid f (int n)\r\n{ \r\n  if (n <=1)  {\r\n   printf (\"%d\", n);\r\n  }\r\n  else {\r\n   f (n/2);\r\n   printf (\"%d\", n%2);\r\n  }\r\n}\r\nWhat does f(173) print?\r\n",
        "answer": [
            "010110101",
            "010101101",
            "10110101",
            "10101101"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> (173)<sub>2</sub> = 10101101</div>",
        "keyword": "Recursion"
    },
    {
        "question": "Consider the code fragment written in C below :\r\n\r\n\r\nvoid f (int n)\r\n{\r\n    if (n <= 1)  {\r\n        printf (\"%d\", n);\r\n    }\r\n    else {\r\n        f (n/2);\r\n        printf (\"%d\", n%2);\r\n    }\r\n}\r\n \r\n\r\nWhich of the following implementations will produce the same output for f(173) as the above code?\r\nP1\r\n\r\n\r\nvoid f (int n)\r\n{\r\n    if (n/2)  {\r\n        f(n/2);\r\n    }\r\n    printf (\"%d\", n%2);\r\n}\r\n \r\n\r\nP2\r\n\r\n\r\n\r\nvoid f (int n)\r\n{\r\n    if (n <=1)  {\r\n        printf (\"%d\", n);\r\n    }\r\n    else {\r\n        printf (\"%d\", n%2);\r\n        f (n/2);\r\n    }\r\n}\r\n\r\n\n",
        "answer": [
            "Both P1 and P2",
            "P2 only",
            "P1 only",
            "Neither P1 nor P2"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\">  \r\n\r\n<span style=\"font-size: small;\">Here, basically the function f prints the binary representation of the number.\r\n</span> <span style=\"font-size: small;\">function f1 also prints the binary representation of the number\r\n</span> <span style=\"font-size: small;\">function f2 prints the binary representation but in reverse order.\r\nOutput of f  is:- 10101101\r\nOutput of f1 is:- 10101101\r\nOutput of f2 is:- 10110101</span>\n<span style=\"font-size: small;\">So, the answer is option (C) which is P1 only.\r\n\r\nThis solution is contributed  by <span class=\"im\"><b class=\"gmail_sendername\">Anil Saikrishna Devarasetty</b></span>.\r\n</span></div>",
        "keyword": "Recursion"
    },
    {
        "question": "A program is called reentrant if it can be interrupted in the middle of its execution, and then be safely called again (\"re-entered\") before its previous invocations complete execution. The interruption could be caused by an internal action such as a jump or call, or by an external action such as an interrupt or signal. Once the reentered invocation completes, the previous invocations will resume correct execution.\r\n\r\nWhich of the following program is not reentrant ?\r\n\r\n",
        "answer": [
            "\r\nint t;\r\n\r\nvoid swap(int *x, int *y)\r\n{\r\n    t = *x;\r\n    *x = *y;\r\n\r\n    // hardware interrupt might invoke isr() here!\r\n    *y = t;\r\n}\r\n\r\nvoid isr()\r\n{\r\n    int x = 1, y = 2;\r\n    swap(&x, &y);\r\n}\r\n",
            "\r\nint t;\r\n\r\nvoid swap(int *x, int *y)\r\n{\r\n    int s;\r\n\r\n    s = t; // save global variable\r\n    t = *x;\r\n    *x = *y;\r\n\r\n    // hardware interrupt might invoke isr() here!\r\n    *y = t;\r\n    t = s; // restore global variable\r\n}\r\n\r\nvoid isr()\r\n{\r\n    int x = 1, y = 2;\r\n    swap(&x, &y);\r\n}\r\n",
            "\r\nvoid swap(int *x, int *y)\r\n{\r\n    int t = *x;\r\n    *x = *y;\r\n\r\n    // hardware interrupt might invoke isr() here!\r\n    *y = t;\r\n}\r\n\r\nvoid isr()\r\n{\r\n    int x = 1, y = 2;\r\n    swap(&x, &y);\r\n}\r\n",
            "None of these"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Code given in option (A) of a swap() function that fails to be reentrant. </div>",
        "keyword": "Recursion"
    },
    {
        "question": "Match the pairs in the following questions:\r\n\n",
        "answer": [
            "A – 2, B – 1, C – 4, D – 3 ",
            "A – 3, B – 4, C – 1, D – 2 ",
            "A – 3, B – 1, C – 4, D – 2 ",
            "A – 2, B – 4, C – 1, D – 3 "
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Correct matching is A – 3, B – 1, C – 4, D – 2 \r\nOption (C) is correct.</div>",
        "keyword": "Recursion"
    },
    {
        "question": "In general, in a recursive and non-recursive implementation of a problem (program) :",
        "answer": [
            "Both time and space complexities are better in recursive than in non-recursive program.",
            "Both time and space complexities are better in non-recursive than in recursive program",
            "Time complexity is better in recursive version but space complexity is better in non-recursive version of the program.",
            "Space complexity is better in recursive version but time complexity is better in non-recursive version of the program."
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> In general, in a recursive and non-recursive implementation of a problem (program) both time and space complexities are better in non-recursive than in recursive program. In some program recursive implementation gives worst case scenario too. So, recursive implementation does not guarantee for best case all the time.\r\nSo, optipon (B) is correct.  </div>",
        "keyword": "Recursion"
    },
    {
        "question": "The solution of the recurrence relation\r\nT(m) = T(3m / 4) + 1 is :",
        "answer": [
            "θ (lg m)",
            "θ (m)",
            "θ (mlg m)",
            "θ (lglg m)"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Given,\r\n<pre>T(m) \r\n= T(3m/4) + 1\r\n= T(m/(4/3)) + 1 </pre>\r\nIn this problem we use <a href=\"https://www.geeksforgeeks.org/analysis-algorithm-set-4-master-method-solving-recurrences/\" rel=\"noopener\" target=\"_blank\">Master's Theorem</a>:\r\n<pre>T(m) = aT(m/b) + n^k logn </pre>\r\nCompare both equation, \r\n<pre>we get a = 1 and b = 4/3 and k=0 </pre>\r\nNow find (log a base b), i.e., (log 1 base 4/3), which is greater than (4/3)<sup>0</sup>\r\nAnd whenever, (log<sub>b</sub>(a)) and b<sup>k</sup> is greater than answer is f(m)* log(m)\r\nHere, f(m) = 1\r\nHence, correct answer 1*log(m) = log(m)</div>",
        "keyword": "Recursion"
    },
    {
        "question": "What is the return value of following function for arr[] = {9, 12, 2, 11, 2, 2, 10, 9, 12, 10, 9, 11, 2} and n is size of this array.\r\n\r\n\r\nint fun(int arr[], int n)\r\n{\r\n    int x = arr[0];\r\n    for (int i = 1; i < n; i++)\r\n        x = x ^ arr[i];\r\n    return x;\r\n}\r\n",
        "answer": [
            "0",
            "9",
            "12",
            "2"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Note that 9 is the only element with odd occurrences, all other elements have even occurrences.\r\n\r\nIf the input array has all elements with even occurrences except one, then the function returns the only element with odd occurrences.  Note that XORing an element with itself results 0 and XOR of 0 with a number x is equal to x.\r\n\r\nTry following complete program.\r\n<pre>\r\n# include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nint fun(int arr[], int n)\r\n{\r\n    int x = arr[0];\r\n    for (int i = 1; i &lt; n; i++)\r\n        x = x ^ arr[i];\r\n    return x;\r\n}\r\n\r\nint main()\r\n{\r\n  int arr[] = {9, 12, 2, 11, 10, 9, 12, 10, 9, 11, 2};\r\n  int n = sizeof(arr)/sizeof(arr[0]);\r\n  cout &lt;&lt; fun(arr, n) &lt;&lt; endl;\r\n  return 0;\r\n}</pre>\n</div>",
        "keyword": "Bit Algorithms"
    },
    {
        "question": "What does the following C expression do?\r\n\r\nx = (x<<1) + x + (x>>1);",
        "answer": [
            "Multiplies an integer with 7",
            "Multiplies an integer with 3.5",
            "Multiplies an integer with 3",
            "Multiplies an integer with 8"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> The expression multiplies an integer with 3.5.  For example, if x is 4, the expression returns 15. If x is 6, it returns 21.  If x is 5, it return 17.  See <a href=\"http://www.geeksforgeeks.org/multiply-an-integer-with-3-5/\" target=\"_blank\">Multiply a given Integer with 3.5</a> for more details.</div>",
        "keyword": "Bit Algorithms"
    },
    {
        "question": "What does the following C expression do?\r\n\r\n x = x & (x-1) ",
        "answer": [
            "Sets all bits as 1",
            "Makes x equals to 0",
            "Turns of the rightmost set bit",
            "Turns of the leftmost set bit"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> The expression simply turns off the rightmost set bit. For example, if x = 14 (1110), x - 1 = 13 (1101) it returns resultant as (1100) i.e, 12 .</div>",
        "keyword": "Bit Algorithms"
    },
    {
        "question": "Given two arrays of numbers a1, a2, a3,...an and b1, b2, .. bn where each number is 0 or 1, the fastest algorithm to find the largest span(i, j) such that ai + ai+1, ....aj = bi +  bi+1, .. bj. or report that there is not such span,",
        "answer": [
            "Takes O(n3) and Ω(2n) time if hashing is permitted",
            "Takes O(n3) and Ω(n2.5) time in the key comparison model",
            " Takes θ(n) time and space",
            " Takes O(√n) time only if the sum of the 2n elements is an even number"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> The problem can be solved in  Takes θ(n) time and space.\r\n\r\n<strong>The idea is based on below observations.</strong>\n<ol>\n<li>Since there are total n elements, maximum sum is n for both arrays.</li>\n<li>Difference between two sums varies from <strong>-n</strong> to <strong>n</strong>. So there are total 2n + 1 possible values of difference.</li>\n<li>If differences between prefix sums of two arrays become same at two points, then subarrays between these two points have same sum.</li>\n</ol>\r\nBelow is Complete Algorithm.\r\n<ol>\n<li>Create an auxiliary array of size 2n+1 to store starting points of all possible values of differences (Note that possible values of differences vary from -n to n, i.e., there are total 2n+1 possible values)</li>\n<li>Initialize starting points of all differences as -1.</li>\n<li>Initialize <strong>maxLen</strong> as 0 and prefix sums of both arrays as 0, <strong>preSum1</strong> = 0, <strong>preSum2</strong> = 0</li>\n<li>Traverse both arrays from i = 0 to n-1.\r\n<ol>\n<li type=\"a\">Update prefix sums: preSum1 += arr1[i], preSum2 += arr2[i]</li>\n<li type=\"a\">Compute difference of current prefix sums: <strong>curr_diff </strong>= preSum1 – preSum2</li>\n<li type=\"a\">Find index in diff array: <strong>diffIndex</strong> = n + curr_diff // curr_diff can be negative and can go till -n</li>\n<li type=\"a\"><strong>If</strong> curr_diff is 0, then i+1 is maxLen so far</li>\n<li type=\"a\"><strong>Else If</strong> curr_diff is seen first time, i.e., starting point of current diff is -1, then update starting point as i</li>\n<li type=\"a\"><strong>Else</strong> (curr_diff is NOT seen first time), then consider i as ending point and find length of current same sum span. If this length is more, then update maxLen</li>\n</ol>\n</li>\n<li>Return maxLen</li>\n</ol>\n<strong>See<a href=\"http://www.geeksforgeeks.org/longest-span-sum-two-binary-arrays/\"> Longest Span with same Sum in two Binary arrays</a> for complete running code</strong></div>",
        "keyword": "Bit Algorithms"
    },
    {
        "question": "Consider the following code snippet for checking whether a number is power of 2 or not.\r\n\r\n\r\n/* Incorrect function to check if x is power of 2*/\r\nbool isPowerOfTwo (unsigned int x) \r\n{ \r\n  return (!(x&(x-1))); \r\n} \r\n\r\nWhat is wrong with above function?",
        "answer": [
            "It does reverse of what is required",
            "It works perfectly fine for all values of x.",
            "It does not work for x  = 0",
            "It does not work for x = 1"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Please see <a href=\"https://www.geeksforgeeks.org/program-to-find-whether-a-no-is-power-of-two/\">https://www.geeksforgeeks.org/program-to-find-whether-a-no-is-power-of-two/</a></div>",
        "keyword": "Bit Algorithms"
    },
    {
        "question": "Which of the following algorithms can be used to most efficiently determine the presence of a cycle in a given graph ?",
        "answer": [
            "Depth First Search",
            "Breadth First Search",
            "Prim's Minimum Spanning Tree Algorithm",
            "Kruskal' Minimum Spanning Tree Algorithm"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> See<a href=\"http://www.geeksforgeeks.org/applications-of-depth-first-search/\"> http://www.geeksforgeeks.org/applications-of-depth-first-search/</a> and <a href=\"http://www.geeksforgeeks.org/depth-first-traversal-for-a-graph/\">http://www.geeksforgeeks.org/depth-first-traversal-for-a-graph/</a></div>",
        "keyword": "Graph Traversals"
    },
    {
        "question": "Traversal of a graph is different from tree because",
        "answer": [
            "There can be a loop in graph so we must maintain a visited flag for every vertex",
            "DFS of a graph uses stack, but inorrder traversal of a tree is recursive",
            "BFS of a graph uses queue, but a time efficient BFS of a tree is recursive.",
            "All of the above"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> See <a href=\"http://www.geeksforgeeks.org/depth-first-traversal-for-a-graph/\">http://www.geeksforgeeks.org/depth-first-traversal-for-a-graph/</a></div>",
        "keyword": "Graph Traversals"
    },
    {
        "question": "What are the appropriate data structures for following algorithms?\r\n\r\n1) Breadth First Search                           \r\n2) Depth First Search                            \r\n3) Prim's Minimum Spanning Tree                 \r\n4) Kruskal' Minimum Spanning Tree                \r\n\n",
        "answer": [
            "\r\n1) Stack\r\n2) Queue\r\n3) Priority Queue\r\n4) Union Find",
            "\r\n1) Queue\r\n2) Stack\r\n3) Priority Queue\r\n4) Union Find\r\n\n",
            "\r\n1) Stack\r\n2) Queue\r\n3) Union Find\r\n4) Priority Queue ",
            "\r\n1) Priority Queue\r\n2) Queue\r\n3) Stack\r\n4) Union Find\n"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> 1) <a href=\"http://www.geeksforgeeks.org/breadth-first-traversal-for-a-graph/\">Breadth First Search</a> uses <a href=\"http://geeksquiz.com/queue-set-1introduction-and-array-implementation/\">Queue</a>                          \r\n2) <a href=\"http://www.geeksforgeeks.org/depth-first-traversal-for-a-graph/\">Depth First Search</a> uses <a href=\"http://geeksquiz.com/stack-set-1/\">Stack</a>                           \r\n3) <a href=\"http://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-minimum-spanning-tree-mst-2/\">Prim's Minimum Spanning Tree</a> uses Priority Queue.                \r\n4) <a href=\"http://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/\">Kruskal' Minimum Spanning Tree</a> uses <a href=\"http://www.geeksforgeeks.org/union-find/\">Union Find</a>.</div>",
        "keyword": "Graph Traversals"
    },
    {
        "question": "The Breadth First Search algorithm has been implemented using the queue data structure. One possible order of visiting the nodes of the following graph is\r\n\n",
        "answer": [
            "MNOPQR ",
            "NQMPOR",
            "QMNPRO ",
            "QMNPOR"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Option (A) is MNOPQR.  It cannot be a BFS as the traversal starts with M, but O is visited before N and Q.  In BFS all adjacent must be visited before adjacent of adjacent.\r\n\r\nOption (B) is NQMPOR.  It also cannot be BFS, because here, P is visited before O.\r\n\r\n(C) and (D) match up to QMNP. We see that M was added to the queue before N and P (because M comes before NP in QMNP). Because R is M's neighbor, it gets added to the queue before the neighbor of N and P (which is O). Thus, R is visited before O.\r\n\r\n</div>",
        "keyword": "Graph Traversals"
    },
    {
        "question": "Let G be an undirected graph. Consider a depth-first traversal of G, and let T be the resulting depth-first search tree.  Let u be a vertex in G and let v be the first new (unvisited) vertex visited after visiting u in the traversal.  Which of the following statements is always true? (GATE CS 2000)",
        "answer": [
            "{u,v} must be an edge in G, and u is a descendant of v in T",
            " {u,v} must be an edge in G, and v is a descendant of u in T",
            "If {u,v} is not an edge in G then u is a leaf in T",
            "If {u,v} is not an edge in G then u and v must have the same parent in T\r\n"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>In <a href=\"http://www.geeksforgeeks.org/depth-first-traversal-for-a-graph/\">DFS</a>, if 'v' is visited\r\nafter 'u', then one of the following is true.\r\n1) (u, v) is an edge.\r\n     u\r\n   /   \\\r\n  v     w\r\n /     / \\\r\nx     y   z\r\n\r\n2) 'u' is a leaf node.\r\n     w\r\n   /   \\\r\n  x     v\r\n /     / \\\r\nu     y   z </pre>\r\n\r\nIn <a href=\"http://www.geeksforgeeks.org/depth-first-traversal-for-a-graph/\">DFS</a>, after visiting a node</div>",
        "keyword": "Graph Traversals"
    },
    {
        "question": "Consider the following graph,\r\n\n\n\r\n\r\nAmong the following sequences:\r\n(I) a b e g h f \r\n(II) a b f e h g\r\n(III) a b f h g e \r\n(IV) a f g h b e  \r\nWhich are depth first traversals of the above graph? ",
        "answer": [
            "I, II and IV only ",
            " I and IV only ",
            "II, III and IV only ",
            "I, III and IV only "
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> We can check all DFSs for following properties.\r\n\r\n<pre>In <a href=\"http://www.geeksforgeeks.org/depth-first-traversal-for-a-graph/\">DFS</a>, if a vertex 'v' is visited\r\nafter 'u', then one of the following is true.\r\n1) (u, v) is an edge.\r\n     u\r\n   /   \\\r\n  v     w\r\n /     / \\\r\nx     y   z\r\n\r\n2) 'u' is a leaf node.\r\n     w\r\n   /   \\\r\n  x     v\r\n /     / \\\r\nu     y   z</pre>\r\nIn <a href=\"http://www.geeksforgeeks.org/depth-first-traversal-for-a-graph/\">DFS</a>, after visiting a node, we first recur for all unvisited children. If there are no unvisited children (u is leaf), then control goes back to parent and parent then visits next unvisited children.</div>",
        "keyword": "Graph Traversals"
    },
    {
        "question": "Make is a utility that automatically builds executable programs and libraries from source code by reading files called makefiles which specify how to derive the target program.  Which of the following standard graph algorithms is used by Make.",
        "answer": [
            "Strongly Connected Components",
            "Topological Sorting",
            "Breadth First Search",
            "Dijkstra's Shortest Path"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Make can decide the order of building a software using topological sorting.   Topological sorting produces the order considering all dependencies provide by makefile. See following for details. \r\n\r\n<a href=\"http://www.geeksforgeeks.org/topological-sorting/\" target=\"_blank\">Topological Sorting</a></div>",
        "keyword": "Graph Traversals"
    },
    {
        "question": "Given two vertices in a graph s and t, which of the two traversals (BFS and DFS) can be used to find if there is path from s to t?",
        "answer": [
            "Only BFS",
            "Only DFS",
            "Both BFS and DFS",
            "Neither BFS nor DFS"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> We can use both traversals to find if there is a path from s to t.</div>",
        "keyword": "Graph Traversals"
    },
    {
        "question": "Which of the following condition is sufficient to detect cycle in a directed graph?",
        "answer": [
            "There is an edge from currently being visited node to an already visited node.",
            "There is an edge from currently being visited node to an ancestor of currently visited node in DFS forest. ",
            "Every node is seen twice in DFS.",
            "None of the bove"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> See <a href=\"http://www.geeksforgeeks.org/detect-cycle-in-a-graph/\" target=\"_blank\">Detect Cycle in a Graph</a></div>",
        "keyword": "Graph Traversals"
    },
    {
        "question": "Is following statement true/false\r\n\r\nIf a DFS of a directed graph contains a back edge, any other DFS of the same graph will also contain at least one back edge.\r\n\r\nSource: http://courses.csail.mit.edu/6.006/oldquizzes/solutions/q2-s2009-sol.pdf",
        "answer": [
            "True",
            "False"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> A back edge means a cycle in graph.  So if there is a cycle, all DFS traversals would contain at least one back edge.</div>",
        "keyword": "Graph Traversals"
    },
    {
        "question": "Is following statement true/false?\r\n\r\nA DFS of a directed graph always produces the same number of tree edges, i.e., independent of the order in which vertices are considered for DFS.\r\n(Source http://courses.csail.mit.edu/6.006/oldquizzes/solutions/q2-f2008-sol.pdf)",
        "answer": [
            "True",
            "False"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Consider the following graph.  If we start from 'a', then there is one tree edge.  If we start from 'b', then there is no tree edge.\r\n\r\n\r\na----&gt;b</div>",
        "keyword": "Graph Traversals"
    },
    {
        "question": "If the DFS finishing time f[u] > f[v] for two vertices u and v in a directed graph G, and u and v are in the same DFS tree in the DFS forest, then u is an ancestor of v in the depth first tree. (Source http://courses.csail.mit.edu/6.006/oldquizzes/solutions/q2-f2007-sol.pdf)",
        "answer": [
            "True",
            "False"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> In a graph with three nodes, r u and v, with edges (r; u) and (r; v), and r is the starting point for the DFS, u and v are siblings in the DFS tree, neither as the ancestor of the other.</div>",
        "keyword": "Graph Traversals"
    },
    {
        "question": "Consider the DAG with Consider V = {1, 2, 3, 4, 5, 6}, shown below. Which of the following is NOT a topological ordering? \r\n\r\n",
        "answer": [
            "1 2 3 4 5 6 ",
            "1 3 2 4 5 6 ",
            "1 3 2 4 6 5 ",
            "3 2 4 1 6 5"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> In option D, 1 appears after 2 and 3 which is not possible in <a href=\"http://www.geeksforgeeks.org/topological-sorting/\" target=\"_blank\">Topological Sorting</a>.\r\n\r\nIn the given DAG it is directly visible that there is an outgoing edge from vertex 1 to vertex 2 and 3 hence 2 and 3 cannot come before vertex 1 so clearly option D is incorrect topological sort.\r\nBut for questions in which it is not directly visible we should know how to find topological sort of a DAG.\r\n\r\n\r\n<a href=\"https://contribute.geeksforgeeks.org/wp-content/uploads/gate1-explanation.png\"><img alt=\"topological_sort\" class=\"alignnone size-full wp-image-29245\" height=\"331\" src=\"https://contribute.geeksforgeeks.org/wp-content/uploads/gate1-explanation.png\" width=\"659\"/></a>\r\n\r\nThis solution is contributed by <strong>Parul sharma.</strong></div>",
        "keyword": "Graph Traversals"
    },
    {
        "question": "Let G be a graph with n vertices and m edges. What is the tightest upper bound on the running time on Depth First Search of G? Assume that the graph is represented using adjacency matrix.",
        "answer": [
            "O(n)",
            "O(m+n)",
            "O(n2)",
            "O(mn)"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> <a href=\"http://www.geeksforgeeks.org/depth-first-traversal-for-a-graph/\" target=\"_blank\">Depth First Search of a graph </a>takes O(m+n) time when the graph is represented using adjacency list.\r\n\r\nIn adjacency matrix representation, graph is represented as an \"n x n\" matrix.  To do DFS, for every vertex, we traverse the row corresponding to that vertex to find all adjacent vertices (In adjacency list representation we traverse only the adjacent vertices of the vertex). Therefore time complexity becomes O(n<sup>2</sup>)</div>",
        "keyword": "Graph Traversals"
    },
    {
        "question": "Consider the tree arcs of a BFS traversal from a source node W in an unweighted, connected, undirected graph. The tree T formed by the tree arcs is a data structure for computing.",
        "answer": [
            "the shortest path between every pair of vertices.",
            "the shortest path from W to every vertex in the graph.",
            " the shortest paths from W to only those nodes that are leaves of T.",
            "the longest path in the graph"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> <a href=\"http://www.geeksforgeeks.org/breadth-first-traversal-for-a-graph/\" target=\"_blank\">BFS</a> always produces shortest path from source to all other vertices in an unweighted graph.</div>",
        "keyword": "Graph Traversals"
    },
    {
        "question": "Suppose depth first search is executed on the graph below starting at some unknown vertex. Assume that a recursive call to visit a vertex is made only after first checking that the vertex has not been visited earlier. Then the maximum possible recursion depth (including the initial call) is _________.\r\n\r\n",
        "answer": [
            "17",
            "18",
            "19",
            "20"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> The following diagram shows the worst case situation where the recursion tree has maximum depth.  \r\n\r\n<a href=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2014/08/GATECS2014Q20Sol.png\"><img alt=\"GATECS2014Q20Sol\" class=\"alignnone size-medium wp-image-13115\" height=\"89\" src=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2014/08/GATECS2014Q20Sol-300x89.png\" width=\"300\"/></a>\r\n\r\nSo the recursion depth is 19 (including the first node).</div>",
        "keyword": "Graph Traversals"
    },
    {
        "question": "Let T be a depth first search tree in an undirected graph G. Vertices u and n are leaves of this tree T. The degrees of both u and n in G are at least 2. which one of the following statements is true? ",
        "answer": [
            "There must exist a vertex w adjacent to both u and n in G",
            "There must exist a vertex w whose removal disconnects u and n in G",
            "There must exist a cycle in G containing u and n",
            " There must exist a cycle in G containing u and all its neighbours in G."
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> <strong>Below example shows that A and B are FALSE:</strong>\n<a href=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2017/01/GATE_DFS2.jpg\"><img alt=\"GATE_DFS2\" class=\"aligncenter size-full wp-image-30434\" height=\"420\" src=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2017/01/GATE_DFS2.jpg\" width=\"535\"/></a>\n<strong>Below example shows C is false:</strong>\n<a href=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2017/01/GATE_DFS1.jpg\"><img alt=\"GATE_DFS\" class=\"aligncenter size-full wp-image-30433\" height=\"420\" src=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2017/01/GATE_DFS1.jpg\" width=\"535\"/></a></div>",
        "keyword": "Graph Traversals"
    },
    {
        "question": "Let G be an undirected graph. Consider a depth-first traversal of G, and let T be the resulting depth-first search tree. Let u be a vertex in G and let v be the first new (unvisited) vertex visited after visiting u in the traversal. Which of the following statements is always true?",
        "answer": [
            "{u,v} must be an edge in G, and u is a descendant of v in T",
            "{u,v} must be an edge in G, and v is a descendant of u in T",
            "If {u,v} is not an edge in G then u is a leaf in T",
            " If {u,v} is not an edge in G then u and v must have the same parent in T "
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>In <a href=\"http://www.geeksforgeeks.org/depth-first-traversal-for-a-graph/\">DFS</a>, if 'v' is visited\r\nafter 'u', then one of the following is true.\r\n1) (u, v) is an edge.\r\n     u\r\n   /   \\\r\n  v     w\r\n /     / \\\r\nx     y   z\r\n\r\n2) 'u' is a leaf node.\r\n     w\r\n   /   \\\r\n  x     v\r\n /     / \\\r\nu     y   z </pre>\r\nIn <a href=\"http://www.geeksforgeeks.org/depth-first-traversal-for-a-graph/\">DFS</a>, after visiting a node, we first recur for all unvisited children.  If there are no unvisited children (u is leaf), then control goes back to parent and parent then visits next unvisited children.</div>",
        "keyword": "Graph Traversals"
    },
    {
        "question": "In a depth-first traversal of a graph G with n vertices, k edges are marked as tree edges. The number of connected components in G is",
        "answer": [
            "k",
            "k + 1",
            "n - k - 1",
            "n - k"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> Tree edges are the edges that are part of DFS tree.  If there are x tree edges in a tree, then  x+1 vertices in the tree.\r\n\r\nThe output of DFS is a forest if the graph is disconnected.  Let us see below simple example where graph is disconnected.\r\n\r\n<a href=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/01/example2.png\"><img alt=\"example\" class=\"alignnone wp-image-22863\" height=\"176\" src=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/01/example2.png\" width=\"476\"/></a>\r\n\r\n \r\n\r\nThe above example matches with D option\r\n\r\n<strong>More Examples:</strong>\r\n\r\n1) All vertices  of Graph are connected.  k must be n-1.  We get number of connected components  = n- k =  n - (n-1) = 1\r\n\r\n2) No vertex is connected. k must be 0.  We get number of connected components  = n- k =  n - 0 = n</div>",
        "keyword": "Graph Traversals"
    },
    {
        "question": "Consider the following directed graph.\r\n\r\n\r\n\r\nThe number of different topological orderings of the vertices of the graph is\r\n\r\n \r\nNote : This question was asked as Numerical Answer Type.\r\n",
        "answer": [
            "1",
            "2",
            "4",
            "6"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> Following are different 6 <a href=\"http://www.geeksforgeeks.org/topological-sorting/\" rel=\"bookmark\">Topological Sortings</a>\n<pre>\r\na-b-c-d-e-f\r\na-d-e-b-c-f\r\na-b-d-c-e-f\r\na-d-b-c-e-f\r\na-b-d-e-c-f\r\na-d-b-e-c-f</pre>\n<iframe allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen=\"\" frameborder=\"0\" height=\"315\" src=\"https://www.youtube.com/embed/Key2RKhzRGY?start=411\" title=\"YouTube video player\" width=\"560\"></iframe></div>",
        "keyword": "Graph Traversals"
    },
    {
        "question": "In an adjacency list representation of an undirected simple graph G = (V, E), each edge (u, v) has two adjacency list entries: [v] in the adjacency list of u, and [u] in the adjacency list of v. These are called twins of each other. A twin pointer is a pointer from an adjacency list entry to its twin. If |E| = m and |V | = n, and the memory size is not a constraint, what is the time complexity of the most efficient algorithm to set the twin pointer in each entry in each adjacency list?",
        "answer": [
            "Θ(n2)",
            "Θ(m+n)",
            "Θ(m2)",
            "Θ(n4)"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> First you need to find twins of each node. You can do this using <b>level order traversal (i.e., BFS)</b> once. Time complexity of BFS is Θ(m +n).\r\nAnd you have to use linked list for representation which is extra space (but memory size is not a constraint here).\r\nFinal, time complexity is Θ(m + n) to set twin pointer.\r\n\r\nOption (B) is correct.</div>",
        "keyword": "Graph Traversals"
    },
    {
        "question": "Let  G = (V, G) be a weighted undirected graph and let T be a Minimum Spanning Tree (MST) of G maintained using adjacency lists. Suppose a new weighed edge (u, v) ∈ V×V is added to G. The worst case time complexity of determining if T is still an MST of the resultant graph is",
        "answer": [
            "Θ(∣E∣ + ∣V∣)",
            "Θ(∣E∣.∣V∣)",
            "Θ(E∣ log ∣V∣)",
            "Θ(∣V∣)"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> <ol>\n<li>As T is a minimum spanning tree and we need to add a new edge to existing spanning tree.\r\n</li>\n<li>Later we need to check still T is a minimum spanning tree or not, So we need to check all vertices whether there is any cycle present after adding a new edge.\r\n</li>\n<li>All vertices need to traverse to confirm minimum spanning tree after adding new edge then time complexity is O(V).\r\n</li>\n</ol> \r\n\r\nOption (D) is correct.\r\n\r\n<iframe allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen=\"\" frameborder=\"0\" height=\"315\" src=\"https://www.youtube.com/embed/fP8QED8d6ws?start=3773\" title=\"YouTube video player\" width=\"560\"></iframe></div>",
        "keyword": "Graph Traversals"
    },
    {
        "question": "An articulation point in a connected graph is a vertex such that removing the vertex and its incident edges disconnects the graph into two or more connected components.\r\n\r\nLet T be a DFS tree obtained by doing DFS in a connected undirected graph G.\r\n\r\nWhich of the following options is/are correct?",
        "answer": [
            "Root of T can never be an articulation point in G.",
            "Root of T is an articulation point in G if and only if it has 2 or more children.",
            "A leaf of T can be an articulation point in G.",
            "If u is an articulation point in G such that x is an ancestor of u in T and y is a descendent of u in T, then all paths from x to y in G must pass through u."
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> How to find all articulation points ? <br/><a href=\"https://www.geeksforgeeks.org/articulation-points-or-cut-vertices-in-a-graph/\">DFS- based-approach</a>: <br/>We can prove following properties: <br/> </div>",
        "keyword": "Graph Traversals"
    },
    {
        "question": "Consider a complete binary tree with 7 nodes. Let A denote the set of first 3 elements obtained by performing Breadth-First Search (BFS) starting from the root. Let B denote the set of first 3 elements obtained by performing Depth-First Search (DFS) starting from the root.\r\n\r\nThe value of ∣A−B∣ is _____________ .",
        "answer": [
            "1",
            "2",
            "3",
            "4"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> In case of BFS if we draw complete binary tree then in Set A we have level1+level2. \r\nIn DFS we have level1+ level 2 + level 3. \r\n\r\nSo A-B= remaining element of level 2. \r\n\r\n<iframe allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen=\"\" frameborder=\"0\" height=\"315\" src=\"https://www.youtube.com/embed/I43aLH5qEBc?start=1915\" title=\"YouTube video player\" width=\"560\"></iframe></div>",
        "keyword": "Graph Traversals"
    },
    {
        "question": "Consider the following directed graph:\r\n\r\n\r\n\r\nWhich of the following is/are correct about the graph?",
        "answer": [
            "The graph does not have a topological order",
            "A depth-first traversal starting at vertex S classifies three directed edges as back edges",
            "The graph does not have a strongly connected component",
            "For each pair of vertices u and v, there is a directed path from u to v"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> <b>(A)</b> True, because of cycle in the bottom left corner of the graph.\r\n\r\n<b>(B)</b> True, we can come back length of 3 edges.\r\n\r\n<b>(C)</b> The graph does have <b>a</b> strongly connected component, it has cycle.\r\n\r\n<b>(D)</b> False, not a strongly connected graph.</div>",
        "keyword": "Graph Traversals"
    },
    {
        "question": "In a directed acyclic graph with a source vertex s, the quality-score of a directed path is defined to be the product of the weights of the edges on the path. Further, for a vertex v other than s, the quality-score of v is defined to be the maximum among the quality-scores of all the paths from s to v. The quality-score of s is assumed to be 1.\r\n\r\n\r\n\r\nThe sum of the quality-scores of all vertices on the graph shown above is _______ .",
        "answer": [
            "929",
            "81",
            "729",
            "1023"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Let Q(V) denote the quality-score of vertex V.\r\n<pre>\r\nQ(S) = 1 (Given)\r\nQ(C) = 1 (S → C)\r\nQ(F) = 1 * 9 (S  → C  → F)\r\nQ(A) = 9 (S  → A)\r\nQ(D) = 9*1 (S  → A  → D)\r\nQ(G) = 9 * 1 * 9 (S  → A  → D  → G)\r\nQ(B) = 9 * 1 (S  → A  → B)\r\nQ(E) = 9 * 1 * 9 (S  → A  → D  → E)\r\nQ(T) = 9*1*9*9 (S  → A  → D  → E → T) </pre>\r\n\r\nSum of quality-score of all vertices, \r\n<pre>\r\n= 1 + 1 + 9 + 9 + 9 + 81 + 9 + 81 + 729 \r\n= 929 </pre></div>",
        "keyword": "Graph Traversals"
    },
    {
        "question": "Consider the directed graph shown in the figure below. There are multiple shortest paths between vertices S and T. Which one will be reported by Dijstra?s shortest path algorithm? Assume that, in any iteration, the shortest path to a vertex v is updated only when a strictly shorter path to v is discovered.\r\n\n",
        "answer": [
            "SDT",
            "SBDT",
            "SACDT",
            "SACET"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> See <a href=\"http://www.geeksforgeeks.org/greedy-algorithms-set-6-dijkstras-shortest-path-algorithm/\">Dijkstra’s shortest path algorithm</a>\r\n\r\nWhen the algorithm reaches vertex 'C', the distance values of 'D' and 'E' would be 7 and 6 respectively. So the next picked vertex would be 'E'</div>",
        "keyword": "Graph Shortest Paths"
    },
    {
        "question": "To implement Dijkstra’s shortest path algorithm on unweighted graphs so that it runs in linear time, the data structure to be used is:",
        "answer": [
            "Queue",
            "Stack",
            "Heap",
            "B-Tree"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> The shortest path in an un-weighted graph means the smallest number of edges that must be traversed in order to reach the destination in the graph. This is the same problem as solving the weighted version where all the weights happen to be 1. If we use Queue (FIFO) instead of Priority Queue (Min Heap), we get the shortest path in linear time O(|V| + |E|). Basically we do BFS traversal of the graph to get the shortest paths.</div>",
        "keyword": "Graph Shortest Paths"
    },
    {
        "question": "Dijkstra’s single source shortest path algorithm when run from vertex a in the below graph, computes the correct shortest path distance to\r\n\r\n",
        "answer": [
            "only vertex a ",
            "only vertices a, e, f, g, h",
            "only vertices a, b, c, d ",
            " all the vertices"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> Dijkstra’s single source shortest path is not guaranteed to work for graphs with negative weight edges, but it works for the given graph.\r\nLet us see...\r\n\r\nLet us run the 1st pass\r\nb 1\r\nb is minimum, so shortest distance to b is 1.\r\n\r\nAfter 1st  pass, distances are\r\nc 3, e -2.  \r\ne is minimum, so shortest distance to e is -2\r\n\r\nAfter 2nd pass, distances are\r\nc 3, f 0.  \r\nf is minimum, so shortest distance to f is 0\r\n\r\nAfter 3rd pass, distances are\r\nc 3, g 3.  \r\nBoth are same, let us take g. so shortest distance to g is 3.\r\n\r\nAfter 4th pass, distances are\r\nc 3, h 5  \r\nc is minimum, so shortest distance to c is 3\r\n\r\nAfter 5th pass, distances are\r\nh  -2\r\nh is minimum, so shortest distance to h is -2</div>",
        "keyword": "Graph Shortest Paths"
    },
    {
        "question": "In an unweighted, undirected connected graph, the shortest path from a node S to every other node is computed most efficiently, in terms of time complexity by",
        "answer": [
            "Dijkstra’s algorithm starting from S.",
            "Warshall’s algorithm",
            "Performing a DFS starting from S.",
            "Performing a BFS starting from S."
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> <pre> * Time Comlexity of the <a href=\"http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\">Dijkstra’s algorithm </a>is O(|V|^2 + E)  \r\n * Time Comlexity of the <a href=\"http://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm\">Warshall’s algorithm</a> is O(|V|^3)\r\n * <a href=\"http://en.wikipedia.org/wiki/Depth-first_search\">DFS </a>cannot be used for finding shortest paths\r\n * <a href=\"http://en.wikipedia.org/wiki/Breadth-first_search\">BFS</a> can be used for unweighted graphs. Time Complexity for BFS is O(|E| + |V|)</pre></div>",
        "keyword": "Graph Shortest Paths"
    },
    {
        "question": "Suppose we run Dijkstra’s single source shortest-path algorithm on the following edge weighted directed graph with vertex P as the source. In what order do the nodes get included into the set of vertices for which the shortest path distances are finalized? (GATE CS 2004)\r\n\n",
        "answer": [
            "P, Q, R, S, T, U",
            "P, Q, R, U, S, T",
            "P, Q, R, U, T, S",
            "P, Q, T, R, U, S"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Refer <a href=\"http://www.geeksforgeeks.org/greedy-algorithms-set-6-dijkstras-shortest-path-algorithm/\">http://www.geeksforgeeks.org/greedy-algorithms-set-6-dijkstras-shortest-path-algorithm/</a></div>",
        "keyword": "Graph Shortest Paths"
    },
    {
        "question": "What is the time complexity of Bellman-Ford single-source shortest path algorithm on a complete graph of n vertices?\r\n",
        "answer": [
            "[Tex]\\Theta(n^2)[/Tex]",
            "[Tex]\\Theta(n^2 Logn)[/Tex]",
            "[Tex]\\Theta(n^3)[/Tex]",
            "[Tex]\\Theta(n^3 Logn)[/Tex]"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Time complexity of Bellman-Ford algorithm is <img alt=\"\\Theta(VE)\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"27\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-eb4af745f2a96fea1f4fecbe3b40d5ad_l3.png\" style=\"vertical-align: -7px;\" title=\"Rendered by QuickLaTeX.com\" width=\"80\"/> where V is number of vertices and E is number edges (See <a href=\"http://www.geeksforgeeks.org/dynamic-programming-set-23-bellman-ford-algorithm/\" target=\"_blank\">this</a>).  If the graph is complete, the value of E becomes <img alt=\"\\Theta(V^2)\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"31\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-2efbade4358ee827f0cc1bf3601c9a0a_l3.png\" style=\"vertical-align: -7px;\" title=\"Rendered by QuickLaTeX.com\" width=\"70\"/>.  So overall time complexity becomes  <img alt=\"\\Theta(V^3)\" class=\"ql-img-inline-formula quicklatex-auto-format\" height=\"31\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-25f00363ec340606801f3fb00dd2ac6f_l3.png\" style=\"vertical-align: -7px;\" title=\"Rendered by QuickLaTeX.com\" width=\"70\"/></div>",
        "keyword": "Graph Shortest Paths"
    },
    {
        "question": "In a weighted graph, assume that the shortest path from a source 's' to a destination 't' is correctly calculated using a shortest path algorithm.  Is the following statement true?\r\nIf we increase weight of every edge by 1, the shortest path always remains same.",
        "answer": [
            "Yes",
            "No"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> See the following counterexample.\r\n\r\nThere are 4 edges s-a, a-b, b-t and s-t of wights 1, 1, 1 and 4 respectively.   The shortest path from s to t is s-a, a-b, b-t.  IF we increase weight of every edge by 1, the shortest path changes to s-t.<pre>\r\n\r\n   1      1     1\r\ns-----a-----b-----t\r\n \\              /\r\n   \\          /\r\n     \\______/\r\n        4</pre>\n</div>",
        "keyword": "Graph Shortest Paths"
    },
    {
        "question": "Following statement is true or false?\r\n\r\n\r\nIf we make following changes to  Dijkstra, then it can be used to find \r\nthe longest simple path, assume that the graph is acyclic.\r\n\r\n1) Initialize all distances as minus infinite instead of plus infinite.\r\n\r\n2) Modify the relax condition in  Dijkstra's algorithm to update distance\r\n  of an adjacent v of the currently considered vertex u only\r\n  if \"dist[u]+graph[u][v] > dist[v]\". In shortest path algo, \r\n  the sign is opposite. \n",
        "answer": [
            "True",
            "False"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> In shortest path algo, we pick the minimum distance vertex from the set of vertices for which distance is not finalized yet. And we finalize the distance of the minimum distance vertex.  \r\n\r\nFor maximum distance problem, we cannot finalize the distance because there can be a longer path through not yet finalized vertices.</div>",
        "keyword": "Graph Shortest Paths"
    },
    {
        "question": "Which of the following algorithm can be used to efficiently calculate single source shortest paths in a Directed Acyclic Graph?",
        "answer": [
            "Dijkstra",
            "Bellman-Ford",
            "Topological Sort",
            "Strongly Connected Component"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Using Topological Sort, we can find single source shortest paths in O(V+E) time which is the most efficient algorithm.  See following for details.\r\n\r\n\r\n<a href=\"http://www.geeksforgeeks.org/shortest-path-for-directed-acyclic-graphs/\">Shortest Path in Directed Acyclic Graph</a></div>",
        "keyword": "Graph Shortest Paths"
    },
    {
        "question": "\nGiven a directed graph where weight of every edge is same, we can efficiently find shortest path from a given source to destination using? \n",
        "answer": [
            "Breadth First Traversal",
            "Dijkstra's Shortest Path Algorithm",
            "Neither Breadth First Traversal nor Dijkstra's algorithm can be used",
            "Depth First Search"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\">\n<p>With BFS, we first find explore vertices at one edge distance, then all vertices at 2 edge distance, and so on.<br/> </p>\n</div>",
        "keyword": "Graph Shortest Paths"
    },
    {
        "question": "Is the following statement valid about shortest paths?\r\nGiven a graph, suppose we have calculated shortest path from a source to all other vertices.  If we modify the graph such that weights of all edges is becomes double of the original weight, then the shortest path remains same only the total weight of path changes.",
        "answer": [
            "True",
            "False"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> The shortest path remains same.  It is like if we change unit of distance from meter to kilo meter, the shortest paths don't change.</div>",
        "keyword": "Graph Shortest Paths"
    },
    {
        "question": "Match the following\r\n              \r\nGroup A                                                Group B\r\na) Dijkstra's single shortest path algo               p) Dynamic Programming\r\nb) Bellmen Ford's single shortest path algo           q) Backtracking  \r\nc) Floyd Warshell's all pair shortest path algo.      r) Greedy Algorithm",
        "answer": [
            "a-r,  b-q, c-p",
            "a-p,  b-p, c-p",
            "a-r,  b-p, c-p",
            "a-p,  b-r, c-q"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Dijkstra is a greedy algorithm where we pick the minimum distant vertex from not yet finalized vertices.\r\n\r\nBellman Ford and Floyd Warshell both are Dynamic Programming algorithms where we build the shortest paths in bottom up manner.</div>",
        "keyword": "Graph Shortest Paths"
    },
    {
        "question": "Is the following statement valid?. \nGiven a weighted graph where weights of all edges are unique (no two edge have same weights), there is always a unique shortest path from a source to destination in such a graph.",
        "answer": [
            "True",
            "False"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> There can be more than one paths with same weight.  Consider a path with one edge of weight 5 and another path with two edges of weights 2 and 3.  Both paths have same weights.</div>",
        "keyword": "Graph Shortest Paths"
    },
    {
        "question": "Is the following statement valid?. \nGiven a graph where all edges have positive weights, the shortest paths produced by Dijsktra and Bellman Ford algorithm may be different but path weight would always be same.",
        "answer": [
            "True",
            "False"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> Dijkstra and Bellman-Ford both work fine for a graph with all positive weights, but they are different algorithms and may pick different edges for shortest paths.</div>",
        "keyword": "Graph Shortest Paths"
    },
    {
        "question": "Which of the following statement(s)is / are correct regarding Bellman-Ford shortest path algorithm? \r\nP: Always finds a negative weighted cycle, if one exist s.\r\nQ: Finds whether any negative weighted cycle is reachable \r\n   from the source. ",
        "answer": [
            "P Only",
            "Q Only ",
            "Both P and Q",
            "Neither P nor Q"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> <a href=\"http://www.geeksforgeeks.org/dynamic-programming-set-23-bellman-ford-algorithm/\" target=\"_blank\">Bellman-Ford shortest path algorithm</a> is a single source shortest path algorithm.  So it can only find cycles which are reachable from a given source, not any negative weight cycle.  Consider a disconnected where a negative weight cycle is not reachable from the source at all.\r\n\r\nIf there is a negative weight cycle, then it will appear in shortest path as the negative weight cycle will always form a shorter path when iterated through the cycle again and again.</div>",
        "keyword": "Graph Shortest Paths"
    },
    {
        "question": "Let G(V, E) an undirected graph with positive edge weights. Dijkstra's single-source shortest path algorithm can be implemented using the binary heap data structure with time complexity:",
        "answer": [
            "O(| V |2)",
            "O (| E | + | V | log | V |)",
            "O (| V | log | V |)",
            "O ((| E | + | V |) log | V |)"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> See Time Complexity Section of <a href=\"http://www.geeksforgeeks.org/greedy-algorithms-set-7-dijkstras-algorithm-for-adjacency-list-representation/\" target=\"_blank\">http://www.geeksforgeeks.org/greedy-algorithms-set-7-dijkstras-algorithm-for-adjacency-list-representation/</a></div>",
        "keyword": "Graph Shortest Paths"
    },
    {
        "question": "Let G = (V, E) be an undirected graph with a subgraph G1 = (V1, El). Weights are assigned to edges of G as follows : \r\n\r\n \r\n\r\nA single-source shortest path algorithm is executed on the weighted graph (V, E, w) with an arbitrary vertex ν1 of V1 as the source. Which of the following can always be inferred from the path costs computed?",
        "answer": [
            "The number of edges in the shortest paths from ν1 to all vertices of G",
            "G1 is connected",
            "V1 forms a clique in G",
            "G1 is a tree"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> When shortest path shortest path from v1 (one of the vertices in V1) is computed.  G1 is connected if the distance from v1 to any other vertex in V1 is greater than 0, otherwise G1 is disconnected. </div>",
        "keyword": "Graph Shortest Paths"
    },
    {
        "question": "Let G (V, E) be a directed graph with n vertices. A path from vi to vj in G is sequence of vertices (vi, vi+1, ......., vj) such that (vk, vk+1) ∈ E for all k in i through j - 1. A simple path is a path in which no vertex appears more than once.\r\nLet A be an n x n array initialized as follow \r\n \r\nConsider the following algorithm.\r\n\r\nfor i = 1 to n\r\n   for j = 1 to n\r\n      for k = 1 to n\r\n         A [j , k] = max (A[j, k] (A[j, i] + A [i, k]); \r\nWhich of the following statements is necessarily true for all j and k after terminal of the above algorithm ?",
        "answer": [
            "A[j, k] ≤ n",
            "If A[j, k] ≥ n - 1, then G has a Hamiltonian cycle",
            "If there exists a path from j to k, A[j, k] contains the longest path lens from j to k",
            "If there exists a path from j to k, every simple path from j to k contain most A[j, k] edges"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> <pre>In the original input matrix,  A[j , k] is 1 if there\r\nis an edge from j to k, else 0.\r\n\r\nBelow expression is important to note:\r\n\r\nA[j , k] = max(A[j, k] (A[j, i] + A [i, k]);\r\n\r\nThis expression puts the count of maximum edges on a path from\r\nj to k.  In this expression, we consider every vertex k that can \r\nbecome an intermediate vertex and can give longer path.</pre>\n</div>",
        "keyword": "Graph Shortest Paths"
    },
    {
        "question": "Let G = (V, E) be a simple undirected graph, and s be a particular vertex in it called the source. For x ∈ V, let d(x) denote the shortest distance in G from s to x. A breadth first search (BFS) is performed starting at s. Let T be the resultant BFS tree. If (u, v) is an edge of G that is not in T, then which one of the following CANNOT be the value of d(u) – d(v)?",
        "answer": [
            "-1",
            "0",
            "1",
            "2"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> Note that the given graph is undirected, so an edge (u, v) also means (v, u) is also an edge.\r\n\r\nSince a shorter path can always be obtained by using edge (u, v) or (v, u), the difference between d(u) and d(v) can not be more than 1.</div>",
        "keyword": "Graph Shortest Paths"
    },
    {
        "question": "Let G be a directed graph whose vertex set is the set of numbers from 1 to 100. There is an edge from a vertex i to a vertex j iff either j = i + 1 or j = 3i. The minimum number of edges in a path in G from vertex 1 to vertex 100 is\r\n\r\n \r\n\r\n ",
        "answer": [
            "4",
            "7",
            "23",
            "99"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> The task is to find minimum number of edges in a path in G from vertex 1 to vertex 100 such that we can move to either i+1 or 3i from a vertex i.\r\n\r\n<pre>\r\nSince the task is to minimize number of edges, \r\nwe would prefer to follow 3*i.  \r\n\r\nLet us follow multiple of 3.\r\n\r\n1 =&gt; 3 =&gt; 9 =&gt; 27 =&gt; 81, now we can't follow multiple\r\nof 3. So we will have to follow i+1. This solution gives\r\na long path.\r\n\r\nWhat if we begin from end, and we reduce by 1 if \r\nthe value is not multiple of 3, else we divide by 3.\r\n100 =&gt; 99 =&gt; 33 =&gt; 11 =&gt; 10 =&gt; 9 =&gt; 3 =&gt; 1\r\n\r\nSo we need total 7 edges.</pre></div>",
        "keyword": "Graph Shortest Paths"
    },
    {
        "question": "Consider the weighted undirected graph with 4 vertices, where the weight of edge {i, j} g is given by the entry\r\nWij in the matrix W\r\n\n\n\r\nThe largest possible integer value of x, for which at least one shortest path between some pair of vertices will contain the edge with weight x is ________\r\n\r\n \r\nNote : This question was asked as Numerical Answer Type.\r\n",
        "answer": [
            "8",
            "12",
            "10",
            "11"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Let vertices be 0, 1, 2 and 3.  \r\n\r\nx directly connects 2 to 3.  The shortest path (excluding x) from 2 to 3 is of weight 12 (2-1-0-3).</div>",
        "keyword": "Graph Shortest Paths"
    },
    {
        "question": "The Floyd-Warshall algorithm for all-pair shortest paths computation is based on:\r\n",
        "answer": [
            "  Greedy paradigm.",
            "  Divide-and-Conquer paradigm.",
            "  Dynamic Programming paradigm.",
            "neither Greedy nor Divide-and-Conquer nor Dynamic Programming paradigm.\r\n"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> <a href=\"http://www.geeksforgeeks.org/dynamic-programming-set-16-floyd-warshall-algorithm/\">Floyd Warshall Algorithm</a> is a <a href=\"http://www.geeksforgeeks.org/dynamic-programming-set-1/\">Dynamic Programming</a> based algorithm. \r\n\r\nIt finds all pairs shortest paths using following recursive nature of problem. \r\n\r\nFor every pair (i, j) of source and destination vertices respectively, there are two possible cases.\r\n1) k is not an intermediate vertex in shortest path from i to j. We keep the value of dist[i][j] as it is.\r\n2) k is an intermediate vertex in shortest path from i to j. We update the value of dist[i][j] as dist[i][k] + dist[k][j].\r\n\r\nThe following figure is taken from the Cormen book. It shows the above optimal substructure property in the all-pairs shortest path problem.\r\n\r\n<img alt=\"\" src=\"https://cdncontribute.geeksforgeeks.org/wp-content/uploads/gatecs24.png\"/>\r\n\r\n\r\nSince there are <a href=\"http://www.geeksforgeeks.org/dynamic-programming-set-1/\">overlapping subproblems</a> in recursion, it uses dynamic programming.</div>",
        "keyword": "Graph Shortest Paths"
    },
    {
        "question": "Consider a weighted undirected graph with positive edge weights and let uv be an edge in the graph. It is known that the shortest path from the source vertex s to u has weight 53 and the shortest path from s to v has weight 65. Which one of the following statements is always true?",
        "answer": [
            "weight (u, v) < 12",
            "weight (u, v) ≤ 12",
            "weight (u, v) > 12",
            "weight (u, v) ≥ 12"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> <img alt=\"\" src=\"https://cdncontribute.geeksforgeeks.org/wp-content/uploads/gateit_3.png\"/>\r\n\r\n\r\n\r\nThe minimum weight happens when (S,U) + (U,V) = (S,V)\r\n\r\nElse (S,U) + (U,V) &gt;= (S,V)\r\n\r\nGiven (S,U) = 53, (S,V) = 65\r\n\r\n53 + (U,V) &gt;= 63\r\n\r\n(U,V) &gt;= 12.\r\n\r\n\r\nThis solution is contributed by <strong>Anil Saikrishna Devarasetty</strong></div>",
        "keyword": "Graph Shortest Paths"
    },
    {
        "question": "Which of the following data structure is useful in traversing a given graph by breadth first search?",
        "answer": [
            "Stack",
            "List",
            "Queue",
            "None of the above."
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> BFS performs level-order traversal which can be fairly done using a queue. A queue uses FIFO ordering and the nodes that we enqueue first are explored first maintaining the order of traversal. </div>",
        "keyword": "Graph Shortest Paths"
    },
    {
        "question": "Which of the following algorithm solves the all-pair shortest path problem?",
        "answer": [
            "Prim’s algorithm",
            "Dijikstra’s algorithm",
            "Bellman-Ford’s algorithm",
            "Floyd-Warshall’s algorithm"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> Prim's Algorithm is used to find MST of a given graph. Refer: <a href=\"https://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-minimum-spanning-tree-mst-2/\" rel=\"noopener\" target=\"_blank\">Prim’s Minimum Spanning Tree (MST)</a>\r\nDijikstra's Algorithm is used to find the shortest path from source to all the other nodes in a weighted graph. Refer: <a href=\"https://www.geeksforgeeks.org/greedy-algorithms-set-7-dijkstras-algorithm-for-adjacency-list-representation/\" rel=\"noopener\" target=\"_blank\">Dijkstra’s Algorithm</a>\r\nBellmanFord's Algorithm is used to find the shortest distance from source to all other nodes in a graph that can contain negative weight edges. Refer:<a href=\"https://www.geeksforgeeks.org/dynamic-programming-set-23-bellman-ford-algorithm/\" rel=\"noopener\" target=\"_blank\">Bellman–Ford Algorithm</a>\r\nFloyd-Warshall's Algorithm: It is an All-pair-shortest path algorithm, used to find shortest distance between every pair of vertices. Refer: <a href=\"https://www.geeksforgeeks.org/dynamic-programming-set-16-floyd-warshall-algorithm/\" rel=\"noopener\" target=\"_blank\">Floyd Warshall Algorithm </a>\r\nSo, option (D) is correct.</div>",
        "keyword": "Graph Shortest Paths"
    },
    {
        "question": "Which one of the following algorithm design techniques is used in finding all pairs of shortest distances in a graph?",
        "answer": [
            "Dynamic programming",
            "Backtracking",
            "Greedy",
            " Divide and Conquer"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> <a href=\"https://www.geeksforgeeks.org/dynamic-programming-set-16-floyd-warshall-algorithm/\" rel=\"noopener\" target=\"_blank\">Floyd Warshall Algorithm</a> is the All Pairs Shortest Path problem which uses Dynamic Programming to find shortest distances between every pair of vertices in a given edge weighted directed Graph.\r\n\r\nOption (A) is correct.</div>",
        "keyword": "Graph Shortest Paths"
    },
    {
        "question": "Which of the following is application of Breath First Search on the graph?",
        "answer": [
            "Finding diameter of the graph",
            "Finding bipartite graph",
            "Both (a) and (b)",
            "None of the above"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> BFS is used to Find the diameter of the graph and to test whether a graph is bipartite or not. BFS has many other applications also.\r\n\r\nRefer: <a href=\"https://www.geeksforgeeks.org/applications-of-breadth-first-traversal/\" rel=\"noopener\" target=\"_blank\">Applications of Breadth First Traversal</a>\r\n\r\nOption (C) is correct.</div>",
        "keyword": "Graph Shortest Paths"
    },
    {
        "question": "Let G=(V,E) be a directed, weighted graph with weight function w:E→R. For some function f:V→R, for each edge (u,v)∈E, define w′(u,v) as w(u,v)+f(u)−f(v).\r\n\r\nWhich one of the options completes the following sentence so that it is TRUE ?\r\n\r\n“The shortest paths in G under w are shortest paths under w′ too, _________”.",
        "answer": [
            "for every f:V→R",
            "if and only if ∀u∈V, f(u) is positive",
            "if and only if ∀u∈V, f(u) is negative",
            "if and only if f(u) is the distance from s to u in the graph obtained by adding a new vertex s to G and edges of zero weight from s to every vertex of G"
        ],
        "correct": "A",
        "explain": "None",
        "keyword": "Graph Shortest Paths"
    },
    {
        "question": "An undirected graph G(V, E) contains n ( n > 2 ) nodes named v1 , v2 ,….vn. Two nodes vi , vj are connected if and only if 0 < |i – j| <= 2. Each edge (vi, vj ) is assigned a weight i + j. A sample graph with n = 4 is shown below. What will be the cost of the minimum spanning tree (MST) of such a graph with n nodes? (GATE CS 2011)\r\n\r\n\n",
        "answer": [
            " 1/12(11n^2 – 5n)",
            " n^2 – n + 1",
            " 6n – 11",
            "2n + 1"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> See <a href=\"http://www.geeksforgeeks.org/data-structures-and-algorithms-set-27/\">http://www.geeksforgeeks.org/data-structures-and-algorithms-set-27/</a> for explanation.</div>",
        "keyword": "Graph Minimum Spanning Tree"
    },
    {
        "question": "The length of the path from v5 to v6 in the MST of previous question with n = 10 is",
        "answer": [
            "11",
            "25",
            "31",
            "41"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> See question 2 of <a href=\"http://www.geeksforgeeks.org/data-structures-and-algorithms-set-27/\">http://www.geeksforgeeks.org/data-structures-and-algorithms-set-27/</a> for explanation.</div>",
        "keyword": "Graph Minimum Spanning Tree"
    },
    {
        "question": "Consider a complete undirected graph with vertex set {0, 1, 2, 3, 4}. Entry Wij in the matrix W below is the weight of the edge {i, j}. What is the minimum possible weight of a spanning tree T in this graph such that vertex 0 is a leaf node in the tree T? (GATE CS 2010)\r\n\n\n",
        "answer": [
            "7",
            "8",
            "9",
            "10"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> To get the minimum spanning tree with vertex 0 as leaf, first remove 0th row and 0th column and then get the minimum spanning tree (MST) of the remaining graph. Once we have MST of the remaining graph, connect the MST to vertex 0 with the edge with minimum weight (we have two options as there are two 1s in 0th row).</div>",
        "keyword": "Graph Minimum Spanning Tree"
    },
    {
        "question": "In the graph given in above question question, what is the minimum possible weight of a path P from vertex 1 to vertex 2 in this graph such that P contains at most 3 edges?",
        "answer": [
            "7",
            "8",
            "9",
            "10"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Path: 1 -&gt; 0 -&gt; 4 -&gt; 2\r\nWeight: 1 + 4 + 3</div>",
        "keyword": "Graph Minimum Spanning Tree"
    },
    {
        "question": "An undirected graph G has n nodes. Its adjacency matrix is given by an n × n square matrix whose (i) diagonal elements are 0‘s and (ii) non-diagonal elements are 1‘s. which one of the following is TRUE?",
        "answer": [
            "Graph G has no minimum spanning tree (MST)",
            " Graph G has a unique MST of cost n-1",
            "Graph G has multiple distinct MSTs, each of cost n-1",
            "Graph G has multiple spanning trees of different costs"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> See Question 2 of <a href=\"http://www.geeksforgeeks.org/data-structures-and-algorithms-set-22/\" target=\"_blank\"> http://www.geeksforgeeks.org/data-structures-and-algorithms-set-22/</a></div>",
        "keyword": "Graph Minimum Spanning Tree"
    },
    {
        "question": "Consider the following graph:\r\n\r\nWhich one of the following cannot be the sequence of edges added, in that order, to a minimum spanning tree using Kruskal’s algorithm?\r\n",
        "answer": [
            "(a—b),(d—f),(b—f),(d—c),(d—e)",
            "(a—b),(d—f),(d—c),(b—f),(d—e)",
            "(d—f),(a—b),(d—c),(b—f),(d—e)",
            "(d—f),(a—b),(b—f),(d—e),(d—c)"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> The edge (d-e) cannot be considered before (d-c) in <a href=\"http://en.wikipedia.org/wiki/Kruskal's_algorithm\">Kruskal's minimum spanning tree algorithm</a> because Kruskal’s algorithm picks the edge with minimum weight from the current set of edges at each step.</div>",
        "keyword": "Graph Minimum Spanning Tree"
    },
    {
        "question": "Let G be an undirected connected graph with distinct edge weight. Let emax be the edge with maximum weight and emin the edge with minimum weight. Which of the following statements is false? (GATE CS 2000)",
        "answer": [
            "Every minimum spanning tree of G must contain emin",
            "If emax is in a minimum spanning tree, then its removal must disconnect G",
            "No minimum spanning tree contains emax",
            "G has a unique minimum spanning tree"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> (a) and (b) are always true. \r\n(c) is false because (b) is true.  \r\n(d) is true because all edge weights are distinct for G.</div>",
        "keyword": "Graph Minimum Spanning Tree"
    },
    {
        "question": "Consider a weighted complete graph G on the vertex set {v1,v2 ,v} such that the weight of the edge (v,,v) is 2|i-j|. The weight of a minimum spanning tree of G is: (GATE CS 2006)\r\n\r\n",
        "answer": [
            " n — 1",
            "2n — 2",
            "nC2",
            "2"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Minimum spanning tree of such a graph is\r\n<pre>\r\nv1\r\n  \\\r\n    v2\r\n      \\\r\n       v3\r\n         \\\r\n          v4\r\n            .\r\n              .\r\n                .\r\n                 vn\r\n </pre>\r\nWeight of the minimum spanning tree  \r\n                =  2|2 - 1| + 2|3 - 2| + 2|4 - 3| + 2|5 - 4| .... + 2| n - (n-1) |\r\n                = 2n - 2\r\n</div>",
        "keyword": "Graph Minimum Spanning Tree"
    },
    {
        "question": "Let G be a weighted graph with edge weights greater than one and G'be the graph constructed by squaring the weights of edges in G. Let T and T' be the minimum spanning trees of G and G', respectively, with total weights t and t'. Which of the following statements is TRUE?",
        "answer": [
            " T' = T with total weight t' = t2",
            "T' = T with total weight t' < t2",
            " T' != T but total weight t' = t2",
            " None of the above"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> <strong>Squaring the weights of the edges in a weighted graph will not change the minimum spanning tree</strong>. Assume the opposite to obtain a contradiction. If the minimum spanning tree changes then at least one edge from the old graph G in the old minimum spanning tree T must be replaced by a new edge in tree T' from the graph G' with squared edge weights. The new edge from G' must have a lower weight than the edge from G. This implies that there exists some weights C1 and C2 such that C1 &lt; C2 and C12 &gt;= C22. This is a contradiction.\r\nSource: <a href=\"http://www.cs.nyu.edu/courses/spring06/V22.0310-001/hw3.htm\">http://www.cs.nyu.edu/courses/spring06/V22.0310-001/hw3.htm</a>\r\n\r\nSums of squares of two or more numbers is always smaller than square of sum.\r\nExample:  2^2 + 2^2 &lt; (4)^2\r\n\r\nBut <pre>there is one counter example when the graph has only one edge.  \r\n         In that case, the two values are same. </pre>\n</div>",
        "keyword": "Graph Minimum Spanning Tree"
    },
    {
        "question": "Consider the following graph:\r\n\n\n\r\nWhich one of the following is NOT the sequence of edges added to the minimum spanning tree using Kruskal's algorithm?\r\n",
        "answer": [
            "(b,e)(e,f)(a,c)(b,c)(f,g)(c,d)",
            "(b,e)(e,f)(a,c)(f,g)(b,c)(c,d)",
            "(b,e)(a,c)(e,f)(b,c)(f,g)(c,d)",
            "(b,e)(e,f)(b,c)(a,c)(f,g)(c,d)"
        ],
        "correct": "D",
        "explain": "<div class=\"mtq_explanation-text\"> In the sequence (b, e) (e, f) (b, c) (a, c) (f, g) (c, d) given option D, the edge (a, c) of weight 4 comes after (b, c) of weight 3.\r\n\r\nIn <a href=\"http://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/\" target=\"_blank\">Kruskal's Minimum Spanning Tree Algorithm</a>, we first sort all edges, then consider edges in sorted order, so a higher weight edge cannot come before a lower weight edge.</div>",
        "keyword": "Graph Minimum Spanning Tree"
    },
    {
        "question": "The number of distinct minimum spanning trees for the weighted graph below is ____\r\n\n\n",
        "answer": [
            "4",
            "5",
            "6",
            "7"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> Below diagram shows a minimum spanning tree. Highlighted (in <span style=\"color: #339966;\">green</span>) are the edges picked to make the MST.\r\n\r\n<a href=\"http://www.geeksforgeeks.org/wp-content/uploads/MST2.png\"><img alt=\"MST2\" class=\"aligncenter size-full wp-image-128831\" height=\"220\" src=\"http://www.geeksforgeeks.org/wp-content/uploads/MST2.png\" width=\"450\"/></a>\r\n\r\nIn the right side of MST, we could either pick edge ‘a’ or ‘b’. In the left side, we could either pick ‘c’ or ‘d’ or ‘e’ in MST.\r\n\r\nThere are 2 options for one edge to be picked and 3 options for another edge to be picked. Therefore, total 2*3 possible MSTs.\r\n</div>",
        "keyword": "Graph Minimum Spanning Tree"
    },
    {
        "question": "Let s and t be two vertices in a undirected graph G + (V, E) having distinct positive edge weights. Let [X, Y] be a partition of V such that s ∈ X and t ∈ Y. Consider the edge e having the minimum weight amongst all those edges that have one vertex in X and one vertex in Y\r\n\r\nThe edge e must definitely belong to:\t\t ",
        "answer": [
            "the minimum weighted spanning tree of G",
            "the weighted shortest path from s to t",
            "each path from s to t",
            "the weighted longest path from s to t"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> The minimum weight edge on any s-t cut is always part of MST. This is called <a href=\"https://en.wikipedia.org/wiki/Minimum_spanning_tree#Cut_property\">Cut Property</a>. \r\n\r\nThis is the idea used in <a href=\"http://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-minimum-spanning-tree-mst-2/\" target=\"_blank\">Prim's algorithm</a>.  The minimum weight cut edge is always a minimum spanning tree edge.\r\n\r\n<strong>Why B (the weighted shortest path from s to t) is not an answer?</strong>\r\nSee below example, edge 4 (lightest in highlighted red cut from s to t) is not part of shortest path.\r\n<a href=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2015/11/ShortestPathCut.png\"><img alt=\"ShortestPathCut\" class=\"alignnone size-full wp-image-20660\" height=\"208\" src=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2015/11/ShortestPathCut.png\" width=\"440\"/></a></div>",
        "keyword": "Graph Minimum Spanning Tree"
    },
    {
        "question": "What is the weight of a minimum spanning tree of the following graph ?\r\n\r\n",
        "answer": [
            "29",
            "31",
            "38",
            "41"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> (a,c), (a,d), (d,b), (b,g), (g,h), (h,f), (h,i), (i,j), (i,e) = 31\r\n \r\n\r\nBackground required - Minimum Spanning Tree (<a href=\"http://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-minimum-spanning-tree-mst-2/\">Prims</a> / <a href=\"http://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/\">Kruskal</a>)\r\n\r\nIn these type of questions, always go for kruskal’s algorithm to find out the the minimum spanning tree as it is easy and there are less chances of doing silly mistakes. \r\n\r\n<strong>Algorithm:</strong>\r\n\r\nAlways pick the minimum edge weight and try to add to current forest (Collection of Trees) if no cycle is formed else discard.\r\nAs soon as u have added n-1 edges to the forest, stop and you have got your minimum spanning tree.\r\n\r\nSee the below image for construction of MST of this question.\r\n\r\n<a href=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/12/graph.jpg\"><img alt=\"graph\" class=\"aligncenter size-full wp-image-28652\" height=\"960\" src=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/12/graph.jpg\" width=\"1280\"/></a> \r\n\r\nWeight of minimum spanning tree = Sum of all the edges in Minimum Spanning tree\r\n\t\t\t\t       = 31\r\n\r\nThis explanation has been provided by <strong>Pranjul Ahuja.</strong>\n<strong>Visit the following links to learn more:</strong>\r\nhttp://www.ics.uci.edu/~eppstein/161/960206.html\r\nhttps://en.wikipedia.org/wiki/Minimum_spanning_tree\r\n\r\n</div>",
        "keyword": "Graph Minimum Spanning Tree"
    },
    {
        "question": "Consider an undirected unweighted graph G. Let a breadth-first traversal of G be done starting from a node r. Let d(r,u) and d(r,v) be the lengths of the shortest paths from r to u and v respectively in G. If u is visited before v during the breadth-first traversal, which of the following statements is correct?",
        "answer": [
            "d(r, u) < d(r, v) ",
            "d(r,u) > d(r,v)",
            "d(r,u) <= (r,v) ",
            "None of the above"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> See question 4 of <a href=\"http://www.geeksforgeeks.org/data-structures-and-algorithms-set-8/\" target=\"_blank\">http://www.geeksforgeeks.org/data-structures-and-algorithms-set-8/</a></div>",
        "keyword": "Graph Minimum Spanning Tree"
    },
    {
        "question": "The graph shown below 8 edges with distinct integer edge weights. The minimum spanning tree (MST) is of weight 36 and contains the edges: {(A, C), (B, C), (B, E), (E, F), (D, F)}. The edge weights of only those edges which are in the MST are given in the figure shown below. The minimum possible sum of weights of all 8 edges of this graph is ______________.\r\n\r\n",
        "answer": [
            "66",
            "69",
            "68",
            "70"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> In every cycle, the weight of an edge that is not part of MST must by greater than or equal to weights of other edges which are part of MST.\r\n\r\nSince all edge weights are distinct, the weight must be greater.\r\n\r\nSo the minimum possible weight of ED is 7, minimum possible weight of CD is 16 and minimum possible weight of AB is 10. \r\n\r\nTherefore minimum possible sum of weights is 69.\r\n</div>",
        "keyword": "Graph Minimum Spanning Tree"
    },
    {
        "question": "Let G be connected undirected graph of 100 vertices and 300 edges. The weight of a minimum spanning tree of G is 500. When the weight of each edge of G is increased by five, the weight of a minimum spanning tree becomes ________.",
        "answer": [
            "1000",
            "995",
            "2000",
            "1995"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> Since there are 100 vertices, there must be 99 edges in Minimum Spanning Tree (MST).  \r\n\r\nWhen weight of every edge is increased by 5, the increment in weight of MST is = 99 * 5 = 495\r\n\r\nSo new weight of MST is 500 + 495 which is 995</div>",
        "keyword": "Graph Minimum Spanning Tree"
    },
    {
        "question": "Let G be a weighted connected undirected graph with distinct positive edge weights. If every edge weight is increased by the same value,  then which of the following statements is/are TRUE? \r\nP: Minimum spanning tree of G does not change\r\nQ: Shortest path between any pair of vertices does not change\r\n\n",
        "answer": [
            "P only\r\n\r\n\r\n",
            "Q only",
            "Neither P nor Q",
            "Both P and Q"
        ],
        "correct": "A",
        "explain": "<div class=\"mtq_explanation-text\"> The shortest path may change. The reason is, there may be different number of edges in different paths from s to t. For example, let shortest path be of weight 15 and has 5 edges. Let there be another path with 2 edges and total weight 25. The weight of the shortest path is increased by 5*10 and becomes 15 + 50. Weight of the other path is increased by 2*10 and becomes 25 + 20. So the shortest path changes to the other path with weight as 45.\r\n\r\nThe Minimum Spanning Tree doesn't change.  Remember the Kruskal's algorithm where we sort the edges first.  IF we increase all weights, then order of edges won't change.</div>",
        "keyword": "Graph Minimum Spanning Tree"
    },
    {
        "question": "Let G be a complete undirected graph on 4 vertices, having 6 edges with weights being 1, 2, 3, 4, 5, and 6.  The maximum possible weight that a minimum weight spanning tree of G can have is.\r\n\r\n[This Question was originally a Fill-in-the-Blanks question]",
        "answer": [
            "6",
            "7",
            "8",
            "9"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\"> One graph that has maximum possible weight of spanning tree\r\n\r\n<a href=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/02/gatesol.jpg\"><img alt=\"gatesol\" class=\"aligncenter size-full wp-image-23812\" height=\"233\" src=\"http://www.geeksforgeeks.org/wp-content/uploads/gq/2016/02/gatesol.jpg\" width=\"418\"/></a></div>",
        "keyword": "Graph Minimum Spanning Tree"
    },
    {
        "question": "G = (V, E) is an undirected simple graph in which each edge has a distinct weight, and e is a particular edge of G.  Which of the following statements about the minimum spanning trees (MSTs) of G is/are TRUE\r\n\r\nI.  If e is the lightest edge of some cycle in G, \r\n    then every MST of G includes e\r\nII. If e is the heaviest edge of some cycle in G, \r\n    then every MST of G excludes e\r\n",
        "answer": [
            "I only   ",
            " II only ",
            "both I and II ",
            "neither I nor II"
        ],
        "correct": "B",
        "explain": "<div class=\"mtq_explanation-text\">\n<strong>I is NOT true.</strong>\r\nLet G=(V, E) be a rectangular graph where V = {a, b, c, d} and E = {ab, bc, cd, da, ac}. \r\nLet the edges have weights: ab = 1, bc = 2, cd = 4, da = 5, ac = 3. Then, clearly, ac is the lightest edge of the cycle cdac, however, the MST abcd with cost 7 (= ab + bc + cd) does not include it.\r\nLet the edges have weights: ab = 6, bc - 7, cd = 4, da = 5, ac = 3. Then, again, ac is the lightest edge of the cycle cdac, and, the MST bacd with cost 13 (= ba + ac + cd) includes it.\r\nSo, the MSTs of G may or may not include the lightest edge.\r\n\r\n<strong>II is true</strong>\r\nLet the heavies edge be e. Suppose the minimum spanning tree which contains  e. If we add one more edge to the spanning tree we will create a cycle. Suppose we add edge e' to the spanning tree which generated cycle C. We can reduce the cost of the minimum spanning tree if we choose an edge other than e from C for removal which implies that e must not be in minimum spanning tree and we get a contradiction.\r\n\r\nSource: <a href=\"http://www.ece.northwestern.edu/~dda902/336/hw5-sol.pdf\">http://www.ece.northwestern.edu/~dda902/336/hw5-sol.pdf</a></div>",
        "keyword": "Graph Minimum Spanning Tree"
    },
    {
        "question": "What is the largest integer m such that every simple connected graph with n vertices and n edges contains at least m different spanning trees?",
        "answer": [
            "1",
            "2",
            "3",
            "n"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> A graph is connected iff all nodes can be traversed from each node. For a graph with n nodes, there will be n-1 minimum number of edges. <br/>\r\nGiven that there are n edges, that means a cycle is there in the graph.<br/>\r\nThe simplex graph with these conditions may be:<br/>\n<img alt=\"\" src=\"https://cdncontribute.geeksforgeeks.org/wp-content/uploads/gateit24.png\"/><br/>\r\n\r\n\r\nNow we can make a different spanning tree by removing one edge from the cycle, one at a time.<br/>\r\nMinimum cycle length can be 3, So, there must be atleast 3 spanning trees in any such Graph. \r\n</div>",
        "keyword": "Graph Minimum Spanning Tree"
    },
    {
        "question": "If Kruskal’s algorithm is used for finding a minimum spanning tree of a weighted graph G with n vertices and m edges and edge weights are already given in a sorted list, then, What will be the time complexity to compute the minimum cost spanning tree given that union and find operations take amortized O(1) ?",
        "answer": [
            "O(m logn)",
            "O(n)\r\n",
            " O(m)    ",
            "O(n logm)\r\n"
        ],
        "correct": "C",
        "explain": "<div class=\"mtq_explanation-text\"> \r\nO(m) as you are already given edge weights in sorted order. You just have to pick the edges in the increasing order and add it to the current spanning set if its addition does not result in a cycle else throw it away.\r\n</div>",
        "keyword": "Graph Minimum Spanning Tree"
    },
    {
        "question": "Consider a graph G=(V, E), where V = { v1,v2,…,v100 }, E={ (vi, vj) ∣ 1≤ii",
        "answer": "None",
        "correct": "None",
        "explain": "None",
        "keyword": "Graph Minimum Spanning Tree"
    }
]